<main class="main-container ng-scope" ng-view=""><div class="main receptacle post-view ng-scope"><article class="entry ng-scope" ng-controller="EntryCtrl" ui-lightbox=""><header><h1 class="entry-title ng-binding">Exploit开发系列教程-Mona 2& SEH</h1><div class="entry-meta"><a target="_blank" class="author name ng-binding">P3nro5e</a> <span class="bull">·</span> <time title="2015/07/10 10:58" ui-time="" datetime="2015/07/10 10:58" class="published ng-binding ng-isolate-scope">2015/07/10 10:58</time></div></header><section class="entry-content ng-binding" ng-bind-html="postContentTrustedHtml"><p></p><h1>0x00 Mona 2 前言 &amp; 准备</h1><hr><p>Mona 2是一种非常有用的插件，它由Corelan Team开发。起初是为Immunity Debugger写的，现在它适用于WinDbg调试器。</p><p>你将需要为WinDbg x86 和 WinDbg x64安装一些工具：</p><p>安装Python 2.7 (从<a href="https://www.python.org/downloads/">这里</a>可下载到) 。</p><p>x86 和 x64版本的工具分别安装在不同的目录里，如c:\python27(32) 和c:\python27。</p><p>从<a href="http://pykd.codeplex.com/">这里</a>下载正确的zip包（请下载pykd-0.2.0.29-python-2.7.zip这个压缩包），接着提取并运行vcredist&#95;x86.exe 和 vcredist&#95;x64.exe。</p><p><a href="http://pykd.codeplex.com/">从这里</a>下载两个exe程序（x86版和x64版），接着执行它们。</p><p><a href="https://github.com/corelan">从这里</a>下载windbglib.py和mona.py，并将它们放置到WinDbg.exe所在的目录中。</p><p><img alt="enter image description here" img-src="207eed1eab985d75d07e69f1624c1ed5045f145c.jpg"></p><p>配置符号搜索路径如下：</p><p>通过 <code>File→Symbol File Path</code></p><p>输入</p><pre><code>SRV*C:\windbgsymbols*http://msdl.microsoft.com/download/symbols
</code></pre><p>3.保存工作区(File→Save Workspace).</p><p>在WinDbg下运行mona.py</p><p>用WinDbg运行mona.py的范例:</p><p>1.使用如下命令加载pykd插件</p><pre><code>.load pykd.pyd
</code></pre><p>2.运行mona使用命令如下：</p><pre><code>!py mona
</code></pre><p><img alt="enter image description here" img-src="0a589bacd1d954d416488d2394f90df9a277313e.jpg"></p><p>更新mona 输入如下：</p><pre><code>!py mona update
</code></pre><p><img alt="enter image description here" img-src="83f726dd8ff82c441d09c485f98dec5a35883691.jpg"></p><h1>0x01 配置</h1><hr><p>工作目录</p><p>在mona的工作目录里，mona的多数函数将数据转储到已创建的文件中。我们可以具体指定某个工作目录，这取决于使用的格式说明符%p (process name) 和 %i (process id)指定的进程名和id。</p><p>例如，输入：</p><pre><code>workingfolder "C:\mona_files\%p_%i"
</code></pre><p>排除模块</p><p>你可以用如下操作排除指定模块:</p><pre><code>!mona config -set excluded_modules "module1.dll,module2.dll"
!mona config -add excluded_modules "module3.dll,module4.dll"
</code></pre><p>作者</p><p>你也可以设定作者:</p><pre><code>!mona config -set author Kiuhnm
</code></pre><p>当产生与metasploit兼容的输出内容时可以使用该信息。</p><p>重点</p><p>如果WinDbg和mona都没有出错，那么请试试以管理员身份运行WinDbg。</p><h1>0x02 Mona的手册</h1><hr><p>你可以在这里找到更多关于Mona的信息。</p><p>范例</p><p>该范例引用自Mona的手册. 现在来说明如下代码中我们控制的ECX的值：</p><pre><code>MOV   EAX, [ECX]
CALL   [EAX+58h]
</code></pre><p>我们想要使用那段代码以jmp到我们的shellcode(即我们注入到进程中的代码)，它的地址位于ESP+4，因此我们需要调用如上调用的一些指令，如<code>“ADD ESP, 4 | RET“</code>。上面的代码有许多间接的操作：</p><pre><code>(ECX = p1) → p2
p2+58h → p3 → “ADD ESP,4 | RET”
</code></pre><p>首先我们需要找到p3:</p><pre><code>!py mona config -set workingfolder c:\logs
!py mona stackpivot -distance 4,4
</code></pre><p>如上使用的命令可以让你在stackpivots内的指定偏移范围在mix~max之间找到等价于<code>ADD ESP, X | RET</code>代码的指针，通过选项<code>-distance min,max</code>来指定偏移范围。</p><p>已发现指针/地址会被写入到<code>c:\logs\stackpivot.txt</code>。</p><p>现在我们已经有我们的p3指针（许多p3指针！）了，我们还需找到p1:</p><pre><code>!py mona find -type file -s "c:\logs\stackpivot.txt" -x * -offset 58 -level 2 -offsetlevel 2
</code></pre><p>下面来了解那些选项的含义：</p><p>使用“-x *”选项意味着你要 “accept addresses in pages with any access level” (正如另一个范例所示, 用 “-x X”选项说明我们仅在可执行页中定位).</p><p>“-level 2”具体指定要间接操作的指令层级，它告知mona找出“a pointer (p1) to a pointer (p2)to a pointer (p3)”。 前两个选项 (-type 和 -s)指定ps必须是指针，它被列出在文件“c:\logs\stackpivot.txt“里。</p><p>使用“-offsetlevel 2” 和 “-offset 58”选项告知mona用偏移58h来进行增值操作时，第二个指针(p2)必须指向第三个指针(p3)。</p><p>如果这个范例并不能让你对其内容有较好的理解，请你不要担心。这个范例仅向你展示了WinDbg中利用Mona插件可以实现的一些功能。当然，我也承认这个命令的语法不是非常易懂。</p><p>范例</p><p>使用findwild命令可以让你找到带有特殊形式的指令链。 细想如下范例：</p><pre><code>!mona findwild -s "push r32 # * # pop eax # inc eax # * # retn"
</code></pre><p>选项”-s”指定链的形态:</p><p>用 ‘#‘将指令分隔开</p><p>r32 为任意32位寄存器</p><ul><li>为任意指令序列</li></ul><p>可选参数为:</p><ul><li>-depth <code>&lt;nr&gt;</code>: maximum length of the chain</li><li>-b <code>&lt;address&gt;</code>: base address for the search</li><li>-t <code>&lt;address&gt;</code>: top address for the search</li><li>-all: returns also chains which contain “bad” instructions, i.e. instructions that might break the chain (jumps, calls, etc…)</li></ul><p>ROP链</p><p>Mona可以找到ROP gadgets并利用它们构造ROP链，但是我将不在这部分讲解这方面的相关内容，因为这里我假设你并不知道ROP链的含义及关于ROP的概念。正如我曾说过的，如果这篇文章讲述的内容让你难以理解，那么请不要担心。尽管学习该系列的下一部分文章吧。</p><h1>0x03 结构化异常处理（SEH）</h1><hr><p>异常处理器以一种单链表的形式存在，它和每个线程有关。一般说来，链表的节点被分配在栈上。某一位于TEB (Thread Environment Block)的起始位置的指针指向链表头，因此当代码想要添加一个新的异常处理器时，某一新节点会被添加到链表头并且在TEB里的指针所指向的位置会被改变，进而指向新节点。</p><p>每个节点固有&#95;EXCEPTION&#95;REGISTRATION_RECORD类型并且会存储处理器的地址及链表下个节点的一个指针。奇怪的是，链表上一节点的“next pointer”不是null但是它等价于0xffffffff。</p><p>确切的定义如下：</p><pre><code>0:000&gt; dt _EXCEPTION_REGISTRATION_RECORD
ntdll!_EXCEPTION_REGISTRATION_RECORD
   +0x000 Next             : Ptr32 _EXCEPTION_REGISTRATION_RECORD
   +0x004 Handler          : Ptr32     _EXCEPTION_DISPOSITION
</code></pre><p>TEB可被段选择子fs访问（始于 fs:[0]）, 因此通常可看到代码如下：</p><pre><code>mov    eax, dword ptr fs:[00000000h]      ; retrieve the head
push   eax                                ; save the old head
lea    eax, [ebp-10h]
mov    dword ptr fs:[00000000h], eax      ; set the new head
.
.
.
mov    ecx, dword ptr [ebp-10h]           ; get the old head (NEXT field of the current head)
mov    dword ptr fs:[00000000h], ecx      ; restore the old head
</code></pre><p>编译器通常会注册单个全局句柄，它能意识到被程序执行过的区域（这依赖于某一全局变量）并且当它被调用时会有根据地作出行为。</p><p>因为每个线程都有一个不同的TEB，因此操作系统会确保段被fs选择，fs总会引用准确的TEB（即当前线程之一）。 通过读取与TEB的Self区域相符的 fs:[18h]得到TEB的地址。</p><p>列出TEB的信息如下：</p><pre><code>0:000&gt; !teb
TEB at 7efdd000
    ExceptionList:        003ef804          -----------------------
    StackBase:            003f0000
    StackLimit:           003ed000
    SubSystemTib:         00000000
    FiberData:            00001e00
    ArbitraryUserPointer: 00000000
    Self:                 7efdd000
    EnvironmentPointer:   00000000
    ClientId:             00001644 . 00000914
    RpcHandle:            00000000
    Tls Storage:          7efdd02c
    PEB Address:          7efde000
    LastErrorValue:       2
    LastStatusValue:      c0000034
    Count Owned Locks:    0
    HardErrorMode:        0
</code></pre><p>现在我们可以证实fs引用TEB：</p><pre><code>0:000&gt; dg fs
                                  P Si Gr Pr Lo
Sel    Base     Limit     Type    l ze an es ng Flags
---- -------- -------- ---------- - -- -- -- -- --------
0053 7efdd000 00000fff Data RW Ac 3 Bg By P  Nl 000004f3
</code></pre><p>正如我们在之前讲述过的， fs:18h含有TEB的地址:</p><pre><code>0:000&gt; ? poi(fs:[18])
Evaluate expression: 2130563072 = 7efdd000
</code></pre><p>记住：poi会对某一指针进行解引用操作并且使用‘?’来对某一表达式进行求值操作。 我们看看ExceptionList 指向的结构体名：</p><pre><code>0:000&gt; dt nt!_NT_TIB ExceptionList
ntdll!_NT_TIB
   +0x000 ExceptionList : Ptr32 _EXCEPTION_REGISTRATION_RECORD
</code></pre><p>正如我们已经说过的那样，这意味着每个节点会是&#95;EXCEPTION&#95;REGISTRATION_RECORD的某一实例。使用!slist命令展示出整个链表的信息：</p><pre><code>0:000&gt; !slist $teb _EXCEPTION_REGISTRATION_RECORD
SLIST HEADER:
   +0x000 Alignment          : 3f0000003ef804
   +0x000 Next               : 3ef804
   +0x004 Depth              : 0
   +0x006 Sequence           : 3f

SLIST CONTENTS:
003ef804
   +0x000 Next             : 0x003ef850 _EXCEPTION_REGISTRATION_RECORD
   +0x004 Handler          : 0x6d5da0d5     _EXCEPTION_DISPOSITION  MSVCR120!_except_handler4+0
003ef850
   +0x000 Next             : 0x003ef89c _EXCEPTION_REGISTRATION_RECORD
   +0x004 Handler          : 0x00271709     _EXCEPTION_DISPOSITION  +0
003ef89c
   +0x000 Next             : 0xffffffff _EXCEPTION_REGISTRATION_RECORD
   +0x004 Handler          : 0x77e21985     _EXCEPTION_DISPOSITION  ntdll!_except_handler4+0
ffffffff
   +0x000 Next             : ???? 
   +0x004 Handler          : ???? 
Can't read memory at ffffffff, error 0
</code></pre><p>记住$teb表示的是TEB的地址.</p><p>以下使用了一种更简洁的方法来展示异常处理链的信息：</p><pre><code>0:000&gt; !exchain
003ef804: MSVCR120!_except_handler4+0 (6d5da0d5)
  CRT scope  0, func:   MSVCR120!doexit+116 (6d613b3b)
003ef850: exploitme3+1709 (00271709)
003ef89c: ntdll!_except_handler4+0 (77e21985)
  CRT scope  0, filter: ntdll!__RtlUserThreadStart+2e (77e21c78)
                func:   ntdll!__RtlUserThreadStart+63 (77e238cb)
We can also examine the exception handler chain manually:
0:000&gt; dt 003ef804 _EXCEPTION_REGISTRATION_RECORD
MSVCR120!_EXCEPTION_REGISTRATION_RECORD
   +0x000 Next             : 0x003ef850 _EXCEPTION_REGISTRATION_RECORD
   +0x004 Handler          : 0x6d5da0d5     _EXCEPTION_DISPOSITION  MSVCR120!_except_handler4+0
0:000&gt; dt 0x003ef850 _EXCEPTION_REGISTRATION_RECORD
MSVCR120!_EXCEPTION_REGISTRATION_RECORD
   +0x000 Next             : 0x003ef89c _EXCEPTION_REGISTRATION_RECORD
   +0x004 Handler          : 0x00271709     _EXCEPTION_DISPOSITION  +0
0:000&gt; dt 0x003ef89c _EXCEPTION_REGISTRATION_RECORD
MSVCR120!_EXCEPTION_REGISTRATION_RECORD
   +0x000 Next             : 0xffffffff _EXCEPTION_REGISTRATION_RECORD
   +0x004 Handler          : 0x77e21985     _EXCEPTION_DISPOSITION  ntdll!_except_handler4+0
</code></pre><p></p></section></article><div class="entry-controls clearfix"><div style="float:left;color:#9d9e9f;font-size:15px"><span>&copy;乌云知识库版权所有 未经许可 禁止转载</span></div></div><div class="yarpp-related"><h3>为您推荐了适合您的技术文章:</h3><ol id="recommandsystem"><li><a href="http://drops.wooyun.org/tips/10382" rel="bookmark" id="re1">Exploit开发系列教程-Exploitme2 (Stack cookies &amp; SEH)</a></li><li><a href="http://drops.wooyun.org/tips/6813" rel="bookmark" id="re2">Exploit开发系列教程-Windbg</a></li><li><a href="http://drops.wooyun.org/tips/7275" rel="bookmark" id="re3">Exploit开发系列教程-Heap</a></li><li><a href="http://drops.wooyun.org/tips/9948" rel="bookmark" id="re4">Exploit开发系列教程-Exploitme1 (“ret eip” overwrite) &amp;More space on stack</a></li></ol></div><div id="comments" class="comment-list clearfix"><div id="comment-list"></div></div></div></main>