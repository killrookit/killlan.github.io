<main class="main-container ng-scope" ng-view=""><div class="main receptacle post-view ng-scope"><article class="entry ng-scope" ng-controller="EntryCtrl" ui-lightbox=""><header><h1 class="entry-title ng-binding">从Android运行时出发，打造我们的脱壳神器</h1><div class="entry-meta"><a target="_blank" class="author name ng-binding">zyq8709</a> <span class="bull">·</span> <time title="2015/10/03 10:03" ui-time="" datetime="2015/10/03 10:03" class="published ng-binding ng-isolate-scope">2015/10/03 10:03</time></div></header><section class="entry-content ng-binding" ng-bind-html="postContentTrustedHtml"><p></p><h1>0x00 前言</h1><hr><p>之前对Android的两个运行时的源码做了一些研究，又加上如火如荼的Android加固服务的兴起，便产生了打造一个用于脱壳的运行时，于是便有了DexHunter的诞生（源码：<a href="https://github.com/zyq8709/DexHunter/">https://github.com/zyq8709/DexHunter/</a>）。今天，我就通过这篇小文聊聊我的一些简单的思路，供大家参考和讨论。</p><h1>0x02 相关机制</h1><hr><p>首先，先来看一看Android运行时的一些相关机制，看看我们来怎么搞。</p><p>首当其冲，要脱壳少不了研究一下Dex文件的格式，这一点Android的官方文档写的已经很清晰了，我这里就简单再提一下。整个结构便如图1所示：</p><p><img alt="" img-src="25e40e40f920c879810350a1d3ba28ff645a2bac.jpg"></p><p>图1 Dex文件结构</p><p>其实就是分区段存储不同的内容，在头部里有指向各个区段起始的偏移值。当然我们最关心的就是class_defs和data这两个段了。</p><p>class&#95;defs包含了所有的类，用class&#95;def&#95;item来描述。图2是对class&#95;def_item展开的一个示意图：</p><p><img alt="" img-src="519e79840a7625f240d2a8cd28fa1fa38da2a243.jpg"></p><p>图2 class&#95;def&#95;item结构</p><p>每个class&#95;def&#95;item指向一个class&#95;data&#95;item，每个class&#95;data&#95;item 包含了一个class的数据，每个方法用encoded&#95;method结构来描述，它又指向了一个code&#95;item，这个里面就保存着一个方法的所有指令。</p><p>对于ART下，安装后的dex文件会被编译为oat文件，这个oat文件其实是一个ELF文件，图3是它的一个结构：</p><p><img alt="" img-src="5236597778eae76da1eaf25c785e6987a179870f.jpg"></p><p>图3 OAT文件结构</p><p>其中可以看到oatdata指向的部分包含了原有的Dex文件，这个是我们的目标。当然oatexec指向了编译后的ARM指令，但是对于我们暂时来说没有什么卵用。</p><h1>0x03 四个时机</h1><hr><p>为了脱壳，我们要建立一个概念，就是“时机”。对于非虚拟机壳，从内存中转储是一个最为有效和统用的技巧，那么就必须要找到一个时机，保证内存中的数据是完全正确的。</p><p>在Android中呢，便有这么四个时机：</p><ol><li><p>打开Dex文件</p><p>就是把APK中的dex文件提取并做cache，那么最终打开的其实是odex或oat文件；</p></li><li><p>加载Class</p><p>运行时读取存储在Dex中的每个class，并用来填充一个生成的Class对象，其中包含了class的所有成员，这样一个class才能被使用；图4表示了ART和DVM下的Class对象的结构</p><p><img alt="" img-src="ff598a218d81ab60d04c78ed07397877fe636280.jpg"></p><p><img alt="" img-src="eff7d3a62bad9f9038c36e555773e181b279817d.jpg"></p><p>图4 Class的结构</p></li><li><p>初始化Class</p><p>如果一个class有static块，那么这个部分就会编译为类的初始化器，具体看说就是<clinit>方法，在class真正需要被使用的时候就会执行它，当然，壳就可以利用它来做许多事情；</clinit></p></li><li><p>调用具体的方法</p><p>不用多说，就是根据生成的Class对象查找到具体的代码指令并执行了。</p></li></ol><h1>0x04 两种加载</h1><hr><p>好，那我们怎么做呢？很简单，我们就从类的加载开始。</p><p>总的来说，有两种可以加载类的方法，一个是显示加载，主要用于反射，就是通过调用Class.forName()或ClassLoader.loadClass()方法来主动加载一个类；另一个是隐式加载，主要是通过创建第一个class的实例或在类产生前访问静态成员时发生。这些操作的背后在运行时中是有相应的函数来真正完成的。</p><p>在ART中：</p><p>显式加载：</p><p>ClassLoader.loadClass 对应DexFile_defineClassNative</p><p>Class.forName 对应Class_classForName</p><p>隐式加载：</p><p>对应artAllocObjectFromCode</p><p>图5表述了这个关系：</p><p><img alt="" img-src="efb450c40c51ea348d5a5813fdb07f263911be9e.jpg"></p><p>图5 ART中的实现</p><p>在DVM中：</p><p>显式加载：</p><p>ClassLoader.loadClass对应Dalvik&#95;dalvik&#95;system&#95;DexFile&#95;defineClassNative</p><p>Class.forName对应Dalvik&#95;java&#95;lang&#95;Class&#95;classForName</p><p>隐式加载：</p><p>对应dvmResolveClass</p><p>图6是DVM中的实现表示：</p><p><img alt="" img-src="b2e903f9d91a1263bbd4b42b96ea3bd9d2d581a1.jpg"></p><p>图6 DVM中的实现</p><h1>0x05 开始修改</h1><hr><p>很清晰看到，我们找到了关键点，在ART中是DefineClass，DVM中是Dalvik&#95;dalvik&#95;system&#95;DexFile&#95;defineClassNative，我们就从这里动手，主要的修改就发生在这里。简单地说就是主动地一次性加载并初始化所有的类。</p><p>这样做是隐含了几条原则的：</p><ul><li>当类被加载时，dex中对应的部分必须有效；</li><li>类初始化的时候，dex中的内容包括生成的Class对象是可以被修改的；</li><li>只有在执行一个方法时，才要求code_item是有效的。</li></ul><p>图7就是DexHunter的一个工作流程：</p><p><img alt="" img-src="211aa8bc4f750d0f5df9e6bf5c08bea2007dc5be.jpg"></p><p>图7 DexHunter原理</p><p>下面就分这几个步骤来说：</p><p><strong>（1） 定位内存</strong></p><p>对于之前提到的入口函数，都有一个参数表示在操作的文件。</p><p>ART中，这个参数是DexFile对象，其中有一个location_成员，是一个字符串，可以简单的理解为此文件的路径。那么DVM中是DexOrJar，相对的字符串成员是fileName。这下我们就好整了，只要我们指定了目标字符串，我们就可以从可能使用的众多dex文件中找出我们想要的那个，而且方便的是，通过这两个对象，我们还能很容易找到操作的文件在内存中的起始地址和长度。</p><p><strong>（2） 主动加载并初始化</strong></p><p>这个就是遍历dex文件中class&#95;defs区段里每一个class&#95;def_item，并逐一加载和初始化，在ART里我们使用FindClass函数来加载类，EnsureInitialized进行初始化；在DVM中用dvmDefineClass加载，dvmIsClassInitialized 和dvmInitClass来初始化。</p><p><strong>（3） 转储并自动修复</strong></p><p>最后就是真正抓取dex了。把dex分为三部分：</p><ul><li>Part 1: class_defs之前的内容</li><li>Part 2: class_defs段</li><li>Part 3: class_defs后边的部分</li></ul><p>我们把Part 1存在part1文件里，Part 3存在data文件中，Part 2先不要急。</p><p>现在我们要解析class&#95;defs的东东了。不整代码了，用文字简单来说，就是模仿Android的过程，我们把每个class&#95;data_item解码为内存中的对象（有LEB128编码），便于我们的修复。</p><p>下边就要进行一些判断看需不需要修复：</p><p>看class&#95;def&#95;item中的 class&#95;data&#95;off是不是在之前拿到的dex文件的内存范围内，如果跑出去了，就需要把这个类的class&#95;data&#95;item给放到dex尾部去，修改class&#95;def&#95;item并保存。</p><p>比较解析出来的accessflag、codeoff和运行时生成的方法对象的accessflag、codeoff，如果不一致，以运行时中的为准，并修改保存。</p><p>同样，检查code&#95;item&#95;off是否出界了，一旦出界，把code&#95;item收回来，继续向尾部添加，并修改class&#95;def_item的相关内容重新保存。</p><p>当然了，所谓放到尾部，只是先保证偏移值从尾部开始的，真正的内容先存在extra文件了。被修改过的class_defs段，就保存在classdef文件中了。</p><p>然后我们把四个文件重新拼起来，就得到原始的dex或odex了。</p><h1>0x06 有趣的现象</h1><hr><p>最后聊一下我们看到的一些有趣的现象。</p><p>360基本上是把原始的dex加密存在了一个so中，加载之前解密。</p><p>阿里把一些class&#95;data&#95;item和code&#95;item拆出去了，打开dex时会修复之间的关系。同时一些annotation&#95;off是无效的的来防止静态解析。</p><p>百度是把一些class&#95;data&#95;item拆走了，与阿里很像，同时它还会抹去dex文件的头部；它也会选择个别方法重新包装，达到调用前还原，调用后抹去的效果。我们可以通过对DoInvoke (ART)和dvmMterp_invokeMethod (DVM)监控来获取到相关代码。</p><p>梆梆和爱加密与360的做法很像，梆梆把一堆read,write, mmap等libc函数hook了，防止读取相关dex的区域，爱加密的字符串会变，但是只是文件名变目录不变。</p><p>腾讯针对于被保护的类或方法造了一个假的class&#95;data&#95;item，不包含被保护的内容。真正的class&#95;data&#95;item会在运行的时候释放并连接上去，但是code&#95;item却始终存在于dex文件里，它用无效数据填充annotation&#95;off和debug&#95;info&#95;off来实现干扰反编译。</p><h1>0x07 参考</h1><hr><pre><code>https://source.android.com/devices/tech/dalvik/dex-format.html
/libcore/libart/src/main/java/java/lang/ClassLoader.java
/libcore/libdvm/src/main/java/java/lang/ClassLoader.java
/libcore/dalvik/src/main/java/dalvik/system/DexClassLoader.java
/libcore/dalvik/src/main/java/dalvik/system/PathClassLoader.java
https://github.com/anestisb/oatdump_plus#dalvik-opcode-changes-in-art
</code></pre><p></p></section></article><div class="entry-controls clearfix"><div style="float:left;color:#9d9e9f;font-size:15px"><span>&copy;乌云知识库版权所有 未经许可 禁止转载</span></div></div><div id="comments" class="comment-list clearfix"><div id="comment-list"><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">eachcan</span> <span class="reply-time">2016-03-19 16:17:21</span></div><p></p><p>@wdydxf 目前都针对DexHunter以及类似的修改过 dvm 的系统进行检测。具体原理不太清楚，猜测是探测一些特征。我正尝试修改DexHunter的机制，看能不能通过 Clone 内存到磁盘，进行后续分析。而不是当时拦截。</p><p></p></div></div><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">wdydxf</span> <span class="reply-time">2015-12-16 22:50:46</span></div><p></p><p>最新版梆梆加固，加载招商银行的“掌上生活”apk， apk好像会自动检测， 总是报告：“检查出客户端异常，请卸载后重新安装”。 然后就自动关闭了。 请问我应该从哪里入手解决这个问题？</p><p></p></div></div><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">Knight</span> <span class="reply-time">2015-10-04 20:39:31</span></div><p></p><p>具体如何操作？可否出下教程。</p><p></p></div></div><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">高小厨</span> <span class="reply-time">2015-10-03 11:17:45</span></div><p></p><p>感谢分享</p><p></p></div></div></div></div></div></main>