<main class="main-container ng-scope" ng-view=""><div class="main receptacle post-view ng-scope"><article class="entry ng-scope" ng-controller="EntryCtrl" ui-lightbox=""><header><h1 class="entry-title ng-binding">CVE-2015-7547简单分析与调试</h1><div class="entry-meta"><a target="_blank" class="author name ng-binding">mrh</a> <span class="bull">·</span> <time title="2016/02/23 10:42" ui-time="" datetime="2016/02/23 10:42" class="published ng-binding ng-isolate-scope">2016/02/23 10:42</time></div></header><section class="entry-content ng-binding" ng-bind-html="postContentTrustedHtml"><p></p><h1>0x00 漏洞信息</h1><hr><p>最近glibc有一个栈溢出的漏洞具体情况，漏洞的具体信息可以参考下面链接。</p><p><a href="https://googleonlinesecurity.blogspot.com/2016/02/cve-2015-7547-glibc-getaddrinfo-stack.html">CVE-2015-7547: glibc getaddrinfo stack-based buffer overflow</a></p><p>poc在github上：https://github.com/fjserna/CVE-2015-7547</p><h1>0x01 环境准备</h1><hr><pre><code>操作系统：ubuntu15.04
glibc版本：glibc-2.2.0
</code></pre><h2>1.1 glibc源码编译</h2><p>在ubuntu系统下，只需要执行源码和调试符的命令之后就可以使用gdb对glibc的跟踪调试，安装指令如下：</p><pre><code>sudo apt-get install libc6-dbg
sudo apt-get source libc6-dev
</code></pre><p>但是因为系统自带的glibc是<strong>发行版</strong>的，所以在编译的是时候选用了优化参数 <code>-O2</code>,所以在调试的过程中会出现<strong>变量被优化无法读取</strong>以及代码运行的时候与<strong>源码的行数</strong>对不上的情况。</p><p><strong>所以需要自己编译一个可调式并且没有过度优化的glibc来进行调试。</strong></p><p>首先，从glibc的官网下载glibc的源码。我选择了2.20的版本。编译安装glibc的方法很容易可以在网上找到。需要注意的是在进行configure时需要设置一些特殊的参数。如果需要调试宏可以添加 -gdwarf-2,glibc无法使用-O0编译，不过-O1也够用了。</p><pre><code>/opt/glibc220/configure --prefix=/usr/local/glibc220/ --enable-debug CFLAGS="-g -O1" CPPFLAGS = "-g -O1"
</code></pre><p>在<code>configure</code>执行完成之后只需要简单执行编译与安装就好了。</p><pre><code>sudo make
sudo make install
</code></pre><h2>1.2 使用调试版本glibc编译POC</h2><p>在glibc编译安装成功后，系统默认的glibc还是原来的那个。所以需要选择指定的glibc来编译POC代码。</p><pre><code>gcc -o client CVE-2015-7547-client.c -Wl,-rpath /usr/local/glibc220
</code></pre><p>通过ldd指令可以看到，确实使用了刚编的glibc。<img alt="ldd ./client" img-src="1e10a62a13a4724be919284579c67c4f5eb2ee17.jpg"></p><p>这个时候就可以用GDB调试glibc中的函数了。</p><h2>1.3 配置本地dns服务器</h2><p>运行poc的python服务器。修改<code>/etc/resolv.conf</code>。将域名服务器改为127.0.0.1就好了。不过这样一来这台机器访问网络就会出问题了。</p><pre><code>nameserver 127.0.0.1
</code></pre><h1>0x02 漏洞分析</h1><hr><h2>2.1 运行POC</h2><p>使用gdb启动客户端直接运行，出现崩溃堆栈。</p><p><img alt="crash" img-src="d0b4794a3167529a3c5b8c4eb758ac13c4a8ea88.jpg"></p><h2>2.2 寻找溢出函数</h2><p>可以看到栈都被覆盖为0x42424242,根据<a href="https://googleonlinesecurity.blogspot.com/2016/02/cve-2015-7547-glibc-getaddrinfo-stack.html">google提供的分析</a>,出问题的是send_dg和send_vc函数。分别在send_vc和send_dg上下断点，重新运行程序，会发现先调用send_dg函数再调用send_vc函数。</p><p><img alt="寻找溢出函数" img-src="dce45d0f06797660929e43fc4b2e7e1dec8532e3.jpg"></p><p>可以看出是在send_vc的时候发生了栈溢出。</p><p>因为根据<a href="https://googleonlinesecurity.blogspot.com/2016/02/cve-2015-7547-glibc-getaddrinfo-stack.html">google提供的分析</a>可以知道是在读取socket的时候发生的溢出，可以通过结合源码调试来分析。剔除不需要看的代码，核心代码如下，总共干了四件事。</p><pre><code>[1]选择适当的缓存
[2]读取dns包的长度
[3]读取dsn包
[4]判断是否需要读取第二个数据包。
</code></pre><p><br></p><pre><code>#!c
static int
send_vc(res_state statp,
    const u_char *buf, int buflen, const u_char *buf2, int buflen2,
    u_char **ansp, int *anssizp,
    int *terrno, int ns, u_char **anscp, u_char **ansp2, int *anssizp2,
    int *resplen2, int *ansp2_malloced)
{
    const HEADER *hp = (HEADER *) buf;
    const HEADER *hp2 = (HEADER *) buf2;
    u_char *ans = *ansp;
    int orig_anssizp = *anssizp;

    [...]                               //这段干的事情可以无视。                           

 read_len:
    //----------------[2]-------------start----------------
    cp = (u_char *)&amp;rlen16;
    len = sizeof(rlen16);
    while ((n = TEMP_FAILURE_RETRY (read(statp-&gt;_vcsock, cp,  
                         (int)len))) &gt; 0) {
        cp += n;
        if ((len -= n) &lt;= 0)
            break;
    }
    if (n &lt;= 0) {
        [...]   //出错处理无视。
    }
    int rlen = ntohs (rlen16); 
    //----------------[2]-------------end----------------

    //----------------[1]-------------start----------------
    int *thisanssizp;
    u_char **thisansp;
    int *thisresplenp;
    if ((recvresp1 | recvresp2) == 0 || buf2 == NULL) { //第一次从read_len开始读取网络包进入这个分支。
        thisanssizp = anssizp;                          //第一次调用read时可用内存65536
        thisansp = anscp ?: ansp;                       //第一次调用read时使用的缓存anscp  
        assert (anscp != NULL || ansp2 == NULL);
        thisresplenp = &amp;resplen;
    } else {
        if (*anssizp != MAXPACKET) { 
            [...]                                       //重现流程中不会进入这块。
        } else {
            /* The first reply did not fit into the
               user-provided buffer.  Maybe the second
               answer will.  */
            *anssizp2 = orig_anssizp;                   //第二次调用时可用内存长度65536
            *ansp2 = *ansp;                             //第二次调用read时使用的缓存ansp
        }

        thisanssizp = anssizp2;
        thisansp = ansp2;
        thisresplenp = resplen2;
    }
    //----------------[1]-------------end----------------


    anhp = (HEADER *) *thisansp;    

    *thisresplenp = rlen;
    if (rlen &gt; *thisanssizp) { 
        [...]       //重现流程中不会进入这块。
    } else
        len = rlen;

    if (__glibc_unlikely (len &lt; HFIXEDSZ))       {
        [...]       //重现流程中不会进入这块。
    }

    cp = *thisansp; //*ansp;
    //---------------[2]--------------------start-----------------
    while (len != 0 &amp;&amp; (n = read(statp-&gt;_vcsock, (char *)cp, (int)len)) &gt; 0){ //溢出点。
        cp += n;
        len -= n;
    }
    //---------------[2]--------------------start-----------------


    if (__glibc_unlikely (n &lt;= 0))       {
        [...]       //重现流程中不会进入这块。
    }
    if (__glibc_unlikely (truncating))       {
        [...]       //重现流程中不会进入这块。
    }
    /*
     * If the calling application has bailed out of
     * a previous call and failed to arrange to have
     * the circuit closed or the server has got
     * itself confused, then drop the packet and
     * wait for the correct one.
     */

    //---------------[4]--------------------start-----------------
    if ((recvresp1 || hp-&gt;id != anhp-&gt;id)                   //不进。
        &amp;&amp; (recvresp2 || hp2-&gt;id != anhp-&gt;id)) {
        [...]       //重现流程中不会进入这块。
        goto read_len;
    }

    /* Mark which reply we received.  */
    if (recvresp1 == 0 &amp;&amp; hp-&gt;id == anhp-&gt;id)               //第一次运行recvresp1=1 recvresp2=0
      recvresp1 = 1;
    else
      recvresp2 = 1;
    /* Repeat waiting if we have a second answer to arrive.  */
    if ((recvresp1 &amp; recvresp2) == 0)                       // 调用goto，回到前面。
        goto read_len;
    //---------------[4]--------------------end-----------------
    /*
     * All is well, or the error is fatal.  Signal that the
     * next nameserver ought not be tried.
     */
    return resplen;
}
</code></pre><p>根据源码分析，从socket读取网络包数据的时候是溢出的地方，所以在这里下断点。</p><pre><code>gdb&gt; b res_send.c:853
</code></pre><p><img alt="寻找溢出函数" img-src="f7f6c2d31156230bc7672826debebca510671c11.jpg"></p><p>通过调用栈可以得知，read发生了两次[4]，而且第一次是正确的，在第二次read之后发生了溢出。通过[1]可以得知，在两次调用read的时候cp指向的内存不同。</p><p>第一次调用<code>read</code>函数时，缓冲区为<strong>anscp</strong>指向的内存。</p><p>第二次调用<code>read</code>函数时，缓冲区为<strong>ansp</strong>指向的内存。<strong>这里暂时不用考虑二级指针的问题。</strong></p><p>可以断定，ansp指针索引的地址出现了问题。ansp是调用时从参数传入的。所以需要通过分析send_vc的调用函数。</p><h2>2.3 内存分配错误</h2><p>send_vc的调用函数如下：</p><pre><code>#!c
int
__libc_res_nsend(res_state statp, const u_char *buf, int buflen,
         const u_char *buf2, int buflen2,
         u_char *ans, int anssiz, u_char **ansp, u_char **ansp2,
         int *nansp2, int *resplen2, int *ansp2_malloced)
{
  [...]
  if (__glibc_unlikely (v_circuit))       {
            /* Use VC; at most one attempt per server. */
            try = statp-&gt;retry;
            n = send_vc(statp, buf, buflen, buf2, buflen2,  //statp状态，buff，bufflen第一组发送数据，buff，2bufflen2第二组发送数据。
                    &amp;ans, &amp;anssiz, &amp;terrno,                 //u_char **ansp, int *anssizp,int *terrno,
                    ns, ansp, ansp2, nansp2, resplen2,      //int ns, u_char **anscp, u_char **ansp2, int *anssizp2,int *resplen2,              
                    ansp2_malloced);                        //int *ansp2_malloced
            if (n &lt; 0)
                return (-1);
            if (n == 0 &amp;&amp; (buf2 == NULL || *resplen2 == 0))
                goto next_ns;
        } else {
            /* Use datagrams. */                            //经过send_dg函数调用，ansp指向65536buff，ans指向2048buff。
            n = send_dg(statp, buf, buflen, buf2, buflen2,
                    &amp;ans, &amp;anssiz, &amp;terrno,
                    ns, &amp;v_circuit, &amp;gotsomewhere, ansp,
                    ansp2, nansp2, resplen2, ansp2_malloced);
            if (n &lt; 0)
                return (-1);
            if (n == 0 &amp;&amp; (buf2 == NULL || *resplen2 == 0))
                goto next_ns;
            if (v_circuit)
              // XXX Check whether both requests failed or     Z
              // XXX whether one has been answered successfully
                goto same_ns;
        }
  [...]
}
</code></pre><p>因为在调用<code>send_vc</code>之前程序先调用了<code>send_dg</code>，且两个函数参数基本相同，通过阅读源码会发现，<code>send_dg</code>对参数进行修改及新内存的申请。</p><pre><code>#!c
static int
send_dg(res_state statp,
    const u_char *buf, int buflen, const u_char *buf2, int buflen2,
    u_char **ansp, int *anssizp,
    int *terrno, int ns, int *v_circuit, int *gotsomewhere, u_char **anscp,
    u_char **ansp2, int *anssizp2, int *resplen2, int *ansp2_malloced)
{
    //ans指向大小为2048的缓冲器
    //ansp指向ans
    //anscp指向ans
    const HEADER *hp = (HEADER *) buf;
    const HEADER *hp2 = (HEADER *) buf2;
    u_char *ans = *ansp;
    int orig_anssizp = *anssizp;
    struct timespec now, timeout, finish;
    struct pollfd pfd[1];
    int ptimeout;
    struct sockaddr_in6 from;
    int resplen = 0;
    int n;

    [...]
  else if (pfd[0].revents &amp; POLLIN) {
        int *thisanssizp;
        u_char **thisansp;
        int *thisresplenp;

        if ((recvresp1 | recvresp2) == 0 || buf2 == NULL) { //send_dg第一次进入这个分支。
            thisanssizp = anssizp;
            thisansp = anscp ?: ansp;                       //thisansp被赋值为anscp
            assert (anscp != NULL || ansp2 == NULL);
            thisresplenp = &amp;resplen;
        } else {
            [...]                                           //第一次调用不会进入。
        }

        if (*thisanssizp &lt; MAXPACKET
            /* Yes, we test ANSCP here.  If we have two buffers
               both will be allocatable.  */
            &amp;&amp; anscp
#ifdef FIONREAD
            &amp;&amp; (ioctl (pfd[0].fd, FIONREAD, thisresplenp) &lt; 0
            || *thisanssizp &lt; *thisresplenp)
#endif
                    ) {
            u_char *newp = malloc (MAXPACKET);
            if (newp != NULL) {
                *anssizp = MAXPACKET;                       //anssizp谁为65536
                *thisansp = ans = newp;                     //anscp指向65536的buffer,但是ansp指向仍然指向原来的2048的buffer
                if (thisansp == ansp2)
                  *ansp2_malloced = 1;
            }
        }
</code></pre><p><img alt="寻找溢出函数" img-src="057a4ccae657626885fac0302ab1c8c9fb55bf52.jpg"></p><p>通过调试可以看出，ansp仍然指向大小为2048的缓冲区，而anscp指向了大小为65536的缓冲区。之后这两个指针又被传递给了send_vc。</p><h2>2.4 溢出原因</h2><p>所以溢出的原因是，<code>*anssizp</code>因为在之前的<code>send_dg</code>中被赋值为65536，<code>send_vc</code>中第二次调用<code>read</code>函数时，认为ansp指向的缓冲区的大小为<code>*anssizp</code>即65536，而实际上ansp指向了一块只有2048大小的缓冲区。所以在从socket读取大于2048个字节之后产生了栈溢出。</p><p><img alt="寻找溢出函数" img-src="f6a7147d95f5d26b603acbf5681f7c92fe22604f.jpg"></p><h1>0x03 参考&amp;感谢</h1><hr><p>感谢分享：）</p><ol><li><p>CVE-2015-7547 --- glibc getaddrinfo() stack-based buffer overflow</p><p>https://sourceware.org/ml/libc-alpha/2016-02/msg00416.html</p></li><li><p>Linux glibc再曝漏洞：可导致Linux软件劫持</p><p>http://www.freebuf.com/news/96244.html</p></li><li><p>CVE-2015-7547: glibc getaddrinfo stack-based buffer overflow</p><p>https://googleonlinesecurity.blogspot.com/2016/02/cve-2015-7547-glibc-getaddrinfo-stack.html</p></li><li><p>glibc编译debug版本</p><p>http://blog.csdn.net/jichl/article/details/7951996</p></li><li><p>glibc的编译和调试</p><p>http://blog.chinaunix.net/uid-20786208-id-4980168.html</p><p>​</p></li></ol><p></p></section></article><div class="entry-controls clearfix"><div style="float:left;color:#9d9e9f;font-size:15px"><span>&copy;乌云知识库版权所有 未经许可 禁止转载</span></div></div><div class="yarpp-related"><h3>为您推荐了适合您的技术文章:</h3><ol id="recommandsystem"><li><a href="http://drops.wooyun.org/papers/7073" rel="bookmark" id="re1">OpenSSL-CVE-2015-1793漏洞分析</a></li><li><a href="http://drops.wooyun.org/papers/9159" rel="bookmark" id="re2">深度调查CVE-2015-5477&#038;CloudFlare Virtual DNS如何保护其用户</a></li><li><a href="http://drops.wooyun.org/papers/4972" rel="bookmark" id="re3">[CVE-2015-2080] Jetty web server 远程共享缓冲区泄漏</a></li><li><a href="http://drops.wooyun.org/papers/8988" rel="bookmark" id="re4">WordPress Vulnerability Analysis (CVE-2015-5714 &amp; CVE-2015-5715)</a></li></ol></div><div id="comments" class="comment-list clearfix"><div id="comment-list"><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">theVita</span> <span class="reply-time">2016-02-25 11:15:16</span></div><p></p><p>如果是同一份poc的话，会走send_dg 的，抓份包不就知道了么，send_dg 的response 设置了truncated flag，client会选择用tcp model重试，send_dg 返回，进入send_vc，所以那份poc也是写的莫民奇妙，看着好像用了原文中的某种翻转response顺序的促发方式，但事实上不是那么回事。</p><p></p></div></div><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">mrh</span> <span class="reply-time">2016-02-24 20:48:57</span></div><p></p><p>@fafafaafafa /opt/glibc220/configure --prefix=/usr/local/glibc220/ --enable-debug CFLAGS=&quot;-g -O1&quot; CPPFLAGS = &quot;-g -O1&quot;<br>后面参数设置好，其他就和网上的源码安装是一样的</p><p></p></div></div><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">mrh</span> <span class="reply-time">2016-02-24 20:47:58</span></div><p></p><p>@k0_pwn 恩，不知道你为何没有触发send_dg，poc中有一段是先调用了UPD的线程，glibc也是再先调用send_dg做了内存的布局，之后send_vc在tcp的流程处理才会上触发了溢出，我再去看一下是不是我遗漏了什么，<a class="__cf_email__" href="/cdn-cgi/l/email-protection" data-cfemail="c623625c2e766486adf6">[email&#160;protected]</a>_pwn兄的指点：）。</p><p></p></div></div><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">fafafaafafa</span> <span class="reply-time">2016-02-24 20:18:55</span></div><p></p><p>怎么对glibc进行编译</p><p></p></div></div><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">k0_pwn</span> <span class="reply-time">2016-02-24 14:45:39</span></div><p></p><p>@mrh 原来是dirge兄，我感觉这个漏洞分析有一点问题，我在调试过程中发现没有进入send_dg函数。。应该是直接在send_vc函数，在nss_dns_gethostbyname4_r之前通过alloca申请的2048空间，在进入res_nsend后调用了send_vc函数，那个send_dg函数好像是if语句的另一个分支，在调试send_vc入口位置可以看到参数ansp对应的地址是bfffd65c，在send_vc函数中可以看到有一处赋值调用的是**ansp，anps的地址中存放的值是bfffe340，正好是2048当时申请的空间。。后续分析和你在send_vc中的分析是基本一致的。。</p><p></p></div></div><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">mrh</span> <span class="reply-time">2016-02-23 20:45:22</span></div><p></p><p>@k0_pwn 没注意小字 两边都投了：）</p><p></p></div></div><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">k0_pwn</span> <span class="reply-time">2016-02-23 15:13:55</span></div><p></p><p>这不是看雪上那篇吗？转载？</p><p></p></div></div><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">mickey</span> <span class="reply-time">2016-02-23 12:01:43</span></div><p></p><p>厉害</p><p></p></div></div></div></div></div></main>