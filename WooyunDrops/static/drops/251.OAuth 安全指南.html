<main class="main-container ng-scope" ng-view=""><div class="main receptacle post-view ng-scope"><article class="entry ng-scope" ng-controller="EntryCtrl" ui-lightbox=""><header><h1 class="entry-title ng-binding">OAuth 安全指南</h1><div class="entry-meta"><a target="_blank" class="author name ng-binding">∑-TEAM</a> <span class="bull">·</span> <time title="2014/05/17 16:42" ui-time="" datetime="2014/05/17 16:42" class="published ng-binding ng-isolate-scope">2014/05/17 16:42</time></div></header><section class="entry-content ng-binding" ng-bind-html="postContentTrustedHtml"><p></p><p>from:http://www.oauthsecurity.com/</p><h2>0x00 前言</h2><hr><p>这篇文章讲了OAuth 和 OpenID容易出现漏洞的一些地方。不管是程序员还是黑客，阅读它都会对你大有裨益。</p><p>就OAuth本身而言有一套很严谨的结构，但是很多开发者在部署AOuth的时候因为疏忽产生很多安全隐患，这些隐患如果被攻击者利用，是很难防御的。</p><p>现在很多大网站，都存在OAuth安全隐患，我写这篇文章的原因也是希望大家意识到由OAuth配置不当所引发的安全问题，和警示开发人员要小心处理关于OAuth的问题。</p><p>这篇文章并没有阐释OAuth的具体工作流程，想了解的话可以看他们的官网。</p><p>此文建议配合另外一个文章来看，包括乌云上很多实际案例：<a href="http://drops.wooyun.org/papers/598">《OAuth 2.0安全案例回顾》</a></p><h2>0x01 Authorization Code flow</h2><hr><h3>1. 通过绑定攻击者的账号进行账户劫持</h3><p>这是一种比较常见的攻击手法，其实就是一种CSRF攻击。</p><p>平台返回code到事先设定好的回调url，<code>SITE/oauth/callback?code=CODE</code>，之后客户端把code连同client credentials 和 redirect&#95;uri一起提交换取access&#95;token。</p><p>如果客户端没有部署 state这个参数来防止CSRF攻击，那么我们就可以通过CSRF轻易地把我们提供的账号和受害者的账号绑定。</p><p><img alt="enter image description here" img-src="b571006b904eeceffe8a39ca09eb4054ba9c87c7.jpg"></p><p>如下图所示，很多网站都提供使用社交账户登录的功能。</p><p><img alt="enter image description here" img-src="e8d88424d8e160d8e9813865ec8e0e477ccdc274.jpg"></p><p><img alt="enter image description here" img-src="be957c1fbf8175b068a25f845035ac5455a2ba9c.jpg"></p><p><strong>防范方法</strong>：在把用户的数据提交给提供者网站的时候，附带一个随机数，在连接返回时，沿着这个随机数是否改变。</p><p><strong>State fixation bug:(state可变漏洞)</strong>：在omniauth中一些遗留代码会导致state被修改，它使用 /connect?state=user_supplied代替了随机数。 一些开发者把state拿来做其他的用途，导致他失去了防止CSRF的功能，一个工整的解决方式可以用JSON Web Token as state。</p><h3>2. 使用会话固化攻击进行账户劫持</h3><p>在会话固化攻击中，攻击者会初始化一个合法的会话，然后诱使用户在这个会话上完成后续操作，从而达到攻击的目的。</p><p>如果我们访问一个用户绑定的链接，比如/user/auth/facebook，这个链接通常会返回 一个附带用户信息的url，其中uid代表了攻击者的id最终这个id将和受害者用户绑定。</p><p><strong>修复</strong>: 确认每一条绑定社交用户的链接都拥有合法的csrf_token,最好使用post代替get。</p><p>Facebook驳回了这个CSRF漏洞的修复建议，很多库中仍包含这一漏洞。所以不要奢望平台方总是能给与你可靠的数据。</p><h3>3. 通过authorization code泄露来劫持数据</h3><p>OAuth 的文档清楚的写出了，平台方应该检查redirect_uri是否被篡改。但我们通常懒得去检查它。</p><p>这使得很多平台方在这里产生了安全隐患，Foursquare (reported), VK (report, in Russian), Github (could be used to leak tokens to private repos)</p><p>攻击的方式很简单，寻找一个XSS漏洞，搞糟一个链接把redirect&#95;uri修改为你自己的地址。当受害者访问这个链接时，就会把leaking&#95;page?code=CODE发送到你的指定地址。</p><p><img alt="enter image description here" img-src="db26795179c39681cfcd8cde74aaa02503b49998.jpg"></p><p>这样你就可以使用这个泄露的授权码，在真实的redirect_uri上面登录受害者的用户了。</p><p><strong>修复方法：</strong>可变的redirect&#95;uri的确会产生风险，如果你非要用它，在access&#95;token创建的时候验证它是否被篡改。</p><h2>0x02 Implicit flow</h2><hr><h3>1. redirect可控引起的access&#95;token/signed&#95;request泄露</h3><p>这个漏洞被媒体称之为"covert redirect" ，但是这并不是一个新的漏洞。</p><p>利用它的前提是需要有一个可以修改的redirect，之后吧response&#95;type替换为token或者是signed&#95;request。302重定向会附带#后的信息，而攻击者只需要通过js截取即可。</p><p><strong>修补方式：</strong>在app setting中建立redirect_uri白名单。</p><p><img alt="enter image description here" img-src="ca7904196dfc010d2e5f6c04bd8dd0fa1994d195.jpg"></p><h3>2. 通过收集用户access_token进行账户劫持</h3><p>这个漏洞也被称为 One Token to Rule Them All.它通常发生在，手机和客户端app上。</p><p>当用户吧一个ring提交到一个他想登陆的网站时，一个恶意的网站管理员就可以通过这个ring登陆这个用户正在使用的其他网站。</p><p><img alt="enter image description here" img-src="684a11d06a8b3213eefbd2a041f2a3263a6da6b7.jpg"></p><p><strong>修补方式：</strong>在接受用户提交的access&#95;token之前，检查他是否符合client&#95;id。</p><h2>0x03 Extra</h2><hr><h3>1. client credentials 泄露</h3><p>client credentials其实并没有那么重要，你所能做的就是取得auth code，然后手动得到一个access_token。</p><p>使用静态redirect_uri，可以防止这种安全隐患。</p><h3>2. 会话固化攻击 (OAuth1.0)</h3><p>OAuth1.0和OAuth2.0的主要区别就是向平台传输参数的方式不同。在1.0中，客户把所有参数传递给平台，然后直接得到access&#95;token。所以你可以诱使用户访问provider?request&#95;token=TOKEN在授权完成后用户会被重定向到client/callback?request&#95;token=SAME&#95;TOKEN如果这个TOKEN是我们事先生成的，那么我们就可以复用这个TOKEN.</p><p>这不是一个服务端的bug，通常它被用来钓鱼，比如这个案例(<a href="http://homakov.blogspot.com/2014/01/token-fixation-in-paypal.html">FYI, Paypal express checkout has this bug</a>)</p><h3>3. 中继平台</h3><p>有些平台本身在其他平台获取账号，同时也为其他用户提供服务。通常他们都需要将url重定向到第三方网站，token在这样的链条中很容易泄露</p><pre><code>Facebook -&gt; Middleware Provider -&gt; Client's callback
</code></pre><p>而且这个问题基本无法修复。</p><p>facebook的解决方法是在callback url后面加上#<em>=</em> 防止其夹带数据。</p><h3>4. 绕过redirect_uri认证的一些技巧</h3><p>如果允许设置子目录，下面是一些目录遍历的技巧</p><pre><code>/old/path/../../new/path
/old/path/%2e%2e/%2e%2e/new/path
/old/path/%252e%252e/%252e%252e/new/path
/new/path///../../old/path/
/old/path/.%0a./.%0d./new/path (For Rails, because it strips \n\d\0)
</code></pre><h3>5. 重放攻击</h3><p>code经过get传输的时候会存在于log文件中，平台应该在使用或者过期之后删除它们。</p><p></p></section></article><div class="entry-controls clearfix"><div style="float:left;color:#9d9e9f;font-size:15px"><span>&copy;乌云知识库版权所有 未经许可 禁止转载</span></div></div><div class="yarpp-related"><h3>为您推荐了适合您的技术文章:</h3><ol id="recommandsystem"><li><a href="http://drops.wooyun.org/papers/598" rel="bookmark" id="re1">OAuth 2.0安全案例回顾</a></li><li><a href="http://drops.wooyun.org/papers/382" rel="bookmark" id="re2">闲扯下午引爆乌云社区“盗窃”乌云币事件</a></li><li><a href="http://drops.wooyun.org/papers/4762" rel="bookmark" id="re3">linux symbolic link attack tutorial</a></li><li><a href="http://drops.wooyun.org/papers/7480" rel="bookmark" id="re4">中间人攻击利用框架bettercap测试</a></li></ol></div><div id="comments" class="comment-list clearfix"><div id="comment-list"><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">廷廷</span> <span class="reply-time">2014-05-18 11:17:22</span></div><p></p><p>没看懂</p><p></p></div></div><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">mramydnei</span> <span class="reply-time">2014-05-18 06:35:01</span></div><p></p><p>1条评论了已经</p><p></p></div></div></div></div></div></main>