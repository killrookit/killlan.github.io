<main class="main-container ng-scope" ng-view=""><div class="main receptacle post-view ng-scope"><article class="entry ng-scope" ng-controller="EntryCtrl" ui-lightbox=""><header><h1 class="entry-title ng-binding">关于OpenSSL“心脏出血”漏洞的分析</h1><div class="entry-meta"><a target="_blank" class="author name ng-binding">Fish</a> <span class="bull">·</span> <time title="2014/04/08 14:17" ui-time="" datetime="2014/04/08 14:17" class="published ng-binding ng-isolate-scope">2014/04/08 14:17</time></div></header><section class="entry-content ng-binding" ng-bind-html="postContentTrustedHtml"><p></p><h2>0x00 背景</h2><hr><p>原作者：<a href="http://blog.existentialize.com/pages/about.html">Sean Cassidy</a> 原作者Twitter：@ex509 原作者博客：<a href="http://blog.existentialize.com">http://blog.existentialize.com</a> 来源：<a href="http://blog.existentialize.com/diagnosis-of-the-openssl-heartbleed-bug.html">http://blog.existentialize.com/diagnosis-of-the-openssl-heartbleed-bug.html</a></p><p>当我分析<a href="http://blog.existentialize.com/the-story-of-the-gnutls-bug.html">GnuTLS的漏洞</a>的时候，我曾经说过，那不会是我们看到的最后一个TLS栈上的严重bug。然而我没想到这次OpenSSL的bug会如此严重。</p><p><a href="http://heartbleed.com/">OpenSSL“心脏出血”漏洞</a>是一个非常严重的问题。这个漏洞使攻击者能够从内存中读取多达64 KB的数据。一些安全研究员表示：</p><blockquote><p>无需任何特权信息或身份验证，我们就可以从我们自己的（测试机上）偷来X.509证书的私钥、用户名与密码、聊天工具的消息、电子邮件以及重要的商业文档和通信等数据。</p></blockquote><p>这一切是如何发生的呢？让我们一起从代码中一探究竟吧。</p><h2>0x01 Bug</h2><hr><p>请看ssl/dl_both.c，<a href="http://git.openssl.org/gitweb/?p=openssl.git;a=commitdiff;h=96db9023b881d7cd9f379b0c154650d6c108e9a3">漏洞的补丁</a>从这行语句开始：</p><pre><code>#!cpp
int            
dtls1_process_heartbeat(SSL *s)
    {          
    unsigned char *p = &amp;s-&gt;s3-&gt;rrec.data[0], *pl;
    unsigned short hbtype;
    unsigned int payload;
    unsigned int padding = 16; /* Use minimum padding */
</code></pre><p>一上来我们就拿到了一个指向一条SSLv3记录中数据的指针。结构体SSL3&#95;RECORD的定义如下（译者注：结构体SSL3&#95;RECORD不是SSLv3记录的实际存储格式。一条SSLv3记录所遵循的存储格式请参见下文分析）：</p><pre><code>#!cpp
typedef struct ssl3_record_st
    {
        int type;               /* type of record */
        unsigned int length;    /* How many bytes available */
        unsigned int off;       /* read/write offset into 'buf' */
        unsigned char *data;    /* pointer to the record data */
        unsigned char *input;   /* where the decode bytes are */
        unsigned char *comp;    /* only used with decompression - malloc()ed */
        unsigned long epoch;    /* epoch number, needed by DTLS1 */
        unsigned char seq_num[8]; /* sequence number, needed by DTLS1 */
    } SSL3_RECORD;
</code></pre><p>每条SSLv3记录中包含一个类型域（type）、一个长度域（length）和一个指向记录数据的指针（data）。我们回头去看dtls1&#95;process&#95;heartbeat：</p><pre><code>#!cpp
/* Read type and payload length first */
hbtype = *p++;
n2s(p, payload);
pl = p;
</code></pre><p>SSLv3记录的第一个字节标明了心跳包的类型。宏n2s从指针p指向的数组中取出前两个字节，并把它们存入变量payload中——这实际上是心跳包载荷的长度域（length）。注意程序并没有检查这条SSLv3记录的实际长度。变量pl则指向由访问者提供的心跳包数据。</p><p>这个函数的后面进行了以下工作：</p><pre><code>#!cpp
unsigned char *buffer, *bp;
int r;

/* Allocate memory for the response, size is 1 byte
 * message type, plus 2 bytes payload length, plus
 * payload, plus padding
 */
buffer = OPENSSL_malloc(1 + 2 + payload + padding);
bp = buffer;
</code></pre><p>所以程序将分配一段由访问者指定大小的内存区域，这段内存区域最大为 (65535 + 1 + 2 + 16) 个字节。变量bp是用来访问这段内存区域的指针。</p><pre><code>#!cpp
/* Enter response type, length and copy payload */
*bp++ = TLS1_HB_RESPONSE;
s2n(payload, bp);
memcpy(bp, pl, payload);
</code></pre><p>宏s2n与宏n2s干的事情正好相反：s2n读入一个16 bit长的值，然后将它存成双字节值，所以s2n会将与请求的心跳包载荷长度相同的长度值存入变量payload。然后程序从pl处开始复制payload个字节到新分配的bp数组中——pl指向了用户提供的心跳包数据。最后，程序将所有数据发回给用户。那么Bug在哪里呢？</p><h3>0x01a 用户可以控制变量payload和pl</h3><p>如果用户并没有在心跳包中提供足够多的数据，会导致什么问题？比如pl指向的数据实际上只有一个字节，那么memcpy会把这条SSLv3记录之后的数据——无论那些数据是什么——都复制出来。</p><p>很明显，SSLv3记录附近有不少东西。</p><p>说实话，我对发现了OpenSSL“心脏出血”漏洞的那些人的声明感到吃惊。当我听到他们的声明时，我认为64 KB数据根本不足以推算出像私钥一类的数据。至少在x86上，堆是向高地址增长的，所以我认为对指针pl的读取只能读到新分配的内存区域，例如指针bp指向的区域。存储私钥和其它信息的内存区域的分配早于对指针pl指向的内存区域的分配，所以攻击者是无法读到那些敏感数据的。当然，考虑到现代malloc的各种神奇实现，我的推断并不总是成立的。</p><p>当然，你也没办法读取其它进程的数据，所以“重要的商业文档”必须位于当前进程的内存区域中、小于64 KB，并且刚好位于指针pl指向的内存块附近。</p><p>研究者声称他们成功恢复了密钥，我希望能看到PoC。如果你找到了PoC，<a href="http://blog.existentialize.com/pages/about.html">请联系我</a>。</p><h3>0x01b 漏洞修补</h3><p>修复代码中最重要的一部分如下：</p><pre><code>#!cpp
/* Read type and payload length first */
if (1 + 2 + 16 &gt; s-&gt;s3-&gt;rrec.length)
    return 0; /* silently discard */
hbtype = *p++;
n2s(p, payload);
if (1 + 2 + payload + 16 &gt; s-&gt;s3-&gt;rrec.length)
    return 0; /* silently discard per RFC 6520 sec. 4 */
pl = p;
</code></pre><p>这段代码干了两件事情：首先第一行语句抛弃了长度为0的心跳包，然后第二步检查确保了心跳包足够长。就这么简单。</p><h2>0x02 前车之鉴</h2><hr><p>我们能从这个漏洞中学到什么呢？</p><p>我是C的粉丝。这是我最早接触的编程语言，也是我在工作中使用的第一门得心应手的语言。但是和之前相比，现在我更清楚地看到了C语言的局限性。</p><p>从<a href="http://blog.existentialize.com/the-story-of-the-gnutls-bug.html">GnuTLS漏洞</a>和这个漏洞出发，我认为我们应当做到下面三条：</p><pre><code>花钱请人对像OpenSSL这样的关键安全基础设施进行安全审计；
为这些库写大量的单元测试和综合测试；
开始在更安全的语言中编写替代品。
</code></pre><p>考虑到使用C语言进行安全编程的困难性，我不认为还有什么其他的解决方案。我会试着做这些，你呢？</p><p>作者简介：Sean是一位关于如何把事儿干好的软件工程师。现在他在<a href="http://www.gosquadron.com/">Squadron</a>工作。Squadron是一个专为SaaS应用程序准备的配置与发布管理工具。</p><p><strong>测试版本的结果以及检测工具：</strong></p><pre><code>OpenSSL 1.0.1 through 1.0.1f (inclusive) are vulnerable
OpenSSL 1.0.1g is NOT vulnerable
OpenSSL 1.0.0 branch is NOT vulnerable
OpenSSL 0.9.8 branch is NOT vulnerable
</code></pre><p><a href="http://filippo.io/Heartbleed/">http://filippo.io/Heartbleed/</a></p><p></p></section></article><div class="entry-controls clearfix"><div style="float:left;color:#9d9e9f;font-size:15px"><span>&copy;乌云知识库版权所有 未经许可 禁止转载</span></div></div><div class="yarpp-related"><h3>为您推荐了适合您的技术文章:</h3><ol id="recommandsystem"><li><a href="http://drops.wooyun.org/papers/13433" rel="bookmark" id="re1">CVE-2016-0799简单分析</a></li><li><a href="http://drops.wooyun.org/papers/8814" rel="bookmark" id="re2">恶意软件PE文件重建指南</a></li><li><a href="http://drops.wooyun.org/papers/12039" rel="bookmark" id="re3">CVE-2015-3795</a></li><li><a href="http://drops.wooyun.org/papers/6077" rel="bookmark" id="re4">PHP multipart/form-data 远程DOS漏洞</a></li></ol></div><div id="comments" class="comment-list clearfix"><div id="comment-list"><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">Budi</span> <span class="reply-time">2016-03-14 07:49:57</span></div><p></p><p>源代码分析，不错</p><p></p></div></div><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">黑吃黑</span> <span class="reply-time">2015-02-06 10:15:25</span></div><p></p><p>利用脚本怎么没放上来</p><p></p></div></div><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">小贱人</span> <span class="reply-time">2014-05-27 15:17:04</span></div><p></p><p>mark</p><p></p></div></div><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">小森森</span> <span class="reply-time">2014-04-20 10:08:46</span></div><p></p><p>@Fish 揪个错～～前边的文件名写错啦，应该是ssl/d1_both.c而不是ssl/dl_both.c，d后边的是数字1～</p><p></p></div></div><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">zaobao</span> <span class="reply-time">2014-04-15 17:01:41</span></div><p></p><p>程序员自己疏忽了，不能赖c吧</p><p></p></div></div><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">11</span> <span class="reply-time">2014-04-13 16:53:55</span></div><p></p><p>http://my.oschina.net/gschen/blog/221796</p><p></p></div></div><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">Fish</span> <span class="reply-time">2014-04-11 13:59:14</span></div><p></p><p>再次看的时候发现我写的“数据包格式”因为有尖括号而被过滤掉了（囧）。<br>补充下，heartbeat 数据包的格式应该是这样的：<br>type, 1 byte<br>length, 2 bytes<br>data, #length# bytes</p><p></p></div></div><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">dood</span> <span class="reply-time">2014-04-11 09:48:59</span></div><p></p><p>多谢指明，因为 struct ssl3_record_st 的前三个域 type, length 和 off无关，所有数据都是用户发来的data[] 里面取出type，length，由此造成了这次风险。</p><p></p></div></div><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">Fish</span> <span class="reply-time">2014-04-11 02:23:29</span></div><p></p><p>根据我的理解，指针 data 指向的 buffer 存储的是客户端发来的 heartbeat 包，格式应该是 ，它和 struct ssl3_record_st 的前三个域 type, length 和 off 无关。<br>最后应该有 pl == &amp;s-&gt;s3-&gt;rrec.data[3]; /* pl 是个指针 */。<br>我没有调试过这段代码。所以如果我理解的不对，请告诉我。</p><p></p></div></div><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">Comer</span> <span class="reply-time">2014-04-10 17:27:39</span></div><p></p><p>赞龙哥。</p><p></p></div></div><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">dood</span> <span class="reply-time">2014-04-10 15:55:23</span></div><p></p><p>求指点，<br>unsigned char *p = &amp;s-&gt;s3-&gt;rrec.data[0]；<br>typedef struct ssl3_record_st<br>{<br>int type; /* type of record */<br>unsigned int length; /* How many bytes available */<br>unsigned int off; /* read/write offset into 'buf' */<br>unsigned char *data;<br>};<br>///此时p 指向的data数组， ssl3_record_st结构体的成员type,length没有用到啊<br>/* Read type and payload length first */<br>hbtype = *p++; /// 怎么得到type，p 指向的是data<br>n2s(p, payload); ///同上<br>pl = p; /// 此时p1 == rrec.data[3] ?</p><p></p></div></div><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">瞌睡龙</span> <span class="reply-time">2014-04-10 14:15:42</span></div><p></p><p>话不能这么说，总有人考虑不到的地方，之前估计谁也不会想到OpenSSL会有这么一个大坑，并且，你刚给的解决方案并不能防御的了，我到内存当中就dump出密码的hash，再用这个hash去请求就是了，一样认证成功，好点的方案是加一个once token带入hash中再认证，但是同样阻挡不了session劫持。再安全的方式就是绑定ip之类的，但是作为一个大量用户业务来讲，基本不可能这么做。</p><p></p></div></div><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">warrioj4</span> <span class="reply-time">2014-04-10 12:54:57</span></div><p></p><p>google一下，你知道的就太多了</p><p></p></div></div><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">warrioj4</span> <span class="reply-time">2014-04-10 12:54:07</span></div><p></p><p>传输的时候肯定是密文，到内存里面计算匹配也是密文，关键是这些密文是不是通用的不可逆算法，例如MD5 如果没加盐的MD5是很容易被查表攻破的</p><p></p></div></div><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">warrioj4</span> <span class="reply-time">2014-04-10 12:51:00</span></div><p></p><p>为了可能的安全问题，客户端跟服务端应该要形成一种安全的共识，不断的加盐 （任你跑个天昏地暗 都跑不出明文），当然 针对客户端的攻击那就没办法了</p><p></p></div></div><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">warrioj4</span> <span class="reply-time">2014-04-10 12:49:33</span></div><p></p><p>那我只能说这些网站程序设计者脑残不？ 如果是我，有控件的话，肯定会先给客户端加点盐，然后生成一个临时表，让客户端返回 MD5（MD5(密码)+盐） 这样服务端只要计算好是否跟数据库匹配与否就好了，这样内存里面一大堆密文 还加了盐 你觉得那些SB黑客 会为了你账户的里面的100块 去跑明文么？</p><p></p></div></div><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">瞌睡龙</span> <span class="reply-time">2014-04-10 12:38:56</span></div><p></p><p>事实胜于雄辩，yahoo与淘宝几乎每个dump下来的16kb都有账户的明文账户密码，yahoo是18小时后修复的，你觉得被全球黑客dump下了多少呢？</p><p></p></div></div><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">morris2600</span> <span class="reply-time">2014-04-10 12:30:36</span></div><p></p><p>传输过程不是密文吗？ 收到之后先解成明文放到内存？</p><p></p></div></div><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">warrioj4</span> <span class="reply-time">2014-04-10 12:21:18</span></div><p></p><p>64KB 能干嘛 也许后面覆盖的内存区域 什么都没有 也许就是一堆无效的数据 或者是一些密文之类</p><p></p></div></div><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">warrioj4</span> <span class="reply-time">2014-04-10 12:20:32</span></div><p></p><p>我就呵呵了 用户提交的内容 如果有安全控件的 一般在客户端就已经加密了</p><p></p></div></div><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">broxian</span> <span class="reply-time">2014-04-10 10:18:31</span></div><p></p><p>There is no total of 64 kilobytes limitation to the attack, that limit applies only to a single heartbeat. Attacker can either keep reconnecting or during an active TLS connection keep requesting arbitrary number of 64 kilobyte chunks of memory content until enough secrets are revealed.</p><p></p></div></div><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">小石头</span> <span class="reply-time">2014-04-10 09:42:16</span></div><p></p><p>围观!</p><p></p></div></div><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">野驴~</span> <span class="reply-time">2014-04-09 21:02:42</span></div><p></p><p>一大波漏洞来袭。</p><p></p></div></div><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">耐小心</span> <span class="reply-time">2014-04-09 19:02:12</span></div><p></p><p>尼玛 凶残</p><p></p></div></div><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">sameul</span> <span class="reply-time">2014-04-09 17:40:34</span></div><p></p><p>用户提交的都是明文的， 数据库里存储的才是密文</p><p></p></div></div><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">cisse</span> <span class="reply-time">2014-04-09 15:45:17</span></div><p></p><p>多谢分享 多谢指教 大神果然厉害</p><p></p></div></div><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">chenlog</span> <span class="reply-time">2014-04-09 15:15:21</span></div><p></p><p>请问密码在内存中不是密文存储的吗？</p><p></p></div></div><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">wwt</span> <span class="reply-time">2014-04-09 14:36:09</span></div><p></p><p>这个应该是拷贝进程所分配的内存，如果没登陆，应该不会泄密吧。</p><p></p></div></div><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">livers</span> <span class="reply-time">2014-04-09 12:10:05</span></div><p></p><p>何止是厂商啊！！！！！</p><p></p></div></div><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">archa</span> <span class="reply-time">2014-04-09 11:08:43</span></div><p></p><p>但是95年没有这个bug</p><p></p></div></div><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">archa</span> <span class="reply-time">2014-04-09 11:08:00</span></div><p></p><p>谁把这个bug引进来的？</p><p></p></div></div><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">拆哪小白菜</span> <span class="reply-time">2014-04-09 10:12:29</span></div><p></p><p>这个绝对是一个后门！95年OpenSSL就有了，呵呵呵呵</p><p></p></div></div><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">银冥币</span> <span class="reply-time">2014-04-08 22:35:09</span></div><p></p><p>求个poc和exp，用来写批量利用工具</p><p></p></div></div><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">hellok</span> <span class="reply-time">2014-04-08 20:25:51</span></div><p></p><p>http://phrack.org/papers/fall_of_groups.html</p><p></p></div></div><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">Seven.Sea</span> <span class="reply-time">2014-04-08 20:13:32</span></div><p></p><p>坐等被刷屏..</p><p></p></div></div><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">高斯</span> <span class="reply-time">2014-04-08 19:31:54</span></div><p></p><p>我tm没法用电脑，泪奔。。。。。。。</p><p></p></div></div><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">Soga</span> <span class="reply-time">2014-04-08 17:46:07</span></div><p></p><p>伙呆了</p><p></p></div></div><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">大亮</span> <span class="reply-time">2014-04-08 17:12:44</span></div><p></p><p>⊙︿⊙╭(￣m￣*)╮(+﹏+)~狂晕，没看懂啊，看来还是回去好好学习吧</p><p></p></div></div><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">Focusstart</span> <span class="reply-time">2014-04-08 16:49:04</span></div><p></p><p>mark！</p><p></p></div></div><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">Pooke</span> <span class="reply-time">2014-04-08 16:48:58</span></div><p></p><p>坐等</p><p></p></div></div><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">Fish</span> <span class="reply-time">2014-04-08 16:00:49</span></div><p></p><p>是的。反复攻击，直到得到敏感数据即可。</p><p></p></div></div><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">refer</span> <span class="reply-time">2014-04-08 15:57:33</span></div><p></p><p>There is no total of 64 kilobytes limitation to the attack, that limit applies only to a single heartbeat. Attacker can either keep reconnecting or during an active TLS connection keep requesting arbitrary number of 64 kilobyte chunks of memory content until enough secrets are revealed.</p><p></p></div></div><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">肉肉</span> <span class="reply-time">2014-04-08 15:38:57</span></div><p></p><p>mark</p><p></p></div></div><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">瞌睡龙</span> <span class="reply-time">2014-04-08 15:34:36</span></div><p></p><p>坐等各大厂商躺枪……</p><p></p></div></div><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">insight-labs</span> <span class="reply-time">2014-04-08 15:22:09</span></div><p></p><p>膜拜fish大神。</p><p></p></div></div><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">hellok</span> <span class="reply-time">2014-04-08 15:08:03</span></div><p></p><p>如果你找到了PoC，请联系我</p><p></p></div></div></div></div></div></main>