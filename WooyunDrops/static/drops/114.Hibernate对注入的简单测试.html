<main class="main-container ng-scope" ng-view=""><div class="main receptacle post-view ng-scope"><article class="entry ng-scope" ng-controller="EntryCtrl" ui-lightbox=""><header><h1 class="entry-title ng-binding">Hibernate对注入的简单测试</h1><div class="entry-meta"><a target="_blank" class="author name ng-binding">clzzy</a> <span class="bull">·</span> <time title="2013/11/25 15:41" ui-time="" datetime="2013/11/25 15:41" class="published ng-binding ng-isolate-scope">2013/11/25 15:41</time></div></header><section class="entry-content ng-binding" ng-bind-html="postContentTrustedHtml"><p></p><h2>0x00 背景</h2><hr><p>前段时间遇到一个使用了Hibernate框架的站，以前没怎么接触过（由于是Java盲，所以大家勿喷），再注入的事情发生了许多奇奇怪怪的事情，于是向本地搭一个看看是个神马情况。Hibernate配备了一种非常强大的查询语言，这种语言看上去很像SQL。但是不要被语法结构上的相似所迷惑，HQL是非常有意识的被设计为完全面向对象的查询。</p><h2>0x01 测试</h2><hr><p>本次测试的环境是JDK5.0+Tomcat8+Hibernate3.0+Servlet。数据库情况如下：</p><p><img alt="2013112511500521075.png" img-src="e4c72bc8969699f19dc3baa83fd002ca5d931837.jpg"></p><p>通过百度知道Hibernate的查询大概有5、6种，通过分析对注入能产生不同影响的应该有如下三种：</p><pre><code>1、HQL方式
2、原生SQL方式
3、Criteria方式
</code></pre><p>重点是HQL方式，HQL相当于Hibernate自己有一套SQL语法，在用Hibernate作为查询中间层的时候，它会将你写的HQL翻译成对应数据库的SQL语句，Hibernate支持N种数据库。</p><p>会一丢丢Java的童鞋都知道Hibernate的使用流程：</p><p>首先要告诉Hibernate数据库的连接信息，hibernate.cfg.xml文件：</p><pre><code>#!xml
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;!DOCTYPE hibernate-configuration PUBLIC "-//Hibernate/Hibernate Configuration DTD 3.0//EN" "http://hibernate.sourceforge.net/hibernate-configuration-3.0.dtd"&gt; 
&lt;!-- Generated by MyEclipse Hibernate Tools. --&gt;
&lt;hibernate-configuration&gt; 
  &lt;session-factory&gt; 
    &lt;property name="dialect"&gt;org.hibernate.dialect.Oracle9Dialect&lt;/property&gt;  
    &lt;property name="connection.url"&gt;jdbc:oracle:thin:@192.168.79.151:1521:orcl&lt;/property&gt;  
    &lt;property name="connection.username"&gt;system&lt;/property&gt;  
    &lt;property name="connection.password"&gt;xxoo&lt;/property&gt;  
    &lt;property name="connection.driver_class"&gt;oracle.jdbc.driver.OracleDriver&lt;/property&gt;  
    &lt;property name="myeclipse.connection.profile"&gt;oracle_connet&lt;/property&gt;  
    &lt;mapping resource="com/mytest/map/Userlist.hbm.xml"/&gt;//这里是包含表的映射文件
  &lt;/session-factory&gt; 
&lt;/hibernate-configuration&gt;
</code></pre><p>其实是映射你想使用的数据表（系统会按照表明自动生成文件，比如我的Userlist表会生成Userlist.hbm.xml），Userlist.hbm.xml文件：</p><p>分别将ID、USERNAME、USERPWD列映射为id、username、userpwd，而在实际环境中，开发者可能映射成他们喜欢的名字。</p><p>注：</p><pre><code>1、未映射的表是不能查询的；
2、使用映射后表名、列名时大小写敏感；
3、不能使用数据库中的列名，比如USERNAME映射为username之后，不能再使用USERNAME，否则报错。
</code></pre><p><br></p><pre><code>#!xml
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;!DOCTYPE hibernate-mapping PUBLIC "-//Hibernate/Hibernate Mapping DTD 3.0//EN" "http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd"&gt;
&lt;!-- Mapping file autogenerated by MyEclipse Persistence Tools --&gt; 
&lt;hibernate-mapping&gt; 
  &lt;class name="com.mytest.map.Userlist" table="USERLIST" schema="SYSTEM"&gt; 
    &lt;id name="id" type="java.math.BigDecimal"&gt; 
      &lt;column name="ID" precision="22" scale="0"/&gt;  
      &lt;generator class="assigned"/&gt; 
    &lt;/id&gt;  
    &lt;property name="username" type="java.lang.String"&gt; 
      &lt;column name="USERNAME" length="20" not-null="true"/&gt; 
    &lt;/property&gt;  
    &lt;property name="userpwd" type="java.lang.String"&gt; 
      &lt;column name="USERPWD" length="30" not-null="true"/&gt; 
    &lt;/property&gt; 
  &lt;/class&gt; 
&lt;/hibernate-mapping&gt;
</code></pre><h3>1、原生的HQL方式：大概代码：</h3><pre><code>try{
    s=HibernateSessionFactory.getSession();
    tx=s.beginTransaction();
    Query query=s.createQuery("from Userlist as u where username='" +userName + "'");
    Qstring=query.getQueryString(); //
    Iterator it = query.iterate();
    //这是Iterate数据返回方式
    List it=query.list();//这是List数据返回方式 //
    ul = (Userlist) it.next();
    ul=(Userlist)it.get(0);
    mUserPwd=ul.getUserpwd();
}catch (Exception e) {
    System.out.println(e.getMessage());
    return e.getMessage();
}//这里加了返回抛出的异常的代码
tx.commit(); //关闭连接
HibernateSessionFactory.closeSession();
</code></pre><p>上面提到的Iterate和List数据返回方式没发现对注入产生多大的影响，他们呢的具体差别请google。</p><p>使用单引号测试（有返回异常的代码，数据库报错）：</p><p><img alt="2013112511511598103.png" img-src="ed8bf64656d7ac810815b093ef8351a4782bdd66.jpg"></p><p>使用单引号测试（没有返回异常的代码，默认情况，Tomcat报错）：</p><p><img alt="2013112511514496111.png" img-src="7fc1e6f2b9a175d8d749f92487f96962825f221f.jpg"></p><pre><code>And 'a'='a 
</code></pre><p><img alt="2013112511522315773.png" img-src="4c425d6723aa0fbe6244f3ba9adbfbaedab27749.jpg"></p><pre><code>And 'a'='b
</code></pre><p><img alt="2013112511525569278.png" img-src="bd9769963efa68ea7fbcd205820de3f668c80225.jpg"></p><p>跨库查系统表？想都不要想：</p><p><img alt="2013112511532221767.png" img-src="561792085696705ec9e6590e2adb7db47dffe709.jpg"></p><p>*号也是不能用滴：</p><p><img alt="2013112511534553955.png" img-src="7e841528833bc7a11bdea765e77fa975854be993.jpg"></p><p>不支持union：</p><p><img alt="2013112511541396421.png" img-src="11cd29c37532e24b05db4cd399e213ff97826232.jpg"></p><p></p><p>单独内嵌select作为条件（正常执行）：</p><p><img alt="2013112511544292137.png" img-src="1ec5d3e08a52c9183fbfcb25f4a0f603f04c5921.jpg"></p><p>单独执行substr()，ASCII()函数没问题：</p><p><img alt="2013112511550372977.png" img-src="02c87c105b0aed5bdb6a6cd006df912d4670ad48.jpg"></p><p>但是执行</p><pre><code>ASCII(SUBSTR((select userpwd from Userlist where ROWNUM=1)，1,1))&gt;0
</code></pre><p>就不行了：</p><p><img alt="2013112511552223471.png" img-src="5441d596ce9b5a8c1f9990bc19da484dca6e61e7.jpg"><br></p><p>结论：这里能爆的列还得看前面那个select的心情。</p><p>小刺猬和它的小伙伴们都惊呆了：</p><p><img alt="2013112511554437592.png" img-src="d22dcfd52213df8bf743747911c7eb28bc3295ec.jpg"></p><p>对于第二种使用原生SQL的方式，写法大概是这样：</p><pre><code>s=HibernateSessionFactory.getSession();
tx=s.beginTransaction();
Query query=s.createSQLQuery("select USERPWD from Userlist where USERNAME='" +userName + "'"); 
Qstring=query.getQueryString(); 
List it = query.list(); 
mUserPwd=(String)it.get(0);
</code></pre><p>就不多说了，就可普通注入一样。毫无压力：</p><p><img alt="2013112511561333503.png" img-src="89592e6145b98bd23ca372ea37ed07a6b266076a.jpg"></p><p>说说第三种，写法大概是这样：</p><pre><code>s=HibernateSessionFactory.getSession();
List UserLists=s.createCriteria(Userlist.class).add(Restrictions.eq("username",userNameString)).list();
Userlist u=(Userlist)UserLists.get(0); 
mUserPwd=u.getUserpwd();
</code></pre><p>如果说我们在HQL下还能用</p><pre><code>ascii(substr(userpwd,1,1))&gt;1
</code></pre><p>来猜解前面SELECT中选择的列中有的列的内容的话，那么在第三种Criteria方式下，基本就绝望了：</p><p><img alt="2013112511564296588.png" img-src="60f1ce752c2781262c690472dd1a97e1a0da19be.jpg"></p><p><img alt="2013112511565763376.png" img-src="e600af46fdf48ecd6576c72bd743a16ab2a2f2da.jpg"></p><p><img alt="2013112511571458944.png" img-src="30159bcae879fcfda14f859442ad11dc63fbc81d.jpg"><br></p><p><img alt="2013112511573196321.png" img-src="59a027b944e832325b2111880647013c421d9ce6.jpg"><br></p><p>本来要结束的时候，我发现了第四种，是HQL的另一种写法，大概代码这么写：</p><pre><code>s=HibernateSessionFactory.getSession();
tx=s.beginTransaction();
Query query=s.createSQLQuery("select {p.*} from Userlist {p} where {p}.USERNAME="+userNameString).addEntity("p", Userlist.class); 
Qstring=query.getQueryString();
List it = query.list();
mUserPwd=(String)it.get(0);
</code></pre><p>貌似这样的也没得玩，歇菜了：</p><p><img alt="2013112511581343139.png" img-src="6c30e03e4d115590436ddbe9dd664373cd471098.jpg"></p><p><img alt="2013112511581991918.png" img-src="85c679e1903be3598ff37247751a5e6ca24b6122.jpg"></p><h2>0x02 总结</h2><hr><p>最后：时间有限，只做了字符型的简单粗浅表面测试，抛个砖，希望有更多经验的留言啊，毕竟这方面的资料网上真心极少，为了方便大众，请大牛们现身说法。</p><p></p></section></article><div class="entry-controls clearfix"><div style="float:left;color:#9d9e9f;font-size:15px"><span>&copy;乌云知识库版权所有 未经许可 禁止转载</span></div></div><div id="comments" class="comment-list clearfix"><div id="comment-list"><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">隐形人真忙</span> <span class="reply-time">2015-02-24 00:17:06</span></div><p></p><p>HQL注入很鸡肋，一般万能密码还行，盲注的话，列名和元数据如何爆，是个问题。除非try-catch中有这样的代码:e.getSQLException或者e.getSQL()，“友好”的显错，所有列名都能爆出。</p><p></p></div></div><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">Asuri</span> <span class="reply-time">2014-09-06 21:52:10</span></div><p></p><p>这方面的资料真心很少......源码审计的时候遇到的一个，明知肯定有注入，但是现有的办法都不行.....</p><p></p></div></div><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">Oops</span> <span class="reply-time">2014-01-13 11:47:57</span></div><p></p><p>说是java盲，我怎么感觉比我知道得还详细啊</p><p></p></div></div><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">Mody</span> <span class="reply-time">2014-01-02 17:25:11</span></div><p></p><p>应该属于第三种，ANSCII \SUBSTR 分开可以，结合就不行了。。。楼主最近可有好的利用方法？？</p><p></p></div></div><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">Mody</span> <span class="reply-time">2014-01-02 17:00:22</span></div><p></p><p>遇到一个。。蛋碎中</p><p></p></div></div><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">核攻击</span> <span class="reply-time">2013-12-17 10:55:27</span></div><p></p><p>阅~</p><p></p></div></div><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">neal</span> <span class="reply-time">2013-12-03 18:43:33</span></div><p></p><p>java 这个面向对象的语言 在hibernate使用里面 sql还是 拼接字符串，我只能说 神一般的程序员。 一般使用都是第三或者第四种。</p><p></p></div></div><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">wefgod</span> <span class="reply-time">2013-12-03 11:13:38</span></div><p></p><p>我去，悲剧啊。就是说第一个方法无法跨过去查任何其它表了？注册有的表也不行？<br>好难搞哦</p><p></p></div></div><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">0x_Jin</span> <span class="reply-time">2013-11-25 18:43:22</span></div><p></p><p>二楼抢坐！</p><p></p></div></div><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">clzzy</span> <span class="reply-time">2013-11-25 16:37:13</span></div><p></p><p>老夫先来</p><p></p></div></div></div></div></div></main>