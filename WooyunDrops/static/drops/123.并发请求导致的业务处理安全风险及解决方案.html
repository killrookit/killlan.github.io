<main class="main-container ng-scope" ng-view=""><div class="main receptacle post-view ng-scope"><article class="entry ng-scope" ng-controller="EntryCtrl" ui-lightbox=""><header><h1 class="entry-title ng-binding">并发请求导致的业务处理安全风险及解决方案</h1><div class="entry-meta"><a target="_blank" class="author name ng-binding">blue</a> <span class="bull">·</span> <time title="2013/12/25 11:51" ui-time="" datetime="2013/12/25 11:51" class="published ng-binding ng-isolate-scope">2013/12/25 11:51</time></div></header><section class="entry-content ng-binding" ng-bind-html="postContentTrustedHtml"><p></p><h2>0x00 背景</h2><hr><p>一段简单的购买程序，看起来没有任何问题。</p><p>剩余余额、商品库存、购买权限等判断面面俱到，从头到脚包装的严严实实。</p><p>但是为何人一多就频频漏点呐？何解？</p><h2>0x01 问题分析</h2><hr><p>还是以商城购买为例，商城网站是web程序和数据库两部分，业务处理流程：</p><pre><code>#!shell
用户金额是否大于商品价格—&gt;商品库存是否充足—&gt;购买操作:生成订单—&gt;扣除用户金额—&gt;商品库存减1
</code></pre><p><img alt="2013122510571541794.png" img-src="fc630c4ff334d6d70954d50ea90d8eb85623b293.jpg"></p><p>流程的每一部分都是web与数据库打交道，查询或者操作数据库。</p><h3>程序示例(PHP+MySQL)</h3><pre><code>#!php
$goods=$db-&gt;FirstRow("SELECT * FROM ".Tb('goods')." WHERE goods_id='{$goods_id}'");
if(empty($goods)) ShowError('商品不存在');
/* 金额是否充足 */
if($user-&gt;money&lt;$goods['price'])  ShowError('金额不足，请充值');
/* 商品库存 */
if($goods['num']==0)  ShowError('库存不足');
/* 购买操作 begin */
//生成订单
CreateOrder($goods,$user,time());
$user-&gt;Update('money'=&gt;$user-&gt;money-$goods['price']); //用户金额减少
$db-&gt;Execute("UPDATE ".Tb('goods')." SET num=num-1 WHERE goods_id='{$goods_id}'");//商品库存-1
ShowSuccess('购买成功');
/* 购买操作 end */
</code></pre><p>正常来看这个业务处理是没有问题的，下面想象下多人同时购买（并发请求，如秒杀活动）的情境可能会引发的问题？</p><p>如果一个用户同时有两次购买请求，一次购买已进行到添加订单但未扣除用户金额，另一次购买在第一步用户金额判断便不准确了。</p><p>当商品库存仅为1时，同时有多个请求，而当前没有一个请求走到商品库存减少位置，多次购买都能成功，而商城却无货可发。</p><p><img alt="2013122510574019546.png" img-src="e8fb7c60f86a55848054013b6d4c1716d0b646bd.jpg"></p><p>总结来说，当有大量的购买操作同时进行，如果<strong>数据库的处理速度跟不上程序的请求速度</strong>，就会出现判断不准确的问题，造成用户以单个商品的金额购买多个商品、某些用户付款了但得不到商品等，算是一个安全风险。</p><h2>0x02 解决方案：</h2><hr><p>核心思想：将一次业务处理流程（如购买操作）作为一个最小操作单元，同一时间只能有一个操作。</p><pre><code>1.  整个操作加内存锁。如在memcache里，开始购买时设置购买状态为进行中，购买结束后清除购买状态，程序开始时即从memcache里判断是否有正在进行的购买操作，如有则退出。
2.  限制每个用户的购买间隔，如10秒内仅允许购买一次，最好也是放在内存里。
3.  当然，优化数据库及程序以加快处理速度也是有必要的。
</code></pre><p><strong>解决方案程序示例(PHP+MySQL+Memcached)</strong></p><pre><code>#!php
/**
 * 通过memcache解决并发购买问题
 */
$goods=$db-&gt;FirstRow("SELECT * FROM ".Tb('goods')." WHERE goods_id='{$goods_id}'");
if(empty($goods)) ShowError('商品不存在');
$mmc=memcache_init();
$lastBuyTime=$mmc-&gt;get('lastBuyTime_'.$user-&gt;userId);
if($lastBuyTime&gt;0 &amp;&amp; $lastBuyTime&gt;time()-10)  ShowError('10秒内只能进行一次购买');
$buying=$mmc-&gt;get('buying');
if($buying==1)  ShowError('有正在进行的购买，请稍候');
/* 金额是否充足 */
if($user-&gt;money&lt;$goods['price'])  ShowError('金额不足，请充值');
/* 商品库存 */
if($goods['num']==0)  ShowError('库存不足');
/* 购买操作 begin */
//生成订单
CreateOrder($goods,$user,time());
$user-&gt;Update('money'=&gt;$user-&gt;money-$goods['price']); //用户金额减少
$db-&gt;Execute("UPDATE ".Tb('goods')." SET num=num-1 WHERE goods_id='{$goods_id}'");//商品库存-1
/* 购买操作 end */
$mmc-&gt;set('buying',0);
$mmc-&gt;set('lastBuyTime_'.$user-&gt;userId,time());
ShowSuccess('购买成功');
</code></pre><p></p></section></article><div class="entry-controls clearfix"><div style="float:left;color:#9d9e9f;font-size:15px"><span>&copy;乌云知识库版权所有 未经许可 禁止转载</span></div></div><div class="yarpp-related"><h3>为您推荐了适合您的技术文章:</h3><ol id="recommandsystem"><li><a href="http://drops.wooyun.org/papers/353" rel="bookmark" id="re1">几种通用防注入程序绕过方法</a></li><li><a href="http://drops.wooyun.org/tips/8166" rel="bookmark" id="re2">使用exp进行SQL报错注入</a></li><li><a href="http://drops.wooyun.org/tips/3464" rel="bookmark" id="re3">SqlServer 2005 Trigger</a></li><li><a href="http://drops.wooyun.org/tips/3790" rel="bookmark" id="re4">Webscan360的防御与绕过</a></li></ol></div><div id="comments" class="comment-list clearfix"><div id="comment-list"><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">tnaw</span> <span class="reply-time">2015-04-11 11:37:11</span></div><p></p><p>wooyun强项是找漏洞，不是修复。</p><p>解决方案一点也不好。 起码应该有事务吧，再高级点，有命令模式吧。</p><p></p></div></div><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">少侠</span> <span class="reply-time">2015-03-26 17:02:30</span></div><p></p><p>楼上的同学们仔细看了吗? 这个解决方案漏洞重重啊<br>1 没有设置buying=1的地方? 还是我没找到?<br>2 第9行和第10行之间有执行时间间隔,如果原来是0,那这个瞬间的所有请求都会通过<br>3 为什么把lastBuyTime_的设置放到最后? 应该放到页首吧,第8行后面<br>4 用秒来计算10秒, 那第0秒或10秒后任意1秒内的所有请求都通过, 1秒内弄个1000QPS没问题吧?</p><p></p></div></div><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">浮世浮城</span> <span class="reply-time">2015-03-24 16:31:54</span></div><p></p><p>膜拜浅蓝大牛</p><p></p></div></div><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">炊烟</span> <span class="reply-time">2015-03-13 17:52:46</span></div><p></p><p>库币不足</p><p></p></div></div><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">Fire ant</span> <span class="reply-time">2015-03-09 12:47:22</span></div><p></p><p>发家致富的时刻到了</p><p></p></div></div><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">浅蓝</span> <span class="reply-time">2015-03-09 12:35:45</span></div><p></p><p>学习了</p><p></p></div></div><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">乌帽子</span> <span class="reply-time">2014-01-11 16:06:02</span></div><p></p><p>http://ww3.sinaimg.cn/bmiddle/53993e84jw1ecf2e1phf8j20c89zl7wi.jpg</p><p></p></div></div><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">clzzy</span> <span class="reply-time">2014-01-07 14:37:36</span></div><p></p><p>尼玛这应该算是逻辑漏洞吧....</p><p></p></div></div><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">_Evil</span> <span class="reply-time">2014-01-02 18:01:03</span></div><p></p><p>楼上也吃过短短的亏啊 忘记了？</p><p></p></div></div><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">nyannyannyan</span> <span class="reply-time">2013-12-30 22:05:43</span></div><p></p><p>加了独占锁...B线程想获取goods记录存必须wait....<br>这是教开发并发程序最开始教的producer-consumer模型...有一套很成型的semaphore的数据结构来解决</p><p></p></div></div><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">xsser</span> <span class="reply-time">2013-12-30 18:22:11</span></div><p></p><p>一看洞主就是吃过亏的人</p><p></p></div></div><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">zsmynl</span> <span class="reply-time">2013-12-26 16:33:28</span></div><p></p><p>学习，学习~</p><p></p></div></div><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">wuxianjun</span> <span class="reply-time">2013-12-26 14:22:38</span></div><p></p><p>不同用户的情况下：<br>A线程 ----&gt; 获取goods当时库存是10个,刚好执行到18行.<br>B线程 ----&gt; 因为A线程执行18行，还没执行减少库存代码,B线程执行4行代码的时候从数据库获取goods的库存还是10个。<br>而这样的情况，假如A线程买了9个走了，实际库存只有一个，这样B线程获取的数据就有问题了。<br>这样会导致库存超卖。</p><p></p></div></div><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">Mr.Anderson</span> <span class="reply-time">2013-12-26 10:54:17</span></div><p></p><p>cool stuff.</p><p></p></div></div><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">小胖子</span> <span class="reply-time">2013-12-25 22:05:46</span></div><p></p><p>用小米的方式来处理，哈哈哈，等你们先抢单，再支付，抢单成功的再支付，队列来解决这个问题。</p><p></p></div></div><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">齐迹</span> <span class="reply-time">2013-12-25 17:14:05</span></div><p></p><p>开启事务都是是会锁表的。理论上不存在绕过的可能。有一个情况我们之前遇到过 当查询的时候走的从库 会导致绕过。</p><p></p></div></div><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">blue</span> <span class="reply-time">2013-12-25 16:40:33</span></div><p></p><p>就是为了解决高并发带来的问题，下单、扣款、减库即使在一个事务里，未处理完时前面的判断也会被绕过，而且像一些通用的电商程序，因为不保证数据库是否支持事务而没有使用事务～</p><p></p></div></div><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">blue</span> <span class="reply-time">2013-12-25 16:24:25</span></div><p></p><p>将操作都放到数据库里肯定最好，之前还看过一程序所有的操作都是存储过程，我这只是描述一种有安全风险的情况和能够快速部署的解决方案</p><p></p></div></div><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">齐迹</span> <span class="reply-time">2013-12-25 15:45:36</span></div><p></p><p>还有就是异步 用队列来实现。</p><p></p></div></div><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">齐迹</span> <span class="reply-time">2013-12-25 15:44:16</span></div><p></p><p>@blue mc 也是有可能延迟的 所以目前最好还是只能利用事务。</p><p></p></div></div><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">wuxianjun</span> <span class="reply-time">2013-12-25 14:51:54</span></div><p></p><p>亲，下单、扣款、减库存在同一个事务里吗？<br>你这程序在高并发的情况下库存会出现超卖的情况。</p><p></p></div></div><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">园长</span> <span class="reply-time">2013-12-25 12:10:26</span></div><p></p><p>业务逻辑缺陷，并发＝RMB</p><p></p></div></div><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">ziwen</span> <span class="reply-time">2013-12-25 12:07:15</span></div><p></p><p>尼玛这应该算是逻辑漏洞吧....</p><p></p></div></div></div></div></div></main>