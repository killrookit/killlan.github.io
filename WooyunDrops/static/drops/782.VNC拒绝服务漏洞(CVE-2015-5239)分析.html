<main class="main-container ng-scope" ng-view=""><div class="main receptacle post-view ng-scope"><article class="entry ng-scope" ng-controller="EntryCtrl" ui-lightbox=""><header><h1 class="entry-title ng-binding">VNC拒绝服务漏洞(CVE-2015-5239)分析</h1><div class="entry-meta"><a target="_blank" class="author name ng-binding">360安全卫士</a> <span class="bull">·</span> <time title="2015/09/21 18:12" ui-time="" datetime="2015/09/21 18:12" class="published ng-binding ng-isolate-scope">2015/09/21 18:12</time></div></header><section class="entry-content ng-binding" ng-bind-html="postContentTrustedHtml"><p></p><p>作者：LR、noirfate</p><h1>0x00 前言</h1><hr><p>Qemu是一款处理器模拟软件，可以提供用户模式模拟和系统模式模拟。当处于用户模式模拟状态时，将使用动态翻译技术，允许一个cpu构建的进程在另一个cpu上执行。</p><p>VNC [ Virtual Network Computing ]是一款优秀的远程控制工具软件。由于Qemu内置vnc功能模块，所以可通过vnc客户端对远程Qemu虚拟机进行远程访问。</p><p>360安全团队的 连一汉 在阅读Qemu-VNC源码过程中，发现了功能模块中的一个远程拒绝服务，漏洞危险等级为中，漏洞编号CVE-2015-5239。</p><p>相关信息见 https://access.redhat.com/security/cve/CVE-2015-5239</p><h1>0x01 VNC通讯协议介绍：</h1><hr><p>VNC采用RFB通信协议。RFB ("remote 帧缓存 ") 是一个远程图形用户的简单协议。通过这个协议，用户可以远程模拟鼠标点击、键盘按键以及文本复制/剪切等功能。本文所讲述漏洞就是在文本复制/剪切时触发的。详细协议格式如下图：</p><p><img alt="enter image description here" img-src="aea83c925de352d1fd5c6821ed3d346934e5088c.jpg"></p><p>举例说明：</p><p>下面这段数据是真实发送的用于文本复制/剪切的报文。</p><pre><code>06 00 00 00 00 00 00 06 74 65 73 74 21 21
06              ：表示协议类型message-type
00 00 00            ：用于填充padding
00 00 00 06     ：待剪切数据的长度length
74 65 73 74 21 21：待剪切数据内容text
</code></pre><p>协议格式相对简单，就不再进一步描述。</p><h1>0x02 漏洞分析：</h1><hr><p>QEMU在通过vnc读取报文中存储的剪切板中的数据时，由于其未对报文中用于描述数据长度的字段进行严格限制，进而导致其出现逻辑错误进入死循环。下面就是程序处理的主体逻辑：</p><pre><code>a)  读取报文中用于描述待读取数据长度的字段
b)  判断这个字段是否超过整个报文的长度。
c)  如果为否，则进行数据复制；如果为是，则跳出循环
</code></pre><p>实现代码如下(ui/vnc.c)：</p><p><img alt="enter image description here" img-src="07e4c83ae86cfedc96d47048918d50eb13cbf554.jpg"></p><p><img alt="enter image description here" img-src="f0549e866ad241334ef471d4040f682d9e36ed2e.jpg"></p><p>从上述代码中可以发现：由于len的初始值为1，所以<code>protocol_client_msg()</code>的返回值为8。<code>Input.offset</code>的值始终为14大于8，所以此时不会跳出循环。在进入下次循环时8将作为<code>protocol_client_msg()</code>的参数len传入，用于读取报文长度字段的值。但是，如果此时读取的报文中的长度字段为<code>0xFFFFFFF9</code>则<code>protocol_client_msg()</code>的返回值又将为1，下次循环时len的值也就又恢复为初始值1。这样，程序又进入开始时的状态，再次调用<code>protocol_client_msg()</code>并且返回值为8。然后又将8传入<code>protocol_client_msg()</code>，读取报文中的长度字段<code>0xFFFFFFF9</code>，返回值又为1，循环往复。由于在这段循环过程中客户端连接标志<code>vs-&gt;csock</code>始终未被更改，程序也将无法跳出循环，从而进入死循环状态。Vnc拒绝服务也就由此产生。</p><p><img alt="enter image description here" img-src="0adc742b19944a29658934fa54bca62e5103f290.jpg"></p><h1>0x03 漏洞危害：</h1><hr><p>攻击者利用该漏洞可以导致虚拟机拒绝服务，并且保持对cpu的高占用率，继而会影响宿主机以及其他虚拟机的正常执行。 我们在测试环境中对该漏洞进行测试，触发前后的截图如下。可以看到，在漏洞触发后qemu-kvm无法远程访问，并占有极高的CPU使用率，严重影响其它程序的运行。 漏洞触发前CPU的状态:</p><p><img alt="enter image description here" img-src="850a81e3cd93c04e5422896f30f6596c8cf66b70.jpg"></p><p>漏洞触发后CPU的状态：</p><h1>0x04 修补方案：</h1><hr><p>官方对该漏洞的修补方法如下：</p><p><img alt="enter image description here" img-src="e1a443322f8c750ac70b14770dc35feeda88f2a9.jpg"></p><p>具体见：<code>http://git.qemu.org/?p=qemu.git;a=commit;h=f9a70e79391f6d7c2a912d785239ee8effc1922d</code> 该补丁中，开发人员对关键数据dlen的大小进行严格的大小判断，确保数据长度值不能超过1MB。这样就完美修复此漏洞。在这里建议所有使用qemu的厂商采用该补丁，防止攻击者利用CVE-2015-5239漏洞对厂商和用户攻击造成损失。 建议厂商安排安全修复。</p><p></p></section></article><div class="entry-controls clearfix"><div style="float:left;color:#9d9e9f;font-size:15px"><span>&copy;乌云知识库版权所有 未经许可 禁止转载</span></div></div><div class="yarpp-related"><h3>为您推荐了适合您的技术文章:</h3><ol id="recommandsystem"><li><a href="http://drops.wooyun.org/papers/9251" rel="bookmark" id="re1">360MarvelTeam虚拟化漏洞第二弹 － CVE-2015-5279 漏洞分析</a></li><li><a href="http://drops.wooyun.org/papers/8596" rel="bookmark" id="re2">KVM虚拟化新型漏洞CVE-2015-6815技术分析</a></li><li><a href="http://drops.wooyun.org/papers/8988" rel="bookmark" id="re3">WordPress Vulnerability Analysis (CVE-2015-5714 &amp; CVE-2015-5715)</a></li><li><a href="http://drops.wooyun.org/papers/7317" rel="bookmark" id="re4">CVE-2015-5090漏洞利用</a></li></ol></div><div id="comments" class="comment-list clearfix"><div id="comment-list"><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">0c0c0f</span> <span class="reply-time">2015-09-22 13:38:12</span></div><p></p><p>第一个while循环没见到调用protocol_client_msg函数的位置啊</p><p></p></div></div></div></div></div></main>