<main class="main-container ng-scope" ng-view=""><div class="main receptacle post-view ng-scope"><article class="entry ng-scope" ng-controller="EntryCtrl" ui-lightbox=""><header><h1 class="entry-title ng-binding">Android sqlite load_extension漏洞解析</h1><div class="entry-meta"><a target="_blank" class="author name ng-binding">路人甲</a> <span class="bull">·</span> <time title="2015/09/25 14:54" ui-time="" datetime="2015/09/25 14:54" class="published ng-binding ng-isolate-scope">2015/09/25 14:54</time></div></header><section class="entry-content ng-binding" ng-bind-html="postContentTrustedHtml"><p></p><h1>0x01 sqlite load_extension</h1><hr><p>SQLite从3.3.6版本（<code>http://www.sqlite.org/cgi/src/artifact/71405a8f9fedc0c2</code>）开始提供了支持扩展的能力，通过sqlite&#95;load&#95;extension API（或者load_extensionSQL语句），开发者可以在不改动SQLite源码的情况下，通过动态加载的库（so/dll/dylib）来扩展SQLite的能力。</p><p><img alt="" img-src="264e54a6cc87da7aa4a668439887c6aceda07638.jpg"></p><p>便利的功能总是最先被黑客利用来实施攻击。借助SQLite动态加载的这个特性，我们仅需要在可以预测的存储路径中预先放置一个覆盖SQLite扩展规范的动态库（Android平台的so库），然后通过SQL注入漏洞调用load&#95;extension，就可以很轻松的激活这个库中的代码，直接形成了远程代码执行漏洞。国外黑客早就提出使用load&#95;extension和sql注入漏洞来进行远程代码执行攻击的方法，如下图。</p><p><img alt="" img-src="74f7cacb50e1afa3746e9c313e4b860dd4357bf2.jpg"></p><p>也许是SQLite官方也意识到了load&#95;extension API的能力过于强大，在放出load&#95;extension功能后仅20天，就在代码中（http://www.sqlite.org/cgi/src/info/4692319ccf28b0eb）将load&#95;extension的功能设置为默认关闭，需要在代码中通过sqlite3&#95;enable&#95;load&#95;extensionAPI显式打开后方可使用，而此API无法在SQL语句中调用，断绝了利用SQL注入打开的可能性。</p><p><img alt="" img-src="0f3445f823c7c3910be50ff33509d1f6d3095be3.jpg"></p><h1>0x02 Android平台下的sqlite load_extension支持</h1><hr><p>出于功能和优化的原因，Google从 Android 4.1.2开始通过预编译宏SQLITE&#95;OMIT&#95;LOAD_EXTENSION，从代码上直接移除了SQLite动态加载扩展的能力,如下图。</p><p><img alt="" img-src="7c6f69e0251cd3da7a08c7c78ed853230e309d88.jpg"></p><p>可以通过adb shell来判断Android系统是不是默认支持load_extension，下图为Android4.0.3下sqlite3的.help命令：</p><p><img alt="" img-src="ab8674b1d96886a34bb4f826427a39de5c078023.jpg"></p><p>可以看出支持load extension，而Android4.1.2上则没有该选项。</p><h1>0x03 Android平台下的sqlite extension模块编译</h1><hr><p>sqlite extension必须包含sqlite3ext.h头文件，实现一个sqlite3&#95;extension&#95;init 入口。下图为一个sqlite extension的基本框架：</p><p><img alt="" img-src="e26f524bd9b8a02b4c7bcab3bbe65424a91e78cb.jpg"></p><p>接着是Android.mk文件，如下图：</p><p><img alt="" img-src="a0f011c4715feb5114ac5fd5a0fbaea2b8bafb9d.jpg"></p><p>我们实现一个加载时打印log输出的一个sqlie extension：</p><p><img alt="" img-src="72a89233a972aac8eb7f6c5f2513698f2e6772fc.jpg"></p><h1>0x04 Android平台下sqlite load_extension实战</h1><hr><p>由于sqlite是未加密的数据库，会导致数据泄露的风险，Android App都开始使用第三方透明加密数据库组件，比如sqlcipher。由于sqlcipher编译时没移除load extension，如图，导致使用它的App存在被远程代码执行攻击的风险。</p><p><img alt="" img-src="4a8c19487c70e00229f61ec28caa950ec76733ab.jpg"></p><p><img alt="" img-src="2dd78348c3958488601de03119ac3b6c3165d2ba.jpg"></p><p>下面我们将通过一个简单的demo来展示sql注入配合load_extension的漏洞利用。</p><p>首先，实现一个使用sqlcipher的Android程序，下载sqlcipher包，将库文件导入项目，如下图：</p><p><img alt="" img-src="6b462b789d80512a39561d7b2845dcd504bd5c26.jpg"></p><p>将导入包换成sqlcipher的：</p><p><img alt="" img-src="ed88667bfcee7f503e4ffb444e5777077d1bcd9e.jpg"></p><p>加载sqlcihper的库文件，并且打开数据库时提供密钥：</p><p><img alt="" img-src="1eaa06344fec3af00dc53eeb77169470ec7e00de.jpg"></p><p>编译的时候如果出错，则将jar包引入并导出，如下图：</p><p><img alt="" img-src="7479840801e969b29ba1b7e7fbdb6928671d8483.jpg"></p><p><img alt="" img-src="f0cd8ae02dba27d7a2ae15744885dc92e2b78ddd.jpg"></p><p>实现一个存在sql注入的数据库查询语句，外部可控，如下图：</p><p><img alt="" img-src="d3e6669f57af27ea2cc8757a3fe913ef68f1812d.jpg"></p><p><strong>该函数接收一个外部可控的参数，并将数据库查询语句进行拼接，导致可被外部植入恶意代码进行</strong>代码执行攻击，如下图：</p><p><img alt="" img-src="5d4c77e5d20247ee7bf9d781feb7cff2499515f4.jpg"></p><p>执行之后，可以看到so加载成功，如下图：</p><p><img alt="" img-src="dcb847079765bbff41f4e7247f1a25339c3cb3c0.jpg"></p><h1>0x05 Android平台下sqlite load_extension攻防</h1><hr><p><strong>攻击场景：</strong>存在漏洞的app可以接收文件，黑客可将文件通过目录遍历漏洞放到app私有目录下，再通过发消息触发sql注入语句，完美的远程代码执行攻击。</p><p><strong>漏洞防御：</strong></p><ol><li>由于sqlcipher的扩展默认是开启的，如果需要sqlcipher，编译sqlcipher的时候通过SQLITE&#95;OMIT&#95;LOAD_EXTENSION宏来关闭sqlcipher的扩展功能。</li><li>进行数据库操作时，禁止将查询语句进行拼接，防止存在sql注入漏洞。</li></ol><p></p></section></article><div class="entry-controls clearfix"><div style="float:left;color:#9d9e9f;font-size:15px"><span>&copy;乌云知识库版权所有 未经许可 禁止转载</span></div></div><div class="yarpp-related"><h3>为您推荐了适合您的技术文章:</h3><ol id="recommandsystem"><li><a href="http://drops.wooyun.org/papers/5164" rel="bookmark" id="re1">Android SecureRandom漏洞详解</a></li><li><a href="http://drops.wooyun.org/tips/3812" rel="bookmark" id="re2">Android Logcat Security</a></li><li><a href="http://drops.wooyun.org/tips/3936" rel="bookmark" id="re3">Android Activtity Security</a></li><li><a href="http://drops.wooyun.org/papers/9769" rel="bookmark" id="re4">Android 5.0屏幕录制漏洞（CVE-2015-3878）威胁预警</a></li></ol></div><div id="comments" class="comment-list clearfix"><div id="comment-list"><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">K4s1</span> <span class="weibo"></span> <span class="reply-time">2015-09-25 17:01:29</span></div><p></p><p>不错 支持一下乌云</p><p></p></div></div></div></div></div></main>