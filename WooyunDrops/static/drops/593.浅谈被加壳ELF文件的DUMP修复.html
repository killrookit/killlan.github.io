<main class="main-container ng-scope" ng-view=""><div class="main receptacle post-view ng-scope"><article class="entry ng-scope" ng-controller="EntryCtrl" ui-lightbox=""><header><h1 class="entry-title ng-binding">浅谈被加壳ELF文件的DUMP修复</h1><div class="entry-meta"><a target="_blank" class="author name ng-binding">腾讯电脑管家</a> <span class="bull">·</span> <time title="2015/06/10 15:45" ui-time="" datetime="2015/06/10 15:45" class="published ng-binding ng-isolate-scope">2015/06/10 15:45</time></div></header><section class="entry-content ng-binding" ng-bind-html="postContentTrustedHtml"><p></p><p>前面的文章中，我已经介绍了如何调试被加壳的ELF，这里不在叙述，直接进入正题，以某加固为例，如何DUMP和修复被加壳的ELF，使其能调试加载</p><p>我们先来看看被加壳ELF的头和Program Header</p><p><img alt="enter image description here" img-src="67a14d17b69c87afab5086c5e7f87a832ba2cbc7.jpg"></p><p><img alt="enter image description here" img-src="1355ec8be9c478500255bb1797350055756c542e.jpg"></p><p>首先我要让调试器停在入口点0x3860的位置</p><p>开始DUMP修复之旅，我的第一次DUMP修复的方法，延续了PE的思路，结果失败了</p><p>失败的原因并不是思路不对，而是细节上出现问题</p><p>第一次DUMP的方法：</p><p>1.废除不影响加载的section(直接把结构体填0)，只关心PT&#95;LOAD和PT&#95;DYNAMIC两种类型节 2.计算DUMP文件最大值 align&#95;up(0x28ca4, 0x8000) = 0x31000 3.将offset和va变成相等值，filesize和memsize按照align对齐 4.根据PT&#95;LOAD节数据把数据DUMP出来，把DUMP数据放进文件里</p><p>那么根据上图描述数据，应该有两块儿</p><pre><code>PT_LOAD : 0 ----align_up(0x12044, 0x8000) = 0 ----- 0x1B000
PT_LOAD : align_down(0x28ca4,0x1000) = 0x28000 ---- align_up(0x28ca4, 0x8000) = 0x31000
</code></pre><p>因为安卓也是linux内核，内存页对齐粒度为4K(0x1000)</p><p>按照上述方法DUMP完，我们来看看IDA加载以后，JNI_ONLOAD的样子</p><p><img alt="enter image description here" img-src="471ae9116b55d311bf6852cdcf2d57c8967d99de.jpg"></p><p>看下红色的部分，奇怪了，本来应该有的代码去哪里了??</p><p><code>0x221b0</code>这个地址竟然无效</p><p>可是动态调试器中明明可以看到这段代码：</p><p><img alt="enter image description here" img-src="3362584e7a5f5e22e887e0ed34d185a9eb8c3c76.jpg"></p><p>对照Program Header, 再看<code>0x221b0</code>这个地址，PT_LOAD节中并没有描述这个地址 所以，失败就是在这个地方，壳的代码里一定是mmap了这段内存，将解密后的数据，放进去，并修改了内存属性</p><p>通过跟踪壳代码，发现确实如此，壳代码通过svc 0，调用了mmap,mprotect两个函数</p><pre><code>mmap(0x3000, 0x23710, 0x3, 0x32, 0xffffffff, 0x0)  
map页属性：PROT_READ | PROT_WRITE
mprotect(0x3000, 0x23710, 0x5)  
</code></pre><p>修改页属性：PROT&#95;READ | PROT&#95;EXEC 具体参数说明请参考帮助文档</p><p>这段区域起始地址：0x3000 大小：<code>align_up(0x23710, 0x1000) = 0x24000</code> 结束地址：<code>0x3000 + 0x24000 = 0x27000</code> 0x221b0这个地址正好在0x3000&#45;--|0x27000这个范围里</p><p>通过上述过程，重新总结DUMP方法如下</p><ol><li>废除不影响加载的section(直接把结构体填0)，只关心PT&#95;LOAD和PT&#95;DYNAMIC两种类型节</li><li>计算DUMP文件最大值 <code>align_up(0x28ca4, 0x8000) = 0x31000</code></li><li>只保留一个PT_LOAD节，从0到<code>0x31000</code> 将整块儿数据DUMP下来直接写入文件，修改align为0x1000，修改flag为RWE</li><li>修改PT_DYNAMIC节的offset,和VA相等 修复完的节表如下：</li></ol><p><img alt="enter image description here" img-src="0de55e694e22753ef7a3c6c235502d424fbd5fb3.jpg"></p><p>最后一个注意的地方，就是干掉INIT段或者是INIT_ARRAY段</p><p>干掉INIT方法：定位INIT描述的数据偏移，将偏移+8的数据，前移8个字节</p><p>干掉INIT_ARRAY方法：定位到VA处，按照结构，将数据填充为0xffffffff或者0</p><p>看下图，INIT段已经不存在了</p><p><img alt="enter image description here" img-src="482b8d1641e89f84df8a13b34aafdb8c9e7ae872.jpg"></p><p>我们来打开IDA，加载修复的文件，看看效果：</p><p><img alt="enter image description here" img-src="6eca83ed760a7864ae73f920b510bab928a2872f.jpg"></p><p><img alt="enter image description here" img-src="82e7209f3f9025f7dfdf15043e543c3cd05f998c.jpg"></p><p>数据完整，再看看动态加载的效果</p><p><img alt="enter image description here" img-src="793954b4fda0b9f37d0f594fbf989b068831449f.jpg"></p><p>加载成功~~~</p><p>哈哈，至此，修复完成</p><p></p></section></article><div class="entry-controls clearfix"><div style="float:left;color:#9d9e9f;font-size:15px"><span>&copy;乌云知识库版权所有 未经许可 禁止转载</span></div></div><div id="comments" class="comment-list clearfix"><div id="comment-list"></div></div></div></main>