<main class="main-container ng-scope" ng-view=""><div class="main receptacle post-view ng-scope"><article class="entry ng-scope" ng-controller="EntryCtrl" ui-lightbox=""><header><h1 class="entry-title ng-binding">Openssl多个安全补丁简易分析危害及修复方案</h1><div class="entry-meta"><a target="_blank" class="author name ng-binding">livers</a> <span class="bull">·</span> <time title="2014/06/06 16:31" ui-time="" datetime="2014/06/06 16:31" class="published ng-binding ng-isolate-scope">2014/06/06 16:31</time></div></header><section class="entry-content ng-binding" ng-bind-html="postContentTrustedHtml"><p></p><h2>0x00 概述</h2><hr><p>心脏出血（CVE-2014-0160）后，Openssl 拿出专项资金进行了代码审计，于6月5号晚发布了所发现的漏洞公告。</p><p><a href="https://www.openssl.org/news/secadv_20140605.txt">https://www.openssl.org/news/secadv_20140605.txt</a></p><p>总结如图：</p><p><img alt="enter image description here" img-src="f4455bb549ee0a0ac1071761fafaad76b5ad65ae.jpg"></p><p>两个高危漏洞 <code>2014-0224中间人攻击（截获明文） 和2014-0195（DTLS 特定包代码执行）</code> 3个拒绝服务 1个缓存区注入 1个特殊漏洞</p><h2>0x01 详情</h2><hr><h3>1. CVE-2014-0224 ChangeCipherSpec 注入</h3><p>漏洞作者：KIKUCHI Masashi</p><h4>漏洞原理</h4><p><img alt="enter image description here" img-src="1a7b44d9c5ae3db19dfe17cca6f886c0ebc03275.jpg"></p><p>按照TLS的协议 在固定的时间顺序内服务端发送和接收ChangeCipherSpec（更改密钥规格）数据，但是实际上openssl的实现：</p><p>服务端在发送时是按照时间线的顺序发送，接收时却没有检查顺序，导致攻击者可以构造伪造的ChangeCipherSpec（比如使用空的主密钥），导致可以中间人攻击解密两端加密信息。</p><p>更多详情：<a href="http://ccsinjection.lepidum.co.jp/blog/2014-06-05/CCS-Injection-en/index.html">http://ccsinjection.lepidum.co.jp/blog/2014-06-05/CCS-Injection-en/index.html</a></p><h4>Poc</h4><p><a href="https://gist.github.com/rcvalle/71f4b027d61a78c42607">https://gist.github.com/rcvalle/71f4b027d61a78c42607</a> <a href="https://gist.github.com/rcvalle/585e12e4d5d3b658cd3d#">https://gist.github.com/rcvalle/585e12e4d5d3b658cd3d#</a></p><h4>影响版本：</h4><p>客户端所有版本都存在。服务端已知的受影响版本OpenSSL 1.0.1 和1.0.2-beta1.</p><p>漏洞产生必须客户端和服务端都使用了受影响版本的openssl。</p><h3>2. CVE-2014-0195 DTLS碎包代码执行</h3><p>漏洞作者:Jüri Aedla(Pwn2Own的火狐溢出执行获胜者)</p><h4>漏洞原理：</h4><p>为了避免被IP分片，在DTLS存在一个数据包处理机制：</p><p>对所有大的UDP包进行分割，每个分割后的DTLS片段有三个标志字段:</p><pre><code>总消息长度
帧偏移量
帧大小长度
</code></pre><p>每个DTLS分包后的总消息长度是固定不变的。</p><p>OPENSSL把每个收到的DTLS包判断（帧大小长度&lt;总的长度）就会把这段长度的数据复制到缓冲区。</p><p>Openssl出错的地方就是：他认为所有DTLS包的总消息长度都是固定不变的。并没有检查总消息长度是否一致</p><p>所有攻击者可构造第一个包：</p><pre><code>总长度 10
分包长度 2
</code></pre><p>第二个包</p><pre><code>总长度 1000
分包长度900
</code></pre><p>由于长度字段占用3个字节，理论上可以写入（2^8）^3数据，再利用上下文执行命令。</p><p>OPENSSL在后面做了一些长度的代码检查但是前面已经执行。</p><p>More: <a href="http://h30499.www3.hp.com/t5/HP-Security-Research-Blog/ZDI-14-173-CVE-2014-0195-OpenSSL-DTLS-Fragment-Out-of-Bounds/ba-p/6501002#.U5FqnvmSyD4">http://h30499.www3.hp.com/t5/HP-Security-Research-Blog/ZDI-14-173-CVE-2014-0195-OpenSSL-DTLS-Fragment-Out-of-Bounds/ba-p/6501002#.U5FqnvmSyD4</a></p><p>受影响范围：</p><pre><code>只有使用到DTLS的应用才会受影响。
包括但不限于：
VPN(openVPN)
VoIP
WebRTC  按照我之前对某些应用的研究很多app使用了这个。包括某 用户量最大的app 视频通信基于这个做的。
SSL的LDAP
SNMPv3
基于SSL的视频 音频
</code></pre><p>（你们只用zmap扫端口是不是太局限了）</p><h3>3. DOS</h3><h4>CVE-2014-0221&amp;&amp;CVE-2014-0198&amp;&amp;CVE-2010-5298</h4><p>CVE-2014-0221</p><p>原理</p><pre><code>发送无效的DTLS握手包到DTLS客户端，可令客户端进入死循环导致拒绝服务。
</code></pre><p>影响</p><pre><code>只对使用了DTLS的客户端有影响。
</code></pre><h4>CVE-2014-0198&amp;&amp;CVE-2010-5298</h4><p>原理</p><pre><code>ssl3_read_bytes功能在竞争条件下可以让攻击者在会话中注入数据或导致拒绝服务。
</code></pre><p>影响</p><pre><code>只有在SSL_MODE_RELEASE_BUFFERS打开的时候受影响（默认关闭）
但是有些服务商为了节省内存会打开此选项。（比如Nginx,apache2.4.1,openvpn）
对DTLS/SSL2无影响。
</code></pre><h4>CVE-2014-3470</h4><p>匿名ECDH套件拒绝服务</p><p>OpenSSL TLS客户端启用了匿名ECDH密码套件会受到拒绝服务攻击。</p><h2>0x02 修复</h2><hr><h3>1. 升级到Openssl最新版</h3><p>Openssl 0.9.8 za</p><p>https://www.openssl.org/source/openssl-0.9.8za.tar.gz</p><p>Openssl 1.0.0m</p><p>https://www.openssl.org/source/openssl-1.0.0m.tar.gz</p><p>Openssl 1.0.1h</p><p>https://www.openssl.org/source/openssl-1.0.1h.tar.gz</p><h3>2. 升级完后 记得重启是配置生效。</h3><p>受影响的客户端及时进行补丁更新。:）</p><p></p></section></article><div class="entry-controls clearfix"><div style="float:left;color:#9d9e9f;font-size:15px"><span>&copy;乌云知识库版权所有 未经许可 禁止转载</span></div></div><div id="comments" class="comment-list clearfix"><div id="comment-list"><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">buptzzy</span> <span class="reply-time">2014-06-17 17:19:49</span></div><p></p><p>为什么服务端受影响的只有1.01和1.02版本？看到很多地方都这么说，但是似乎都没给出原因。另外在测试的时候，用测试脚本发现0.98的也会接受early ccs，显示也可能存在问题。想问下大牛们是怎么回事？</p><p></p></div></div><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">Mumu.</span> <span class="reply-time">2014-06-07 23:46:03</span></div><p></p><p>感谢分析，看了挺有帮助。</p><p></p></div></div><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">动后河</span> <span class="reply-time">2014-06-07 12:30:55</span></div><p></p><p>我猜那app是tudou</p><p></p></div></div><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">livers</span> <span class="reply-time">2014-06-06 22:31:39</span></div><p></p><p>？</p><p></p></div></div><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">动后河</span> <span class="reply-time">2014-06-06 19:01:11</span></div><p></p><p>"WebRTC 按照我之前对某些应用的研究很多app使用了这个。包括某 用户量最大的app 视频通信基于这个做的。"<br>土豆一次，楼下呢？</p><p></p></div></div><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">zj1244</span> <span class="reply-time">2014-06-06 16:39:57</span></div><p></p><p>速度真快，这么快就有分析了</p><p></p></div></div></div></div></div></main>