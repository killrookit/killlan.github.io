<main class="main-container ng-scope" ng-view=""><div class="main receptacle post-view ng-scope"><article class="entry ng-scope" ng-controller="EntryCtrl" ui-lightbox=""><header><h1 class="entry-title ng-binding">Android应用方法隐藏及反调试技术浅析</h1><div class="entry-meta"><a target="_blank" class="author name ng-binding">猎豹科学院</a> <span class="bull">·</span> <time title="2015/10/10 12:20" ui-time="" datetime="2015/10/10 12:20" class="published ng-binding ng-isolate-scope">2015/10/10 12:20</time></div></header><section class="entry-content ng-binding" ng-bind-html="postContentTrustedHtml"><p></p><h1>0x00 前言</h1><hr><p>Android应用的加固和对抗不断升级，单纯的静态加固效果已无法满足需求，所以出现了隐藏方法加固，运行时动态恢复和反调试等方法来对抗，本文通过实例来分析有哪些对抗和反调试手段。</p><h1>0x01 对抗反编译</h1><hr><p>首先使用apktool进行反编译，发现该应用使用的加固方式会让apktool卡死，通过调试apktool源码（如何调试apktool可参见前文《Android应用资源文件格式解析与保护对抗研究》），发现解析时抛出异常，如下图：</p><p><img alt="" img-src="534e1f1f807d0d15e8b4dbe4e08f602b2841dc4b.jpg"></p><p>根据异常信息可知是readSmallUint出错，调用者是getDebugInfo，查看源码如下：</p><p><img alt="" img-src="6d5a8c82528d9cdadfd044bd432a7c7222f95a41.jpg"></p><p>可见其在计算该偏移处的uleb值时得到的结果小于0，从而抛出异常。 在前文《Android程序的反编译对抗研究》中介绍了DEX的文件格式，其中提到与DebugInfo相关的字段为DexCode结构的debugInfoOff字段。猜测应该是在此处做了手脚，在010editor中打开dex文件，运行模板DEXTemplate.bt，找到debugInfoOff字段。果然，该值被设置为了0xFEEEEEEE。</p><p><img alt="" img-src="f21d56fb73794ca0795d79f33256d59e85aed164.jpg"></p><p>接下来修复就比较简单了，由于debugInfoOff一般情况下是无关紧要的字段，所以只要关闭异常就行了。</p><p>为了保险起见，在readSmallUint方法后面添加一个新方法readSmallUint_DebugInfo，复制readSmallUint的代码,if语句内result赋值为0并注释掉抛异常代码。</p><p><img alt="" img-src="e773cc6ef5951d4cf65ea95007ed0fec2d6e4c1a.jpg"></p><p>然后在getDebugInfo中调用readSmallUint_DebugInfo即可。</p><p><img alt="" img-src="d7c0996e59e52c3becea33db923f817f2808223f.jpg"></p><p>重新编译apktool，对apk进行反编译，一切正常。</p><p>然而以上只是开胃菜，虽然apktool可以正常反编译了，但查看反编译后的smali代码，发现所有的虚方法都是native方法，而且类的初始化方法<clinit>中开头多了2行代码，如下图：</clinit></p><p><img alt="" img-src="683a7c23fcf395c35894ff7297960e428c245d05.jpg"></p><p>其基本原理是在dex文件中隐藏虚方法，运行后在第一次加载类时通过在<clinit>方法（如果没有<clinit>方法，则会自动添加该方法）中调用ProxyApplication的init方法来恢复被隐藏的虚方法，其中字符串"aHcuaGVsbG93b3JsZC5NYWluQWN0aXZpdHk="是当前类名的base64编码。</clinit></clinit></p><p>ProxyApplication类只有2个方法，clinit和init，clinit主要是判断系统版本和架构，加载指定版本的so保护模块（X86或ARM）；而init方法也是native方法，调用时直接进入了so模块。</p><p><img alt="" img-src="de6deabd4c98e4e92b1c5d8d3dbf4a107afff59a.jpg"></p><p>那么它是如何恢复被隐藏的方法的呢？这就要深入SO模块内部一探究竟了。</p><h1>0x02 动态调试so模块</h1><p>如何使用IDA调试android的SO模块，网上有很多教程，这里简单说明一下。</p><h2>1. 准备工作</h2><h3>1.1准备好模拟器并安装目标APP。</h3><h3>1.2 将IDA\dbgsrv\目录下的android_server复制到模拟器里，并赋予可执行权限。</h3><pre><code>adb push d:\IDA\dbgsrv\android_server /data/data/sv
adb shell chmod 755 /data/data/sv
</code></pre><h3>1.3 运行android_server，默认监听23946端口。</h3><pre><code>adb shell /data/data/sv
</code></pre><h3>1.4 端口转发。</h3><pre><code>adb forward tcp:23946 tcp:23946
</code></pre><h2>2 以调试模式启动APP，模拟器将出现等待调试器的对话框。</h2><pre><code>adb shell am start -D -n hw.helloworld/hw.helloworld.MainActivity
</code></pre><p><img alt="" img-src="739cef3f43e3ea11f705fbff4dfeeed746515cac.jpg"></p><h2>3 启动IDA，打开debugger->attach->remote Armlinux/andoid debugger，设置hostname为localhost，port为23946，点击OK；然后选择要调试的APP并点击OK。</h2><p><img alt="" img-src="0fc17bfcaa147172cb12c9a2b001380292ede0aa.jpg"></p><p>这时，正常状态下会断下来：</p><p><img alt="" img-src="a84a5a2c961d408514d32c148d1beceb46aa0d55.jpg"></p><p>然后设置在模块加载时中断：</p><p><img alt="" img-src="3d56708faf3595dc59b2c162f69913db05f125b7.jpg"></p><p>点击OK，按F9运行。</p><p>然后打开DDMS并执行以下命令，模拟器就会自动断下来：</p><p><code>jdb -connect com.sun.jdi.SocketAttach:hostname=127.0.0.1,port=8700</code></p><p>（如果出现如下无法附加到目标VM的错误，可尝试端口8600）</p><p><img alt="" img-src="ed8cf48dbd1726076a0e8d888220be8a4d2ca044.jpg"></p><p>此时，可在IDA中正常下断点调试，这里我们断JNI_OnLoad和init函数。</p><p><img alt="" img-src="60dc882cda1da81008335eba695aef972422e3d9.jpg"></p><p><img alt="" img-src="88a463c060e61c5de7b42fd2cbc55aafd68559b3.jpg"></p><p>由于IDA调试器还不够完善，单步调试的时候经常报错，最好先做一个内存快照，然后分析关键点的函数调用，在关键点下断而不是单步调试。</p><h1>0x03 反调试初探</h1><hr><p>一般反调试在JNI&#95;OnLoad中执行，也有的是在INIT&#95;ARRAY段和INIT段中早于JNI&#95;OnLoad执行。可通过readelf工具查看INIT&#95;ARRAY段和INIT段的信息，定位到对应代码进行分析。</p><p><img alt="" img-src="7b0f57e5d2ac64d30509102fd46835312279c2c3.jpg"></p><p>INIT_ARRAY如下：</p><p><img alt="" img-src="da131924ec81deeb063c392e39f34f1f86d3b723.jpg"></p><p>其中函数sub_80407A88的代码如下，通过检测时间差来检测是否中间有被单步调试执行：</p><p><img alt="" img-src="9b337b61ad4ea8741c5efb5f0c2d3357932ddbc0.jpg"></p><p>sub&#95;8040903C函数里就是脱壳了，首先读取/proc/self/maps找到自身模块基址，然后解析ELF文件格式，从程序头部表中找到类型为PT&#95;LOAD，p_offset!=0的程序头部表项，并从该程序段末尾读取自定义的数组，该数组保存了被加密的代码的偏移和大小，然后逐项解密。</p><p><img alt="" img-src="c3b4c2594104203bd7e653e64c6f590312051216.jpg"></p><p>函数check&#95;com&#95;android_reverse里检测是否加载了com.android.reverse，检测到则直接退出。</p><p><img alt="" img-src="7845175ec3d3a00389b634039d7c937f8e416877.jpg"></p><p>JNI_OnLoad函数中有几个关键的函数调用：</p><p><img alt="" img-src="a5f7686d803e8f7cb37dc0bc30ba8192929afaf5.jpg"></p><p>call&#95;system&#95;property_get检测手机上的一些硬件信息，判断是否在调试器中。</p><p><img alt="" img-src="de234943a50b731ec04b27627177d55f355f7d6e.jpg"></p><p>checkProcStatus函数检测进程的状态，打开/proc/$PID/status，读取第6行得到TracerPid，发现被跟踪调试则直接退出。</p><p><img alt="" img-src="3eeba4157c5c5a69a73acf84c834198380c64767.jpg"></p><p>通过命令行查询进程信息，一共有3个同名进程，创建顺序为33->415->430->431。其中415和431处于调试状态：</p><p><img alt="" img-src="c319745a03dfe0cf1175a8dd751c0aaaf38326e9.jpg"></p><p>进程415被进程405（即IDA的android_server）调试：</p><p><img alt="" img-src="3678a7cbf912b29c5a809b42e799532674f37389.jpg"></p><p>进程431被其父进程430调试：</p><p><img alt="" img-src="2a157996d4a2096b846570efa00e65d0fb11d416.jpg"></p><p>要过这种反调试可在调用点直接修改跳转指令，让代码在检测到被调试后继续正常的执行路径，或者干脆nop掉整个函数即可。 检测调试之后，就是调用ptrace附加自身，防止其他进程再一次附加，起到反调试作用。</p><p><img alt="" img-src="e39a266d93998dfa2e37d8a63e2af5b67e707b5f.jpg"></p><p>修改跳转指令BNE（0xD1）为B(0xE0)，直接返回即可。</p><p><img alt="" img-src="a3ee3ed88e590ae02a854dc8366624f7fa713f74.jpg"></p><p>当然，更加彻底的方法是修改android源码中bionic中的libc中的ptrace系统调用。检测到一个进程试图附加自身时直接返回0即可。</p><p>上面几处反调试点在检测到调试器后都直接调用exit()退出进程了，所以直接nop掉后按F9执行。然后就断在了init函数入口，顺利过掉反调试:</p><p><img alt="" img-src="79fbfe0fe83b5342357434fb9e061d8405d42892.jpg"></p><p>init函数在每个类加载的时候被调用，用于恢复当前类的被隐藏方法.首次调用时解密dex文件末尾的附加数据，得到事先保存的所有类的方法属性，然后根据传入的类名查找该类的被隐藏方法，并恢复对应属性字段。 执行完init函数，当前类的方法已经恢复了。然后转到dex文件的内存地址</p><p><img alt="" img-src="f760821817aae612dceb115797da71bc8c5d4b14.jpg"></p><p>dump出dex文件，保存为dump.dex。</p><p><img alt="" img-src="c2484b094ce2f41f94609c5b302c291a9e22b95e.jpg"></p><h1>0x04 恢复隐藏方法</h1><hr><p>对比一下原始dex文件，发现dex文件末尾的附加数据被解密出来了：</p><p><img alt="" img-src="b2c1cbd86281e9e250b78362a27d1d61a22cf6be.jpg"></p><p>仔细分析一下附加数据的数据结构可以发现，它是一个数组，保存了所有类的所有方法的method&#95;idx、access&#95;flags、code&#95;off、debug&#95;info_off属性，解密后的这些属性都是uint类型的,如下图：</p><p><img alt="" img-src="06262bba5e9eab38669a0e11b2daf107d0839fcb.jpg"></p><p>其中黄色框里的就是MainActivity的各方法的属性，知道这些就可以修复dex文件，恢复出被隐藏的方法了。下图就是恢复后的MainActivity类：</p><p><img alt="" img-src="8cd8a5443d113e18bf8b30deaaba42e7fe965cf6.jpg"></p><h1>0x05 总结</h1><hr><p>以上就是通过实例分析展示出来的对抗和反调试手段。so模块中的反调试手段比较初级，可以非常简单的手工patch内存指令过掉，而隐藏方法的这种手段对art模式不兼容，不推荐使用这种方法加固应用。总的来说还是过于简单。预计未来通过虚拟机来加固应用将是一大发展方向。</p><p></p></section></article><div class="entry-controls clearfix"><div style="float:left;color:#9d9e9f;font-size:15px"><span>&copy;乌云知识库版权所有 未经许可 禁止转载</span></div></div><div class="yarpp-related"><h3>为您推荐了适合您的技术文章:</h3><ol id="recommandsystem"><li><a href="http://drops.wooyun.org/mobile/5942" rel="bookmark" id="re1">安卓APP动态调试-IDA实用攻略</a></li><li><a href="http://drops.wooyun.org/tips/2736" rel="bookmark" id="re2">Samsung S Voice attack</a></li><li><a href="http://drops.wooyun.org/papers/3030" rel="bookmark" id="re3">一只android短信控制马的简单分析</a></li><li><a href="http://drops.wooyun.org/tips/4314" rel="bookmark" id="re4">Android Content Provider Security</a></li></ol></div><div id="comments" class="comment-list clearfix"><div id="comment-list"><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">Fakehac</span> <span class="reply-time">2015-11-10 14:02:21</span></div><p></p><p>求加固名称。。想自己调试调试～～</p><p></p></div></div><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">Seven.Sea</span> <span class="reply-time">2015-10-15 14:21:46</span></div><p></p><p>666</p><p></p></div></div><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">发顺丰</span> <span class="reply-time">2015-10-14 10:25:13</span></div><p></p><p>正因为有了这么严实的加固，很多垃圾流氓应用也没法看出来和去除流氓功能了</p><p></p></div></div><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">ruby</span> <span class="reply-time">2015-10-10 23:11:33</span></div><p></p><p>32g e..........赞</p><p></p></div></div><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">dsb2468</span> <span class="reply-time">2015-10-10 15:57:33</span></div><p></p><p>好。。赞。。顶</p><p></p></div></div><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">bigbang</span> <span class="reply-time">2015-10-10 15:37:00</span></div><p></p><p>威武，厉害，希望发更多干货！</p><p></p></div></div></div></div></div></main>