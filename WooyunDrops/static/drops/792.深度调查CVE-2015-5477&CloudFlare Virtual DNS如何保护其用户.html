<main class="main-container ng-scope" ng-view=""><div class="main receptacle post-view ng-scope"><article class="entry ng-scope" ng-controller="EntryCtrl" ui-lightbox=""><header><h1 class="entry-title ng-binding">深度调查CVE-2015-5477&CloudFlare Virtual DNS如何保护其用户</h1><div class="entry-meta"><a target="_blank" class="author name ng-binding">virustracker</a> <span class="bull">·</span> <time title="2015/09/24 15:24" ui-time="" datetime="2015/09/24 15:24" class="published ng-binding ng-isolate-scope">2015/09/24 15:24</time></div></header><section class="entry-content ng-binding" ng-bind-html="postContentTrustedHtml"><p></p><p>原文：<a href="https://blog.cloudflare.com/a-deep-look-at-cve-2015-5477-and-how-cloudflare-virtual-dns-customers-are-protected/">https://blog.cloudflare.com/a-deep-look-at-cve-2015-5477-and-how-cloudflare-virtual-dns-customers-are-protected/</a></p><p>上周，ISC <a href="https://kb.isc.org/article/AA-01272">发布</a>补丁，修复了BIND9 DNS服务器中的一个远程可利用漏洞。这个漏洞会导致服务器在处理某个数据包时发生崩溃。</p><p><img alt="" img-src="2b6f32e53569458b5bef7afc6b4e2e6ea7fcde0c.jpg"></p><p>公告中指出道，服务器在处理TKEY类型的查询时出现了一个错误，这个错误导致assertion fail，而这个fail又造成了服务器的崩溃。因为assertion是在查询解析的过程出现的，所以这个问题无法避免：服务器在接收到数据包时，首先要做的就是解析这个查询，然后再根据需要做出相应的决定。</p><p><a href="https://tools.ietf.org/html/rfc2845">TSIG</a>是DNS服务器使用的一个验证彼此的协议。在这个协议的上下文中用到了<a href="https://tools.ietf.org/html/rfc2930">TKEY 查询</a>。不同于常规的DNS查询，在TKEY查询的信息中，有一个EXTRA/ADDITIONAL节，在这个节中包含有关于TKEY类型的“meta”记录。</p><p><img alt="" img-src="b33607cef8a95a9ab700672a53b0a97df52b43ae.jpg"></p><p>因为现在利用数据包已经公开了，所以我觉着我们可以研究一下这个漏洞代码。那我们就看看这个崩溃实例的输出结果：</p><pre><code>03-Aug-2015 16:38:55.509 message.c:2352: REQUIRE(*name == ((void*)0)) failed, back trace  
03-Aug-2015 16:38:55.510 #0 0x10001510d in assertion_failed()+0x5d  
03-Aug-2015 16:38:55.510 #1 0x1001ee56a in isc_assertion_failed()+0xa  
03-Aug-2015 16:38:55.510 #2 0x1000bc31d in dns_message_findname()+0x1ad  
03-Aug-2015 16:38:55.510 #3 0x10017279c in dns_tkey_processquery()+0xfc  
03-Aug-2015 16:38:55.510 #4 0x100016945 in ns_query_start()+0x695  
03-Aug-2015 16:38:55.510 #5 0x100008673 in client_request()+0x18d3  
03-Aug-2015 16:38:55.510 #6 0x1002125fe in run()+0x3ce  
03-Aug-2015 16:38:55.510 exiting (due to assertion failure)  
[1]    37363 abort (core dumped)  ./bin/named/named -f -c named.conf
</code></pre><p>上面的崩溃代码对我们启示很大,它告诉我们这是由assertion失败导致的崩溃,并且告诉我们出现问题的地方在message.c:2352. 下面是漏洞代码摘要:</p><pre><code>// https://source.isc.org/git/bind9.git -- faa3b61 -- lib/dns/message.c    

    isc_result_t
    dns_message_findname(dns_message_t *msg, dns_section_t section,
                 dns_name_t *target, dns_rdatatype_t type,
                 dns_rdatatype_t covers, dns_name_t **name,
                 dns_rdataset_t **rdataset)
    {
        dns_name_t *foundname;
        isc_result_t result;    

        /*
         * XXX These requirements are probably too intensive, especially
         * where things can be NULL, but as they are they ensure that if
         * something is NON-NULL, indicating that the caller expects it
         * to be filled in, that we can in fact fill it in.
         */
        REQUIRE(msg != NULL);
        REQUIRE(VALID_SECTION(section));
        REQUIRE(target != NULL);
        if (name != NULL)
==&gt;         REQUIRE(*name == NULL);    

    [...]
</code></pre><p>这里，我们找到了一个函数"<code>dns_message_findname</code>"，这个函数的作用是根据message section中给定的名称和类型，查找具有相同名称和类型的RRset。这个函数应用了一个很常见的C API：来获取结果，在结果中填充着caller传递的指针 (<code>dns_name_t **name, dns_rdataset_t **rdataset</code>)。</p><p><img alt="" img-src="a9e04456884cbe1ea3c183ba00f2f6ec3503d936.jpg"></p><p>很讽刺的是，这些指针的验证过程真的非常严格：如果这些指针没有指向(<code>dns_name_t *)NULL，REQUIRE assertion</code>就会fail并且服务器就会崩溃，也不会尝试恢复。调用这个函数的代码必须要格外小心地把指针传递到<code>NULL dns_name_t *</code>，函数会填充到代码中返回找到的名称。</p><p>在非内存安全语言中，当assertion是无效的时候，崩溃就经常出现。因为当出现了异常时，程序很可能就没办法来清理自身的内存了。</p><p>所以，在继续调查中，我们通过栈来查找非法调用。接下来就是<code>dns_tkey_processquery</code>，下面是简化摘要：</p><pre><code>// https://source.isc.org/git/bind9.git -- faa3b61 -- lib/dns/tkey.c    

isc_result_t  
dns_tkey_processquery(dns_message_t *msg, dns_tkeyctx_t *tctx,  
              dns_tsig_keyring_t *ring)
{
    isc_result_t result = ISC_R_SUCCESS;
    dns_name_t *qname, *name;
    dns_rdataset_t *tkeyset;    

    /*
     * Interpret the question section.
     */
    result = dns_message_firstname(msg, DNS_SECTION_QUESTION);
    if (result != ISC_R_SUCCESS)
        return (DNS_R_FORMERR);    

    qname = NULL;
    dns_message_currentname(msg, DNS_SECTION_QUESTION, &amp;qname);    

    /*
     * Look for a TKEY record that matches the question.
     */
    tkeyset = NULL;
    name = NULL;
    result = dns_message_findname(msg, DNS_SECTION_ADDITIONAL, qname,
                      dns_rdatatype_tkey, 0, &amp;name, &amp;tkeyset);
    if (result != ISC_R_SUCCESS) {
        /*
         * Try the answer section, since that's where Win2000
         * puts it.
         */
        if (dns_message_findname(msg, DNS_SECTION_ANSWER, qname,
                     dns_rdatatype_tkey, 0, &amp;name,
                     &amp;tkeyset) != ISC_R_SUCCESS) {
            result = DNS_R_FORMERR;
            tkey_log("dns_tkey_processquery: couldn't find a TKEY "
                 "matching the question");
            goto failure;
        }
    }    

[...]
</code></pre><p>这里有<code>两个dns_message_findname</code>调用，因为我们寻找的是传递恶意name的一个调用，所以我们可以忽略掉第一个调用了，因为前面写着<code>name = NULL</code>;</p><p>第二个调用就比较有意思了。在先调用了<code>dns_message_findname</code>之后，调用又重新使用了相同的<code>dns_name_t *name</code>，而且也没有把它设置成NULL。这可能就是bug出现的地方了。</p><p><img alt="" img-src="5a94ee3b4c1d65830edbafd009a22c950500aa5c.jpg"></p><p>现在的问题是，什么时候<code>dns_message_findname</code>会设置<code>name</code>，而不返回ISC&#95;R&#95;SUCCESS呢（这样的话if条件就能满足了）？现在，我们一起看一看完整的函数主体。</p><pre><code>// https://source.isc.org/git/bind9.git -- faa3b61 -- lib/dns/message.c    

isc_result_t  
dns_message_findname(dns_message_t *msg, dns_section_t section,  
             dns_name_t *target, dns_rdatatype_t type,
             dns_rdatatype_t covers, dns_name_t **name,
             dns_rdataset_t **rdataset)
{
    dns_name_t *foundname;
    isc_result_t result;    

    /*
     * XXX These requirements are probably too intensive, especially
     * where things can be NULL, but as they are they ensure that if
     * something is NON-NULL, indicating that the caller expects it
     * to be filled in, that we can in fact fill it in.
     */
    REQUIRE(msg != NULL);
    REQUIRE(VALID_SECTION(section));
    REQUIRE(target != NULL);
    if (name != NULL)
        REQUIRE(*name == NULL);
    if (type == dns_rdatatype_any) {
        REQUIRE(rdataset == NULL);
    } else {
        if (rdataset != NULL)
            REQUIRE(*rdataset == NULL);
    }    

    result = findname(&amp;foundname, target,
              &amp;msg-&gt;sections[section]);    

    if (result == ISC_R_NOTFOUND)
        return (DNS_R_NXDOMAIN);
    else if (result != ISC_R_SUCCESS)
        return (result);    

    if (name != NULL)
        *name = foundname;    

    /*
     * And now look for the type.
     */
    if (type == dns_rdatatype_any)
        return (ISC_R_SUCCESS);    

    result = dns_message_findtype(foundname, type, covers, rdataset);
    if (result == ISC_R_NOTFOUND)
        return (DNS_R_NXRRSET);    

    return (result);
}
</code></pre><p>你能发现，<code>dns_message_findname</code> 首先使用了<code>findnamet</code>来匹配与目标名称一致的记录，然后用<code>dns_message_findtype</code>来匹配目标类型。在这两个调用之间... <code>*name = foundname</code>！即使<code>dns_message_findname</code> 在 <code>DNS_SECTION_ADDITIONAL</code> 中找到了<code>name == qname</code> 的一条记录，但是类型不是<code>dns_rdatatype_tkey</code> 这个<code>name</code>也会被填充并返回失败。 第二个<code>dns_message_findname</code> 调用会触发恶意 <code>name</code>，然后就一发不可收拾了。</p><p>的确，补丁只是在第二个调用前添加了 <code>name = NULL</code> (不，我们的出发点不是补丁程序，不然还有什么意思)</p><pre><code>diff --git a/lib/dns/tkey.c b/lib/dns/tkey.c  
index 66210d5..34ad90b 100644  
--- a/lib/dns/tkey.c
+++ b/lib/dns/tkey.c
@@ -654,6 +654,7 @@ dns_tkey_processquery(dns_message_t *msg, dns_tkeyctx_t *tctx,
          * Try the answer section, since that's where Win2000
          * puts it.
          */
+        name = NULL;
         if (dns_message_findname(msg, DNS_SECTION_ANSWER, qname,
                      dns_rdatatype_tkey, 0, &amp;name,
                      &amp;tkeyset) != ISC_R_SUCCESS) {
</code></pre><p>让我们再看一下bug触发的流程：</p><ul><li>收到一个<strong>TKEY</strong>类型查询，调用<strong>dns&#95;tkey&#95;processquery</strong>来解析这个查询</li><li><strong>在EXTRA节中找到与查询名称相同的记录，</strong>导致填充了<code>name</code>，但是这条记录并不是一个TKEY记录，导致<code>result != ISC_R_SUCCESS</code></li><li>再次调用<code>dns_message_findname</code>在ANS节中查找，现在是通过恶意的<code>name</code>参考</li><li>assertion *<strong>name != NULL</strong> fail， <code>BIND崩溃</code></li></ul><p><a href="https://twitter.com/@jfoote_">@jfoote_</a>通过 <a href="http://lcamtuf.coredump.cx/afl/">american fuzzy lop</a> 模糊测试工具<a href="https://twitter.com/ISCdotORG/status/626132833849905152">发现了</a>这个bug。模糊测试工具是一个自动工具，能自动向目标程序不断地提交异常输入，直至程序崩溃。你可以通过TKEY 查询+ 非TKEY EXTRA RR的组合来看看服务器最终是怎样崩溃的，并找到这个bug。</p><h1>Virtual DNS用户是安全的</h1><p>好消息！ <a href="https://www.cloudflare.com/virtual-dns">CloudFlare Virtual DNS</a>用户的BIND服务器不会受到这次攻击的影响。如果需要的话，我们的自定义Go DNS服务器-PRDNS会首先解析所有的查询，并“消毒”，然后才会把查询转发回原来的服务器。</p><p>因为Virtual DNS并不支持TSIG和TKEY（用于认证服务器到服务器之间的流量，并不是递归查询），所以没有必要在查询中转发EXTRA节的记录，Virtual DNS也没有这样做。这样面临的攻击风险就小了很多，而且也无法通过Virtual DNS来利用这个漏洞。</p><p>现在还没有什么办法能防御这个漏洞：PRDNS总是会验证进入的数据包是不是良性的，确保查询是正常的，并且简化成最简单的形式，接着才会转发。</p><p></p></section></article><div class="entry-controls clearfix"><div style="float:left;color:#9d9e9f;font-size:15px"><span>&copy;乌云知识库版权所有 未经许可 禁止转载</span></div></div><div class="yarpp-related"><h3>为您推荐了适合您的技术文章:</h3><ol id="recommandsystem"><li><a href="http://drops.wooyun.org/papers/8988" rel="bookmark" id="re1">WordPress Vulnerability Analysis (CVE-2015-5714 &amp; CVE-2015-5715)</a></li><li><a href="http://drops.wooyun.org/papers/13040" rel="bookmark" id="re2">CVE-2015-7547简单分析与调试</a></li><li><a href="http://drops.wooyun.org/papers/9233" rel="bookmark" id="re3">MMD-0043-2015 - 多态型ELF恶意软件:Linux/Xor.DDOS</a></li><li><a href="http://drops.wooyun.org/papers/12039" rel="bookmark" id="re4">CVE-2015-3795</a></li></ol></div><div id="comments" class="comment-list clearfix"><div id="comment-list"><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">乌帽子</span> <span class="reply-time">2015-09-29 20:59:10</span></div><p></p><p>这个图是什么意思？</p><p></p></div></div></div></div></div></main>