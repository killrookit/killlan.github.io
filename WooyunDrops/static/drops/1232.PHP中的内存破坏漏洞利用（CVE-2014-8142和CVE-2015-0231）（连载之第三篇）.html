<main class="main-container ng-scope" ng-view=""><div class="main receptacle post-view ng-scope"><article class="entry ng-scope" ng-controller="EntryCtrl" ui-lightbox=""><header><h1 class="entry-title ng-binding">PHP中的内存破坏漏洞利用（CVE-2014-8142和CVE-2015-0231）（连载之第三篇）</h1><div class="entry-meta"><a target="_blank" class="author name ng-binding">路人甲</a> <span class="bull">·</span> <time title="2016/06/02 10:44" ui-time="" datetime="2016/06/02 10:44" class="published ng-binding ng-isolate-scope">2016/06/02 10:44</time></div></header><section class="entry-content ng-binding" ng-bind-html="postContentTrustedHtml"><p></p><h1>0x00 前言</h1><hr><ul><li>作者: Cigital公司的安全顾问Qsl1pknotp</li><li>题目: Exploiting memory corruption bugs in PHP Part 3: Popping Remote Shells</li><li>地址: <a href="http://www.inulledmyself.com/2015/05/exploiting-memory-corruption-bugs-in.html">http://www.inulledmyself.com/2015/05/exploiting-memory-corruption-bugs-in.html</a></li></ul><p>这片文章所花的时间比我想象中的要长, 不过这时间花得值! 我想通过视频的方式来讲解如何利用这漏洞, 所以这片文章没有之前两篇描述得详细.</p><p>可能会让一些人失望的是, 这篇文章只是介绍了如何写一个 POC (并没有实际放出 POC). 文章末尾的视频会给你们展示我的自动化远程利用工具, 以及在现实环境中为了能让这 POC 成功执行所使用的 tips &amp; trick.</p><h1>0x01 查找数据</h1><hr><p>为了能更简单的解释如何利用这个漏洞, 我使用下面的代码作为演示, 具体情况具体分析.</p><pre><code>#!php
&lt;?php
echo serialize(unserialize(base64_decode($_GET['data'])));
?&gt;
</code></pre><p>我们的目的是能够执行任意 PHP 代码. 当然啦, 我们可以尝试去注入 shellcode 来达到目的, 但是这种方法既没有创造性, 也不优雅(高版本的 PHP 可能不会成功). 如果你还记得 <a href="http://drops.wooyun.org/papers/4864">Part1</a>, 为了能够执行任意 PHP 代码, 我们需要调用 <code>php_execute_script</code> 和 <code>zend_eval_string</code>. 然而, 我们希望能够进行远程攻击, 所以我们必须找到 <code>executor_globals</code> 以及 <code>JMP_BUF</code>. 至于为什么要这样做, 后面会详细介绍.</p><p>简而言之, 我们需要找到 (没有特别的顺序):</p><ul><li><code>executor_globals</code></li><li><code>zend_eval_string</code></li><li><code>JMP_BUF</code></li><li>将任意数据写入 stack 的方法</li></ul><p>比较幸运的是, 上面所列举的要求, 有些还是比较好找的, 因为它们就在 binary 中. 我们直接 dump PHP binay 的 strtab.</p><p><img alt="DumpElfData.png" img-src="6b2710ba95bb50f43f8d269cd817331c597cf3d4.jpg"></p><p>Great! 我们直接从里面找到 <code>zend_eval_string</code> 的地址, 然后在 GDB 中验证这个地址是否正确.</p><ol><li><p>查找 <code>zend_eval_string</code> 的地址</p><p><img alt="GetZendEvalAddress.png" img-src="750f0abefea3376c03e58844ee97b34de541911d.jpg"></p></li><li><p>在 gdb 中查看对应的地址</p><p><img alt="VerifyingZendEvalString.png" img-src="8c0eab8585a52943e01e153ba67e2d14580d898d.jpg"></p></li><li><p>查找 <code>executor_global</code> 的地址</p><p><img alt="GetExecGlobalAddress.png" img-src="3c267bc5d25595a9b89dd2424624a6404661d8e9.jpg"></p></li><li><p>在 gdb 中查看对应的地址</p><p><img alt="PrintGlobalExec.png" img-src="5e3fcf713da609bb002af529dc5eefef0d06e25d.jpg"></p></li></ol><p>Awesome! 现在我们要怎么找到 <code>JMP_BUF</code> 呢? 通过阅读代码, 我们找到了 <a href="https://github.com/php/php-src/blob/9a20323e1946dff57eae8cd054e0893aefe83092/Zend/zend_globals.h#L151"><code>_zend_executor_globals</code></a> 对象, 并在其中发现了一个 <code>JMP_BUF</code> 指针, 名为 <a href="https://github.com/php/php-src/blob/9a20323e1946dff57eae8cd054e0893aefe83092/Zend/zend_globals.h#L164"><code>bailout</code></a>. 让我们挂上 GDB 看看地址是否正确.</p><ol><li><p>查看 <code>zend_executor_globals</code> 对象</p><p><img alt="VerifyingStruct+DataLeakage.png" img-src="344cae6f69713834c7c04cb5d137676402d3b658.jpg"></p></li><li><p>打印 <code>zend_executor_globals-&gt;bailout</code></p><p><img alt="FindingJMPBUF.png" img-src="7226f291a1760b5e19a330cee138cc18a84661a0.jpg"></p></li></ol><p>好, 我们拿到了这个地址, 但是这个地址指向的是什么? 有什么用? 好吧, 在 PHP 中 <code>JMP_BUF</code> 被用来实现 PHP 的 "try{} - catch{}" 机制. 后面会详细介绍这个.</p><h1>0x02 利用方法 1 - ROP</h1><hr><p>我们现在还只差一样东西: 将任意数据写入 stack. 利用方法 2 会详细讨论 Stefan 在 2010 Syscan 公布的方法. 既然我们可以释放任意内存, 那我们下一步该干什么呢? 我们该怎么写数据到 stack 中? 怎么确保写入的数据以后不会被覆盖? (Google is your friend :))</p><p>RFC, 更确切的说是: <a href="https://www.ietf.org/rfc/rfc1867.txt">RFC 1867</a></p><p>这个 RFC 指明允许带有 multipart/form-data 的 POST 请求的数据写入到 stack 中, 而且完全不会被 php 覆盖(由于各种各样的原因). 让我们上传一个"普通"的文件吧.</p><p><img alt="OverwritingStack.png" img-src="29e3f9f4c4cbbfd57ec6f31cab9bb940f9d68f6f.jpg"></p><p>Awesome! 我们可以写入任意数据到 stack 中. 但是我们要写什么到 stack 中?</p><blockquote><p>Hint: 我们之前所寻找的东西 : )</p></blockquote><p>既然之前我们花了那么多时间去找那么多地址, 该时候使用它们了! 所以, 我们应该如何使用之前的地址呢? 经过一些研究, 我们需要这样布局:</p><p><img alt="stack.png" img-src="fae1791c0eac58f659463fdad49c5c3b50a91c32.jpg"></p><p>从最简单的开始: 一开始我们就用 readelf 获取到了 <code>zend_eval_string</code> 的地址. <code>Ret Pointer</code> 和 <code>Zend_Bailout</code> 我们都不需要理会(会导致 PHP crash). 我们在 stack 中填写两次指向 <code>eval_string</code> 的指针, 下面就是我们现有的数据:</p><ul><li>POP; RET - ?????</li><li>XCHG EAX, ESP; RET - ????</li><li>Zend&#95;Eval&#95;String - 0x082da150</li><li>Zend_Bailout - 0x00000000</li><li>Pointer&#95;To&#95;Eval_String - 0xbfffda04</li><li>Ret Pointer - 0x00000000</li><li>Pointer&#95;To&#95;Eval_String - 0xbfffda04</li></ul><p>Sweet! 我们快填写完这些东西了, excellent! 但是, 看起来我们还需要一些 ROP gadgets. 我个人比较喜欢用 ROPGadget, 不过其它工具也是可以的. 我们需要查找 XCHG EAX, ESP; RET (0x94 0xc3), 还需要找 POP EBP; RET (0x5d 0x3c). 一旦找到了这些 gadgets, 我们就可以继续下一步了.</p><p><img alt="Xchg.png" img-src="45bdd4000dece6a62b060c19ae8633c896fc0963.jpg"></p><p><img alt="EBP.png" img-src="ae48501fc5ee377722d6b664b5a57bd998e76e42.jpg"></p><p>我们拿到了这两个地址了(为啥这些地址相差那么大, 因为它们是相对地址), 我们可以继续完成 stack 中的数据:</p><ul><li>POP; RET - 0x000e8e68</li><li>XCHG EAX, ESP; RET - 0x000057b7</li><li>Zend&#95;Eval&#95;String - 0x082da150</li><li>Zend_Bailout - 0x00000000</li><li>Pointer&#95;To&#95;Eval_String - 0xbfffda04</li><li>Ret Pointer - 0x00000000</li><li>Pointer&#95;To&#95;Eval_String - 0xbfffda04</li></ul><p>好了, 该是时候测试了.</p><p><img alt="Segfault.png" img-src="0e7104620d6e43930b334a24c32516e5a07ea735.jpg"></p><p>Hmmm, 这不是我想要的结果, 现在怎么办? 看起来好像我们的代码尝试跳到我们的 gadget (c394). 不幸的是, 你还需要知道一些事情. SPLObjectStorage 要求这些 gadget 在 php 是可以访问的, 所以我们还需要修改一下. 经过修改之后:</p><p><img alt="phpInfoImage.png" img-src="f24f54b99f21556a9368d33a19da6d22bda376c7.jpg"></p><h1>0x03 利用方法 2 - Stefan</h1><hr><p>方法 1 就到此为止了, 方法 1 只能影响老版本的 PHP. 我们继续研究新版本的 PHP 利用方法.</p><p>比较走运的是, 之前找到 <code>php_execute_script</code> 和 <code>jmp_buf</code> 地址, 在新 exploit 中都会被用到.</p><p><code>jmp_buf</code> 在 setjmp &amp; longjmp 中被用来保存 "环境" 以预防 "不可恢复" 的错误. 在 32 位系统中, <code>jmp_buf</code> 是一个存储 6 个 int 的数组, 在 64 位系统中, <code>jmp_buf</code> 存储的是 8 个 int 的数组. 不幸的是, 需要自己查看代码来判断 <code>jmp_buf</code> 保存的寄存器的顺序. 这里有个 <a href="http://www.scs.stanford.edu/histar/src/pkg/uclibc/libc/sysdeps/linux/cris/bits/setjmp.h"><code>jmp_buf</code></a> 样例布局. 让我们看一下 PHP 中的内容...</p><p><img alt="phpJMPBUF.png" img-src="408034763ab64939ccaed05e6e10ed84710147ca.jpg"></p><p>在我的机器上, 寄存器的顺序是: ebx, esp, ebp, esi, edi, eip. 值得完成的事情一般都不怎么容易完成, 在这里也一样, 我们的 edi &amp; eip 看起来貌似被 Glibc 混淆了, Glibc 有个宏叫 <code>PTR_MANGLE</code>, 在视频中, 我们会讲解如何破解 JMPBUF.</p><p>一旦破解出了 edi &amp; eip, 我们就可以继续重写和释放内存了. 幸运的是, 我们可以继续利用 <code>SPLObjectStorage</code> 远程释放内存. 剩下的事情就是将如何写到 stack 中. 和 <a href="http://drops.wooyun.org/tips/4988">Part 2</a>, 我们可以任意操纵 PHP 内存. 我们先释放一些内存, 然后再写 7 byte 数据填充, 当 php 重写我们的数据时, 再重复之前的操作. 第二次重写能够让我们写入任意长度的数据到 stack 中 (我测试的时候, 这个长度大概可以达到 2048 byte). 我们写入的数据和之前使用 ROP 的那个例子差不多. 我们还要继续 "加密" 我们写入 stack 中的数据. 这是攻击效果:</p><p><img alt="phpinfo.png" img-src="aba2c3e3f9aa110ee1137461191deb817c33d206.jpg"></p><h1>0x04 视频地址</h1><hr><p><a href="https://youtu.be/EidBm7-zgSM">video</a>, 自备梯子</p><h3>视频笔记</h3><ul><li>x86 Instruction Chart - <a href="http://sparksandflames.com/files/x86InstructionChart.html">http://sparksandflames.com/files/x86InstructionChart.html</a></li><li>Elf Header lowest 3 bits are 000</li><li>Elf layout - <a href="http://geezer.osdevbrasil.net/osd/exec/elf.txt">http://geezer.osdevbrasil.net/osd/exec/elf.txt</a></li><li>PMAP is your friend when trying to find the "Magic"</li><li>A look at PTR_MANGLE <a href="http://hmarco.org/bugs/CVE-2013-4788.html">http://hmarco.org/bugs/CVE-2013-4788.html</a></li></ul><h1>0x05 译者总结</h1><hr><p>就和作者说的一样, 这篇文章没有之前两篇写得详细.</p><h3>1. 作者那个 PHP binary 文件从哪来的?</h3><p>原文下有评论, 作者说他通过 memory leak 获取了整个 php binary 文件.</p><p>正常情况下, 一般的套路就是:</p><ol><li>查找 ELF magic header <code>\x7fELF</code> 找到起始地址</li><li>通过 <code>strtab</code>, <code>symtab</code> 找到 <code>zend_eval_string</code>, <code>php_execute_script</code>, <code>executor_globals</code> 地址.</li></ol><h3>2. jmpbuf 是什么?</h3><p>jmpbuf 是 setjmp, longjmp 所使用的数据结构, 以实现 try--catch 机制的东西, 和 goto 语法效果差不多, setjmp 相当于在某个位置的 label, longjmp 相当于 goto, 但是 goto 语法并不能跨函数跳转. jmpbuf 主要保存着 caller 的寄存器信息以方便 longjmp 恢复. 另外 glibc 会混淆一些寄存器的值(除了有漏洞的<a href="http://hmarco.org/bugs/CVE-2013-4788.html">glibc</a>).</p><h3>3. 如何解出 jmpbuf?</h3><p>先查看 setjmp 代码:</p><pre><code>#!bash
(gdb) disassemble setjmp
Dump of assembler code for function setjmp:
   0xb7c94410 &lt;+0&gt;: mov    eax,DWORD PTR [esp+0x4]
   0xb7c94414 &lt;+4&gt;: mov    DWORD PTR [eax],ebx        # 1. 保存 ebx
   0xb7c94416 &lt;+6&gt;: mov    DWORD PTR [eax+0x4],esi    # 2. 保存 esi
   0xb7c94419 &lt;+9&gt;: mov    DWORD PTR [eax+0x8],edi    # 3. 保存 edi
   0xb7c9441c &lt;+12&gt;:    lea    ecx,[esp+0x4]
   0xb7c94420 &lt;+16&gt;:    xor    ecx,DWORD PTR gs:0x18
   0xb7c94427 &lt;+23&gt;:    rol    ecx,0x9
   0xb7c9442a &lt;+26&gt;:    mov    DWORD PTR [eax+0x10],ecx # 4. 保存 esp
   0xb7c9442d &lt;+29&gt;:    mov    ecx,DWORD PTR [esp]
   0xb7c94430 &lt;+32&gt;:    xor    ecx,DWORD PTR gs:0x18
   0xb7c94437 &lt;+39&gt;:    rol    ecx,0x9                  
   0xb7c9443a &lt;+42&gt;:    mov    DWORD PTR [eax+0x14],ecx # 5. 保存 eip
   0xb7c9443d &lt;+45&gt;:    mov    DWORD PTR [eax+0xc],ebp  # 6. 保存 ebp
   0xb7c94440 &lt;+48&gt;:    push   0x1
   0xb7c94442 &lt;+50&gt;:    push   DWORD PTR [esp+0x8]
   0xb7c94446 &lt;+54&gt;:    call   0xb7c943c0 &lt;__sigjmp_save&gt;
   0xb7c9444b &lt;+59&gt;:    pop    ecx
   0xb7c9444c &lt;+60&gt;:    pop    edx
   0xb7c9444d &lt;+61&gt;:    ret
</code></pre><p>上面的寄存器保存的都是 caller 的寄存器状态, 其中 esp, eip 都被混淆过了(作者自己的图也是 esp 和 eip 被混淆), 就是使用 <code>PTR_MANGLE</code> 进行混淆.</p><p><code>PTR_MANGLE</code> 和 <code>PTR_DEMANGLE</code> 宏定义如下:</p><pre><code>#!cpp
#  define PTR_MANGLE(reg)   xorl %gs:POINTER_GUARD, reg;              \
                 roll $9, reg
#  define PTR_DEMANGLE(reg) rorl $9, reg;                     \
                 xorl %gs:POINTER_GUARD, reg
</code></pre><p>其中 gs:0x18 就是上面的 <code>POINTER_GUARD</code></p><p>setjmp() 使用 <code>PTR_MANGLE</code> 进行混淆寄存器, longjmp() 使用 <code>PTR_DEMANGLE</code> 解出正常的寄存器. 为了后续能过正常覆盖 jmpbuf, 所以我们需要获得 <code>POINTER_GUARD</code> 的值, 由于 jmpbuf 数据结构可以越界读, caller 的 eip 也可以拿到, 所以通过 <code>PTR_DEMANGLE</code> 就可以获得 <code>POINTER_GUARD</code> 的值.</p><h3>4. 如何获取到 setjmp caller 的 eip ?</h3><p>通过阅读代码, 我们可以知道 <code>php_execute_script</code> 调用了 setjmp, 并将 jmpbuf 保存到 EG(bailout) 中, 通过泄漏 <code>php_execute_script</code> 地址 即可知道调用 setjmp 时到 eip.</p><h3>5. 如何覆盖到 jmpbuf ?</h3><p>jmpbuf 地址向前搜索数值 XX 00 00 00 (XX>0x0c and XX&lt;0x8f), 搜索到一个这样的值之后, 可以把这个值当作一个 memory block.</p><p>先看看 ZMM 的几个结构体:</p><pre><code>#!cpp
/* mm block type */
typedef struct _zend_mm_block_info {
    size_t _size;
    size_t _prev;
} zend_mm_block_info;
</code></pre><p>.</p><pre><code>#!cpp
typedef struct _zend_mm_free_block {
    zend_mm_block_info info;

    struct _zend_mm_free_block *prev_free_block;
    struct _zend_mm_free_block *next_free_block;

    struct _zend_mm_free_block **parent;
    struct _zend_mm_free_block *child[2];
} zend_mm_free_block;
</code></pre><p>.</p><pre><code>#!cpp
struct _zend_mm_heap {
    int                 use_zend_alloc;
    void               *(*_malloc)(size_t);
    void                (*_free)(void*);
    void               *(*_realloc)(void*, size_t);
    size_t              free_bitmap;
    size_t              large_free_bitmap;
    size_t              block_size;
    size_t              compact_size;
    zend_mm_segment    *segments_list;
    zend_mm_storage    *storage;
    size_t              real_size;
    size_t              real_peak;
    size_t              limit;
    size_t              size;
    size_t              peak;
    size_t              reserve_size;
    void               *reserve;
    int                 overflow;
    int                 internal;
#if ZEND_MM_CACHE
    unsigned int        cached;
    zend_mm_free_block *cache[ZEND_MM_NUM_BUCKETS];
#endif
    zend_mm_free_block *free_buckets[ZEND_MM_NUM_BUCKETS*2];
    zend_mm_free_block *large_free_buckets[ZEND_MM_NUM_BUCKETS];
    zend_mm_free_block *rest_buckets[2];
    int                 rest_count;
};
</code></pre><p>我们需要关注的是 <code>_zend_mm_heap</code> 中的 cached. ZMM 会将 0x10 大小的内存块放进 cached 中, 所以当我们找到一个可以当做 memory block 之后, 最后几个字节(7 byte 数据)伪造一个 memory header (&#95;zend&#95;mm&#95;block&#95;info), 然后再用 string 重用这个伪造后的 memory block, 如果写入的长度不足以覆盖 jmpbuf, 继续伪造 memory header 相关的操作, 直到能够覆盖 jmpbuf 为止.</p><h3>6. 能够覆盖 jmpbuf 之后 ?</h3><p>将 eip 设置为 <code>zend_eval_string</code>, 将 esp 设置为一个直接可控的 stack(比如说 jmpbuf 之后), 填充好 jmpbuf, 该混淆的寄存器继续混淆. 然后在这个可控的 stack 上设置好 <code>zend_eval_string</code> 的参数, <code>zend_eval_string</code> 的定义如下:</p><pre><code>#!c
ZEND_API int zend_eval_string(char *str, zval *retval_ptr, char *string_name TSRMLS_DC)
</code></pre><p>最后触发一个 exception, 即可执行我们想要的代码.</p><h3>7. PHP7 的变化 ?</h3><p>php7 的 zval 格式有很大的变化, 通过字符串数据覆盖 zval 结构没法再做到读取任意地址数据了, 只能向后读取数据(<a href="http://drops.wooyun.org/papers/16036">drops</a> 这篇文章的作者 libnex 说他有办法, 期待新文章).</p><pre><code>#!c
struct _zval_struct {
    zend_value        value;            /* value */
    union {
        struct {
            ZEND_ENDIAN_LOHI_4(
                zend_uchar    type,         /* active type */
                zend_uchar    type_flags,
                zend_uchar    const_flags,
                zend_uchar    reserved)     /* call info for EX(This) */
        } v;
        uint32_t type_info;
    } u1;
    union {
        uint32_t     var_flags;
        uint32_t     next;                 /* hash collision chain */
        uint32_t     cache_slot;           /* literal cache slot */
        uint32_t     lineno;               /* line number (for ast nodes) */
        uint32_t     num_args;             /* arguments number for EX(This) */
        uint32_t     fe_pos;               /* foreach position */
        uint32_t     fe_iter_idx;          /* foreach iterator index */
    } u2;
};
</code></pre><p>.</p><pre><code>#!c
struct _zend_string {
    zend_refcounted_h gc;
    zend_ulong        h;                /* hash value */
    size_t            len;
    char              val[1];
};
</code></pre><p>如果通过数据去覆盖 <code>zval_struct</code>, 只能通过修改 len 来实现向后读取.</p><h3>总结 exploit 利用步骤</h3><ol><li>利用 part 2 介绍的方法可以泄漏 <code>std_object_handlers</code> 信息, 随便找一个数值较小的地址</li><li>利用 part 2 介绍的任意地址读取的方法向前读取数据, 直到出现 <code>\x7FELF</code>.</li><li>通过 strtab, symtab 可以泄漏 <code>zend_eval_string</code>, <code>php_execute_script</code>, <code>executor_globals</code> (作者图省事, 文章直接本地 readelf)</li><li>通过 <code>excutor_globals</code> 可以拿到 bailout 地址 (也就是 jmpbuf 地址)</li><li>通过 <code>php_execute_script</code> 获取到调用 setjmp 时的 eip</li><li>获取到了 setjmp caller 的 eip, 再获取到 jmpbuf 地址中 eip 混淆后的值, 通过 <code>PTR_DEMANGLE</code> 即可获得 <code>POINTER_GUARD</code> 的值.</li><li>通过反复释放重用内存, 直到能过覆盖 jmpbuf</li><li>将 <code>zend_eval_string</code> 的地址与之前的 <code>POINTER_GUARD</code> 进行 <code>PTR_MANGLE</code> 写入到 jmpbuf 的 eip 中.</li><li>将 esp 设置为一个我们可写的 stack 范围, 比如说 jmpbuf 之后的内存, 进行 <code>PTR_MANGLE</code> 之后写入到 jmpbuf 的 esp 中.</li><li>在刚刚能覆盖 jmpbuf 的内存块后面依次写入 返回地址, php 代码地址, php 函数名, php 结果返回地址, php 文件名, php 代码.</li><li>触发一个 exception.</li></ol><p>如果还有疑惑的地方, 可以去看看作者的视频以及树人的 paper. 如果我补充的有不正确的地方, 请不吝赐教.</p><p></p></section></article><div class="entry-controls clearfix"><div style="float:left;color:#9d9e9f;font-size:15px"><span>&copy;乌云知识库版权所有 未经许可 禁止转载</span></div></div><div id="comments" class="comment-list clearfix"><div id="comment-list"><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">loopx9</span> <span class="reply-time">2016-06-04 18:30:35</span></div><p></p><p>期待已久的第三篇！</p><p></p></div></div></div></div></div></main>