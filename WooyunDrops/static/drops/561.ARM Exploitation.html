<main class="main-container ng-scope" ng-view=""><div class="main receptacle post-view ng-scope"><article class="entry ng-scope" ng-controller="EntryCtrl" ui-lightbox=""><header><h1 class="entry-title ng-binding">ARM Exploitation</h1><div class="entry-meta"><a target="_blank" class="author name ng-binding">路人甲</a> <span class="bull">·</span> <time title="2015/05/13 10:10" ui-time="" datetime="2015/05/13 10:10" class="published ng-binding ng-isolate-scope">2015/05/13 10:10</time></div></header><section class="entry-content ng-binding" ng-bind-html="postContentTrustedHtml"><p></p><p>原文:Learning Pentesting for Android Devices</p><h3>0x00</h3><hr><p>本文主要带大家了解ARM处理器的基础知识和ARM世界中不同种类的漏洞.我们会进一步分析这些漏洞来搞清楚它的具体利用场景.此外,我们还会研究不同的安卓rooting利用脚本用于挖掘潜在的漏洞.考虑大世面上大多数android智能手机都是基于ARM架构处理器,因此了解ARM以及ARM中存在的安全隐患是非常有价值的.</p><h3>0x01 Introduction to ARM architecture</h3><hr><p>ARM架构基于精简指令集(Reduced Instruction Set Computing <a href="http://baike.baidu.com/link?url=Fhz0XXhUitAZ4AlMdT-exSZP29Joqn6fh-HtrTqUcWV9H3iW6rMAx_G1LtZga4nKGE7vauq7fhvXDLrN7hT_MwytacNITJwM4vSUR1WzYqBeWzVecsCBMSXljxpWnwX-">RISC</a>),这意味着它具有比基于复杂指令集（Complex Instruction Set Computing<a href="http://baike.baidu.com/link?url=T8Kn2EzeE-TjU6ex4i9iVZu4alQrmfmTL4d-Goh3A2LsdX7pYQJC7-Gm7w_A9U1I13DMLDYHp84bCg32R0ls3q">CISC</a>）少得多的指令架构.使用ARM处理器的设备几乎无处不在,比如智能手机,电视,电子书,嵌入式设备等等.</p><p>ARM共有16个通用寄存器从R0到R15.(R0-R7,8个通用寄存器)其中5个有特å殊意义:</p><ul><li>R11: Frame Pointer (FP)</li><li>R12: 内部过程调用暂时寄存器 Intra-procedure Register (IP)</li><li>R13: 栈指针 Stack Pointer (SP)</li><li>R14: 链接寄存器 Link Register (LR)</li><li>R15: 程序计数器 Program Counter (PC)</li></ul><p>下图显示了ARM架构：</p><p><img alt="" img-src="4950e4c3d591174703e72c934967f763857e7680.jpg"></p><p>这五个寄存器中我们应重点关注如下三个:</p><ul><li><p>栈指针 Stack Pointer (SP-R13):存储栈顶指针</p></li><li><p>链接寄存器 Link Register (LR-R14):存储被调用函数返回地址</p></li><li><p>程序计数器 Program Counter (PC-R15):存储着下一条执行指令的地址.每条执行被执行后，该计数器会进行自增.</p></li></ul><h3>0x02 Execution modes</h3><hr><p>ARM有两种执行模式:</p><ul><li>ARM 模式: In the ARM mode, 32位指令集</li><li>Thumb 模式: In the Thumb mode, 16位指令集</li></ul><p>执行模式取决于程序状态寄存器(CPSR)的状态.其实存在第三种模式: Thumb-2模式,就是将arm模式和Thumb模式混合.我们不会去分析这两种模式的区别,因为这样就超出本文的范围了.即使是Android SDK中的模拟器也是arm平台的,其他大多数的智能手机也是基于arm.但是我们还是选择从开源硬件模拟器<a href="http://wiki.qemu.org/Main_Page">QEMU</a>开始进行ARM exploitation的训练.</p><h3>0x03 Setting up the environment</h3><hr><p>在我们开始基于ARM平台设备的exploiting前建议先安装好对应的环境.尽管Android SDK的模拟器也能基于arm运行,而且大多数的智能手机也是基于arm.我们还是选择用QEMU(开源硬件虚拟机和模拟器)开始ARM exploitation.</p><p>为了在android设备上执行接下来的操作,我们需要下载和配置Android NDK环境.如果你正使用Mac,那么安装QEMU是非常简单的,只需要输入:<code>brew install qemu</code></p><p>如果系统是Ubuntu需要执行如下操作:</p><p>1.第一步下载安装QEMU依赖包</p><pre><code>sudo apt-get build-dep qemu
wget http://wiki.qemu-project.org/download/qemu-
   1.7.0.tar.bz2
</code></pre><p>2.下一步配置QEMU,指定目标为ARM最后make.只需要进入解压后的目录输入如下命令.</p><pre><code>./configure --target-list=arm-softmmu
make &amp;&amp; make install
</code></pre><p>3.一但QEMU安装成功,我们就可以下载ARM平台的Debian镜像运行exploitation习题.下载列表:</p><p><a href="http://people.debian.org/~aurel32/qemu/armel/">http://people.debian.org/~aurel32/qemu/armel/</a></p><p>4.这里我们下载格式为qcow2的镜像,debian&#95;squeeze&#95;armel_ standard是基于QUME的系统镜像.qcow2 for our OS.内核文件是 vmlinuz-2.6.32- 5-versatile ,RAM磁盘文件是initrd.img-2.6.32-5- versatile.下载完必须文件后就可以通过以下指令启动QEMU实例.</p><pre><code>qemu-system-arm -M versatilepb -kernel vmlinuz-2.6.32-5-versatile -initrd initrd.img-2.6.32-5-versatile -hda debian_squeeze_armel_standard.qcow2 -append "root=/dev/sda1" --redir tcp:2222::22
</code></pre><p>5.上述所有操作成功就可以通过以下命令ssh登录QEMU:</p><pre><code>ssh root@[ip address of Qemu] -p 2222
</code></pre><p>6.默认帐号密码是root:root.</p><p><img alt="" img-src="17a2378f6a7f13c5bece09e3277feaf944fca062.jpg"></p><p>到此我们已经成功配置好环境,是时候开始exploiting存在漏洞的应用</p><h3>0x04 Simple stack-based buffer overflow</h3><hr><p>简单来讲,缓存(buffer)是用于存储任意数据的地方.当缓存的数据超过了缓存区的大小就会发生溢出(overflow).攻击者可以利用溢出攻击来控制程序执行恶意代码.</p><p>下面就用一个简单的程序来演示如何利用溢出攻击.下图中显示程序有三个函数:vulnerable, ShouldNotBeCalled以及 main.</p><p><img alt="" img-src="a3a2c7c375f76e3334172befd67b3d494c2cc6fe.jpg"></p><p>执行程序的时候函数 <code>ShouldNotBeCalled</code> 一直没有被调用.</p><p>函数<code>vulnerable</code>只有一个操作就是将成员变量拷贝到只有10bytes大小的缓存buff中.</p><p>写完此程序后通过gcc编译(arm虚拟机中编译).此外我们还将禁用空间格局随机化Address Space Layout Randomization (ASLR)让利用场景变得更简单些.ASLR是一种针对缓冲区溢出的安全保护技术，通过对堆、栈、共享库映射等线性区布局的随机化,通过增加攻击者预测目的地址的难度,防止攻击者直接定位攻击代码位置,达到阻止溢出攻击的目的.据研究表明ASLR可以有效的降低缓冲区溢出攻击的成功率,如今Linux、FreeBSD、Windows等主流操作系统都已采用了该技术.Android 4.0之后也实现了该方案.<a href="http://www.duosecurity.com/blog/exploit-mitigations-in-android-jelly-bean-4-1">http://www.duosecurity.com/blog/exploit-mitigations-in-android-jelly-bean-4-1</a></p><pre><code>echo 0 &gt; /proc/sys/kernel/randomize_va_space //禁用ASLR
gcc -g buffer_overflow.c -o buffer_overflow  //编译example
</code></pre><p>下一步,用gdb调试二进制文件.</p><pre><code>gdb -q buffer_overflow
</code></pre><p>使用<code>disass</code>命令反编译一部分函数,下图为反编译<code>ShouldNotBeCalled</code></p><p><img alt="" img-src="e172fce65a0318547f10f8c90870a6c2a2a03b7c.jpg"></p><p>正如截图中说看到的,函数<code>ShouldNotBeCalled</code>从内存地址0x00008408开始.如果我们查看反编译的<code>main</code>函数,将会发现<code>vulnerable</code>函数是从0x000084a4开始调用,在0x000084a8返回.当程序进入存在漏洞的函数,使用有漏洞的指令strcpy,函数并不会检查拷贝字符串的大小.如果程序进入存在漏洞的子程序,我们就能够通过控制LR控制整个程序流程.</p><p>这里目标是估算LR何时被重写之后插入<code>ShouldNotBeCalled</code>地址来调用函数<code>ShouldNotBeCalled</code>.用一个较长的参数运行程序,比如下面的命令,观察发生了啥.在此之前先在调用<code>strcpy</code>地址处设置断点.</p><pre><code>b vulnerable
b *&lt;address of the strcpy call&gt;
</code></pre><p>通过设置断点,我们可以将参数改成AAAABBBBCCCC运行程序观察他如何被覆盖.观察发现在vulnerable和strcpy函数被调用时触发断点.一但断点触发,我们就可以通过<code>x</code>命令指定sp操作堆栈.如下图</p><p><img alt="" img-src="7e6db71b9b46212a17f71edd448ea8e5d4cac3cb.jpg"></p><p>如图所示,堆栈已经被我们输入(ASCII: 41 for A, 42 for B, and so on)的buffer重写.分析截图,发现0x000084a8这种情况我们需要多于4个字节去覆盖返回地址.</p><p>最终输入的字符串为16字节的垃圾数据和函数<code>ShouldNotBeCalled</code>的地址</p><pre><code>r `printf "AAAABBBBCCCCDDDD\x38\x84"`
</code></pre><p>如图所示,我们将<code>IShouldNeverBeCalled</code>起始地址插入参数中</p><p><img alt="" img-src="55c28668dea578c3e62d7554bec14d0a48e12971.jpg"></p><p>请注意,因为框架原因这里字节顺序是相反的.这样就能看到程序调用函数ShouldNotBeCalled了.如下图</p><p><img alt="" img-src="549135817b804ff0c7104e7250914a8fcd930c54.jpg"></p><h3>0x05 Return-oriented programming</h3><hr><p>大多数情况下,我们并不需要调用程序自身的其他函数.相反,我们需要在攻击向量中插入shellcode,这样就可以通过shellcode达到任意目的.但是,再大多数基于arm平台的设备中内存区域是不可执行的,这样就阻止了我们插入和执行shellcode.</p><p>所以,攻击者必须依赖一项技术<strong>返回导向编程 return-oriented programming <a href="http://zh.wikipedia.org/wiki/%E8%BF%94%E5%9B%9E%E5%AF%BC%E5%90%91%E7%BC%96%E7%A8%8B">ROP</a></strong>.所谓ROP,简单的说就是把原来内存已经存在的代码块拼接起来,拼接的方式是通过一个预先准备好的特殊的返回栈,里面包含了各条指令结束后下一条指令的地址.最终执行我的shellcode.在一般程序里面,都包含着大量的返回指令（ret）,他们基本位于函数的尾部,或是函数中部需要返回的地方.而从函数开始的地方到ret指令之间的这一段序列称为二进制指令代码块(gadgets).我们需要在整个内存空间中搜索我们需要的gadgets</p><p>举个例子,如果我们在调试程序的时候反编译<code>seed48()</code>,得到如下输出:</p><p><img alt="" img-src="d1161b09f31b55862d29c8e7a31db155dcd110f1.jpg"></p><p>分析反编译代码,代码包含一个ADD指令接着是POP和BX指令,这就是完美的 ROP gadget.这里攻击者可以想到为了利用 ROP gadget 首先跳到POP指令控制R4(which will be six less than the address of /bin/sh)之后在LR中输入ADD指令的值.最后我们得到 /bin/sh 的地址,当我们跳会ADD (R0 = R4 + 6 ),之后我们可以在R4中指定任意垃圾数据以及LR中指定 system() 的地址.</p><p>这意味着我们最终讲跳到 system() 并且参数为 /bin/sh , 这样就可以执行shell命令了.用同样的方式,我们可以创建任意ROP gadget 来达到执行任意命令的效果.因为ROP是个非常复杂的话题,强烈建议自己动手尝试分析反编译代码,然后构造exploit.</p><h3>0x06 Android root exploits</h3><p>在早期android版本中,各种android版本的各种设备都遇到Android root exploits .Android rooting就是获取设备的最高权限而不是手机制造厂商给用户的默认权限.这些root exploits利用了各种Android系统漏洞.下面是一些漏洞列表和漏洞原理简介:</p><ul><li><p><strong>Exploid</strong>: CVE-2009-1185 影响android2.1及之前版本,此exploit基于<code>udev</code>漏洞CVE-2009-1185,udev是一个android组件负责USB连接,进程应该只处理kernel发送的device的NETLINK的socket消息，但实际上并未检测NETLINK的socket消息的来源,这样可以广播add device的socket信息,触发硬件处理事件,将恶意代码传入kernel,由其写入设备文件.这样,攻击者只需发送一条构造好的udev消息就可以提权了.</p></li><li><p><strong>Gingerbreak</strong>:CVE-2011-1823,此exploit利用vold的漏洞,原理类似上一个.(android并没有实现linux的udev，其功能由vold进程实现，其包含VolumeManager，NetlinkManager，CommandListener等modules).Android 2.3.4之前版本的 volume 守护进程(vold)由于信任从 PF_NETLINK socket 接收到的消息,因此允许以 root 权限执行任意代码,利用方法是通过一个负数索引绕过指针对最大值的有符号整数检查.</p></li><li><p><strong>RageAgainstTheCage</strong>:此exploit基于<code>RLIMIT_NPROC</code>,RLIMIT&#95;NPROC用于指定用户调用setuid()函数的时候能创建的最大进程数.adb 后台是root权限,之后会调用 setuid() 自行降权.android 2.2 以及之前版本如果进程数达到RLIMIT&#95;NPROC的阈值,程序就不会调用setuid()降权,这样adb就会以root权限运行了.</p></li><li><p><strong>Zimperlich</strong>:与<code>RageAgainstTheCage</code>原理类似,不一样的是此处依赖的zygote进程的降权.所有的android应用是由Zygote进程fork分支后启动的.Zygote是由root权限运行的.在fork之后新的进程将使用setuid调用降权至目标应用的uid.Android2.2以及之前版本的Zygote没有对降权时setuid调用的返回值进行检查.同样,在耗尽目标程序uid的最大进程数之后,Zygote就无法降低它的权限,然后就以root权限启动应用了.</p></li><li><p><strong>KillingInTheNameOf</strong>: CVE-2011-1149 此expolit利用了<code>ashmem</code> (the shared memory manager) 接口漏洞,用于修改<code>ro.secure</code>的值,ro.secure决定了设备的root状态.Android 的共享内存(Ashmem)子系统是一个共享内存分配器.共享内存可以通过 mmap 或者文件 I/O 进行访问.在android 2.3之前,ashmem 允许任何用户重新映射属于 init 进程的共享内存,将包括系统属性地地址空间的内存进行共享,KillingInTheNameOf 利用程序将系统属性空间重新映射为可写,并将 ro.secure 属性设置为0.在重启 adbd 后,ro.secure 属性的修改会允许 adb shell 取得 root 权限访问.</p></li></ul><p>这些都是比较出名的用户root安卓设备的exploits.</p><h3>0x07 附录</h3><hr><p>数据处理指令-指令编码</p><p><img alt="" img-src="4af7284109dcbd758582209c6cad2917971c8869.jpg"></p><p>操作码功能表</p><p><img alt="" img-src="8308831602c2b77da39142de9396777500f36719.jpg"></p><p>分支指令B/BL-指令编码</p><p><img alt="" img-src="68a337af7466cf35be763c94643cfb6b27187bff.jpg"></p><p>分支指令BX-指令编码</p><p><img alt="" img-src="4998791f3a9ca3a27a94a6930d023339174b1c8d.jpg"></p><p>分支指令功能表</p><p><img alt="" img-src="b7bfb6eb920b992b03b118eca2d9a2e864d8ea06.jpg"></p><ul><li>跳转指令:<ul><li>B 跳转指令。</li><li>BL 带返回的跳转指令。</li><li>BLX 带返回和状态切换的跳转指令。</li><li>BX 带状态切换的跳转指令。</li></ul></li><li>数据处理指令<ul><li>MOV 数据传送指令</li><li>MVN 数据取反传送指令</li><li>CMP 比较指令</li><li>CMN 反值比较指令</li><li>TST 位测试指令</li><li>TEQ 相等测试指令</li><li>ADD 加法指令28</li><li>ADC 带进位加法指令</li><li>SUB 减法指令</li><li>SBC 带借位减法指令</li><li>SUB 减法指令</li><li>SBC 带借位减法指令</li><li>RSB 逆向减法指令</li><li>RSC 带借位的逆向减法指令</li><li>AND 逻辑与指令</li><li>ORR 逻辑或指令</li><li>EOR 逻辑异或指令</li><li>BIC 位清除指令</li></ul></li><li>乘法指令与乘加指令<ul><li>MUL 32 位乘法指令</li><li>MLA 32 位乘加指令</li><li>SMULL 64 位有符号数乘法指令</li><li>SMLAL 64 位有符号数乘加指令</li><li>UMULL 64 位无符号数乘法指令</li><li>UMLAL 64 位无符号数乘加指令</li></ul></li><li>程序状态寄存器存取指令<ul><li>MRS 程序状态寄存器到通用寄存器的数据传送指令。</li><li>MSR 通用寄存器到程序状态寄存器的数据传送指令。</li></ul></li><li>寄存器加载/存储指令<ul><li>LDR 字数据加载指令</li><li>LDRB 字节数据加载指令</li><li>LDRH 半字数据加载指令</li><li>STR 字数据存储指令</li><li>STRB 字节数据存储指令</li><li>STRH 半字数据存储指令</li><li>LDM 连续数据加载指令</li><li>STM 连续数据存储指令</li></ul></li><li>数据交换指令 :<ul><li>SWP 字数据交换指令</li><li>SWPB 字节数据交换指令</li></ul></li><li>移位元指令：<ul><li>LSL 逻辑左移</li><li>ASL 算术左移</li><li>LSR 逻辑右移</li><li>ASR 算术右移</li><li>ROR 循环右移</li><li>RRX 带扩充的循环右移</li></ul></li><li>协处理器指令<ul><li>CDP 协处理器数据操作指令</li><li>LDC 协处理器数据加载指令</li><li>STC 协处理器数据存储指令</li><li>MCR ARM处理器寄存器到协处理器寄存器的数据传送指令</li><li>MRC 协处理器寄存器到ARM处理器寄存器的数据传送指令</li></ul></li></ul><p>arm架构完整版</p><p><img alt="" img-src="7bc0309deb87b02df78246e1b1c8b8cf2464ece8.jpg"></p><h3>0x08 参考</h3><hr><p><a href="http://infocenter.arm.com/help/topic/com.arm.doc.qrc0001mc/QRC0001_UAL.pdf">http://infocenter.arm.com/help/topic/com.arm.doc.qrc0001mc/QRC0001_UAL.pdf</a></p><p><a href="http://bbs.pediy.com/showthread.php?t=176283">http://bbs.pediy.com/showthread.php?t=176283</a></p><p><a href="http://hack0nair.me/2013-04-05-return-oriented-programming/">http://hack0nair.me/2013-04-05-return-oriented-programming/</a></p><p><a href="http://blog.csdn.net/jackaduma/article/details/7286348">http://blog.csdn.net/jackaduma/article/details/7286348</a></p><p></p></section></article><div class="entry-controls clearfix"><div style="float:left;color:#9d9e9f;font-size:15px"><span>&copy;乌云知识库版权所有 未经许可 禁止转载</span></div></div><div id="comments" class="comment-list clearfix"><div id="comment-list"><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">封停</span> <span class="reply-time">2015-05-14 23:21:13</span></div><p></p><p>@瘦蛟舞 你老板让你赶快掏干货，再不写，就让你捡肥皂……</p><p></p></div></div><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">瘦蛟舞</span> <span class="reply-time">2015-05-14 10:11:35</span></div><p></p><p>@我是壮丁 我就不写,我就 BB</p><p></p></div></div><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">我是壮丁</span> <span class="reply-time">2015-05-13 19:19:00</span></div><p></p><p>@error 快来写啊</p><p></p></div></div><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">error</span> <span class="reply-time">2015-05-13 16:17:49</span></div><p></p><p>表示没有干货</p><p></p></div></div><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">小荷才露尖尖角</span> <span class="reply-time">2015-05-13 10:31:14</span></div><p></p><p>感谢</p><p></p></div></div></div></div></div></main>