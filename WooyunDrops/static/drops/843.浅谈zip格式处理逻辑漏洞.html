<main class="main-container ng-scope" ng-view=""><div class="main receptacle post-view ng-scope"><article class="entry ng-scope" ng-controller="EntryCtrl" ui-lightbox=""><header><h1 class="entry-title ng-binding">浅谈zip格式处理逻辑漏洞</h1><div class="entry-meta"><a target="_blank" class="author name ng-binding">路人甲</a> <span class="bull">·</span> <time title="2015/10/22 10:21" ui-time="" datetime="2015/10/22 10:21" class="published ng-binding ng-isolate-scope">2015/10/22 10:21</time></div></header><section class="entry-content ng-binding" ng-bind-html="postContentTrustedHtml"><p></p><p><strong>前言：</strong><code>zip</code>压缩格式应用广泛，各个平台都有使用，<code>Windows</code>平台使用来压缩文件，<code>Android</code>平台使用来作为<code>apk</code>文件的格式。由于<code>zip</code>文件格式比较复杂，在解析<code>zip</code>文件格式时，如果处理不当，可能导致一些有意思的逻辑漏洞，本篇文章将挑选有意思的漏洞进行解析。</p><h1>一、文件扩展名欺骗漏洞</h1><hr><p>很早之前，国外安全研究人员<a href="http://www.exploit-db.com/papers/32480/">爆料Winrar 4.x版本存在文件扩展名欺骗漏洞</a>，黑客可以通过该漏洞诱骗受害者执行恶意程序。该漏洞的主要原理是：<code>Winrar</code>在文件预览和解压缩显示文件名使用的是不同结构体的字段导致的。</p><h3>1.1 zip格式文件的结构</h3><p>在了解漏洞的原理前，先熟悉下zip格式的文件结构。</p><p>如果一个压缩包文件里有多个文件，可以认为每个文件都是被单独压缩，然后再拼成一起。</p><p>一个 <code>ZIP</code> 文件由三个部分组成：压缩源文件数据区+压缩源文件目录区+压缩源文件目录结束标志，如下图：</p><p><img alt="enter image description here" img-src="3b22cb5743e0cd42183bdf2041ae73706531e76b.jpg"></p><p>1）文件头（压缩源文件目录区）在文件末尾，即图1中的<code>File Header</code>，记录了索引段的偏移、大小等等。</p><p>2）数据段（压缩源文件数据区）在文件开头，即图1中的<code>Local Header</code>，记录了数据的一些基本信息，可以用来跟<code>File Header</code>中记录的数据进行比较，保证数据的完整性。</p><p>3）<code>Local Header</code>还包含了文件被压缩之后的存储区，即图1中的<code>Data</code>区域。</p><p>4）图2和图3为<code>Local Header</code>（图2中的<code>ZIPFILERECORD</code>）和<code>File Header</code>（图3中的<code>ZIPDIRENTRY</code>）的数据对比，两者数据是一致的。</p><p><img alt="enter image description here" img-src="f09e995c067b476a85fda41c9829bbc7823d4a59.jpg"></p><p><img alt="enter image description here" img-src="29566e6c49309ee94dbd45ac43b9eff646c371bb.jpg"></p><h3>1.2 漏洞产生原因</h3><p><code>Winrar</code>在文件预览的时候使用的是<code>ZIPDIRENTRY</code>下面的<code>deFileName</code>字段来显示文件名，解压缩的时候使用的是<code>ZIPFILERECORD</code>下面的<code>frFileName</code>字段来显示文件名。如果将<code>deFileName</code>字段文件扩展名改成<code>jpg</code>、<code>gif</code>等图片的文件扩展名，可以欺骗用户运行恶意程序。</p><p><code>Winrar</code>文件预览示意图：</p><p><img alt="enter image description here" img-src="cac2e0f33cfaad8a1c849881279f22716582f7ae.jpg"></p><p>用户看到的是<code>jpg</code>图片，打开的确实<code>exe</code>文件，真坑啊！</p><p><code>Winrar</code>解压缩文件示意图：</p><p><img alt="enter image description here" img-src="5f27ab7e238fb32ef99e6fcd6be367cb7750864e.jpg"></p><p>解压缩之后显示的<code>exe</code>，两处显示的不一样。</p><h1>二、Android Master Key漏洞</h1><hr><p>之前，国外安全研究人员爆出<a href="http://www.saurik.com/id/19">第三个Android Master Key漏洞</a>，该漏洞的主要原理是：<code>android</code>在解析<code>Zip</code>包时，没有校验<code>ZipEntry</code>和<code>Header</code>中的<code>FileNameLength</code>是否一致。</p><h3>2.1 zip文件格式的结构</h3><p>在了解漏洞的原理前，还是先熟悉下<code>zip</code>格式的文件结构。</p><p>如果一个压缩包文件里有多个文件，可以认为每个文件都是被单独压缩，然后再拼成一起。</p><p>一个 <code>ZIP</code> 文件由三个部分组成：压缩源文件数据区+压缩源文件目录区+压缩源文件目录结束标志，如图1所示：</p><p>1）文件头（压缩源文件目录区）在文件末尾，即图1中的<code>File Header</code>，记录了索引段的偏移、大小等等。</p><p>2）数据段（压缩源文件数据区）在文件开头，即图1中的<code>Local Header</code>，记录了数据的一些基本信息，可以用来跟<code>File Header</code>中记录的数据进行比较，保证数据的完整性。</p><p>3）<code>Local Header</code>还包含了文件被压缩之后的存储区，即图1中的<code>Data</code>区域。</p><p>4）图2和图3为<code>Local Header</code>（图2中的<code>ZIPFILERECORD</code>）和<code>File Header</code>（图3中的<code>ZIPDIRENTRY</code>）的数据对比，两者数据是一致的。</p><p><img alt="enter image description here" img-src="8736bfd58c3b55cb11573fc61cf3e550adfc28f0.jpg"></p><p><img alt="enter image description here" img-src="8de9174f32aeb49bca0176de1497af112c74b97f.jpg"></p><h3>2.2 漏洞产生原因</h3><p>先来看一下是如何定位到<code>Local Header</code>中的<code>Data</code>数据：</p><pre><code>off64_t dataOffset = localHdrOffset + 
                     kLFHLen + 
                     get2LE(lfhBuf + kLFHNameLen) +
</code></pre><p><code>Data</code>的偏移是通过<code>Header</code>的起始偏移+<code>Header</code>的大小（固定值）+<code>Extra data</code>的大小+文件名的大小，如下图</p><p><img alt="enter image description here" img-src="cb0bf69845d1db49f2817f50a23d64a9e836a961.jpg"></p><p>回头看一下，<code>java</code>在获取<code>Data</code>偏移的处理，在读取<code>Extra data</code>的长度的时候，它已经预存了文件名在<code>FileHeader</code>中的长度。</p><pre><code>// We don't know the entry data's start position. 
// All we have is the position of the entry's local 
// header. At position 28 we find the length of the 
// extra data. In some cases this length differs 
// from the one coming in the central header. 

RAFStream rafstrm = new RAFStream(raf, 
         entry.mLocalHeaderRelOffset + 28); 
DataInputStream is = new DataInputStream(rafstrm); 
int localExtraLenOrWhatever = 
</code></pre><p>漏洞就在这里产生了，如果<code>Local Header</code>中的<code>FileNameLength</code>被设成一个大数，并且<code>FileName</code>的数据包含原来的数据，<code>File Header</code>中的<code>FileNameLength</code>长度不变，那么底层<code>C++</code>运行和上层<code>Java</code>运行就是不一样的流程。</p><pre><code>C++ Header 64k Name Data 
+--------&gt; +----------------------&gt; +----------&gt; 
length=64k classes.dex dex\035\A... dex\035\B... 
+--------&gt; +---------&gt; +----------&gt; 
</code></pre><p>如上面所示，底层<code>C++</code>的执行会读取64k的<code>FileName</code>长度，而<code>Java</code>层由于是读取<code>File Header</code>中的数据，<code>FileName</code>的长度依旧是11，于是<code>Java</code>层校验签名通过，底层执行会执行恶意代码。</p><p></p></section></article><div class="entry-controls clearfix"><div style="float:left;color:#9d9e9f;font-size:15px"><span>&copy;乌云知识库版权所有 未经许可 禁止转载</span></div></div><div id="comments" class="comment-list clearfix"><div id="comment-list"><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">LBL</span> <span class="reply-time">2015-11-30 14:24:03</span></div><p></p><p>@Lee 0101是什么工具？</p><p></p></div></div><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">MillionSky</span> <span class="reply-time">2015-11-26 13:31:23</span></div><p></p><p>Very Good, 如果Android Master Key漏洞附上使用例子和工具就更好了。限制就是原dex不能大于64KB，基本无法实用。</p><p></p></div></div><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">_Evil</span> <span class="reply-time">2015-10-23 14:35:46</span></div><p></p><p>@三好学生 顶你</p><p></p></div></div><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">Lee</span> <span class="reply-time">2015-10-23 09:32:14</span></div><p></p><p>知道了， 你用的是0101</p><p></p></div></div><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">Lee</span> <span class="reply-time">2015-10-23 09:28:55</span></div><p></p><p>用的是什么工具查看的？</p><p></p></div></div><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">Doric-2015</span> <span class="weibo"></span> <span class="reply-time">2015-10-22 12:16:56</span></div><p></p><p>赞！</p><p></p></div></div><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">三好学生</span> <span class="reply-time">2015-10-22 11:08:13</span></div><p></p><p>WinRar File extension spoofing zip文件扩展名漏洞至少支持4.20/4.11,经测试不支持4.01/4.00/3.90/3.60,所以小伙伴们还是不要使用上述版本的winrar了。</p><p></p></div></div></div></div></div></main>