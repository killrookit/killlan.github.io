<main class="main-container ng-scope" ng-view=""><div class="main receptacle post-view ng-scope"><article class="entry ng-scope" ng-controller="EntryCtrl" ui-lightbox=""><header><h1 class="entry-title ng-binding">移花接木大法：新型“白利用”华晨远控木马分析</h1><div class="entry-meta"><a target="_blank" class="author name ng-binding">360安全卫士</a> <span class="bull">·</span> <time title="2015/05/28 5:11" ui-time="" datetime="2015/05/28 5:11" class="published ng-binding ng-isolate-scope">2015/05/28 5:11</time></div></header><section class="entry-content ng-binding" ng-bind-html="postContentTrustedHtml"><p></p><h1>0x00 前言</h1><hr><p>“白利用”是木马对抗主动防御类软件的一种常用手法。国内较早一批“白利用”木马是通过系统文件rundll32.exe启动一个木马dll文件，之后又发展出劫持合法软件的dll组件来加载木马dll的攻击方式。</p><p>随着安全软件对“白利用”的防御机制日益完善，木马也在花样翻新。近期，360QVM引擎团队发现“华晨同步专家”远控木马家族采用了比较另类的“白利用”技术：该木马利用白文件加载dll文件后，再次启动白文件并卸载白进程内存空间，然后重新填充病毒代码执行。</p><p>这种“移花接木”的手法，使得病毒代码均通过白进程主模块执行，能够绕过多数安全软件的主动防御规则，具有较强的存活能力。以下是对此木马详细的技术分析：</p><h1>0x01 木马分析</h1><hr><p>该木马伪装成“美女图片”通过社交软件、电子邮件等方式传播，一旦中招，电脑将被黑客发送指令执行摄像头监控、屏幕监控等远程控制行为。目前已知该木马主要变种达到22个。</p><p><img alt="enter image description here" img-src="1734521fd2eef1b21d63fa895deed9fee5ed673a.jpg"></p><p>图：“华晨同步专家”远控木马及变种</p><p><img alt="enter image description here" img-src="01c5c15883b9f88a77fab6ff863083d5ffae953b.jpg"></p><p>图：木马执行过程</p><p>“华晨同步专家”木马文件：</p><p><img alt="enter image description here" img-src="99034a42ed83f44d04d47913c68f59cee71256d5.jpg"></p><p><img alt="enter image description here" img-src="8a1faef703c51b9aa903e09bce941cc566d8f16e.jpg"></p><p>美女图片.exe：运行后会释放update.exe、ETComm.dll、wc.dat这三个文件，并运行update.exe。这种“三合一”的打包方式相比压缩包更利于木马传播。</p><ol><li>update.exe：盛大网络的ET语音启动程序</li><li>ETComm.dll：用于劫持盛大程序的木马dll文件</li><li>wc.dat：zlib压缩加密的远程控制木马</li></ol><p>我们首先从ETComm.dll入手分析：</p><p><strong><em>ETComm.dll分析过程</em></strong></p><p>DllMain中首先获取模块完整路径</p><p><img alt="enter image description here" img-src="e44ad034964a3d26015060135a55ee10656f643b.jpg"></p><p>比较自身完整路径是否为<code>C:\$WinBackUP.H1502\BinBackup\Images\update.exe</code> 如果不在<code>C:\$WinBackUP.H1502\BinBackup\Images</code>目录下则将<code>ETComm.dll</code>、<code>wc.dat</code>、<code>update.exe</code>拷贝过去，接下来直接进入<code>100016A0</code></p><p><img alt="enter image description here" img-src="d3a8a2da419b14b74ba2c6e7c32bb5f1b9218f97.jpg"></p><p>100016A0进来以后首先访问C:\$WinBackUP.H1502\BinBackup\Images\wc.dat</p><p><img alt="enter image description here" img-src="7c3022d9c6d2efe623a60efb06283816f1ddaca8.jpg"></p><p>申请一段内存后将wc.dat的内容读进去</p><p><img alt="enter image description here" img-src="dd2f0617e88dda0ade35405f6c2f311f261f579e.jpg"></p><p>将读出来的文件内容的前四位与0x36异或，得出0x14E00</p><p><img alt="enter image description here" img-src="b70738014bb35ee7b811ab6b64003f15380cd635.jpg"></p><p>将解密出来的0x14e00给到一个变量</p><p>紧接着就申请出来一块0x14E00大小的内存</p><p>之后将这些数据作为参数传递到Zlib的解压函数中</p><p><img alt="enter image description here" img-src="4dd9321b288ed23823e95f097b825bc5c1cf8962.jpg"></p><p>解出来的数据如下</p><p><img alt="enter image description here" img-src="481ef3feed7533cf25365622b7668b30019d0f13.jpg"></p><p>由此我们可以得出wc.dat的结构，第一个DWORD存放的是UnpackFileSize，之后的数据存放的是压缩后的文件数据，此时是最好的dump时机。</p><p>Dump出来的文件：</p><p><img alt="enter image description here" img-src="6850d53eaf0180c91bf5615fcace772c822f01cb.jpg"></p><p><strong><em>接下来是为内存运行exe做准备了</em></strong></p><p>alignPEToMem函数主要作用为加载PE到内存，该函数主要内容为对其exe节数据进行初始化操作。AttachPE主要作用为创建外壳进程（盛大网络ET语音启动程序），并替换进程数据然后执行真正的病毒代码</p><p><img alt="enter image description here" img-src="9b9e2ded4b230fc2e38f6e071dd35bbac87baba5.jpg"></p><p>我们重点来看下AttachPE函数的行为：</p><p>首先挂起模式再次运行<code>C:\$WinBackUP.H1502\BinBackup\Images\update.exe</code></p><p><img alt="enter image description here" img-src="737c8362b165b75f25332ca489dbd42f5a9b827d.jpg"></p><p>调用GetThreadContext获取信息目标进程的线程句柄</p><p><img alt="enter image description here" img-src="52eff979a830784adc8cf80365da6665a7a4b8b4.jpg"></p><p>得到的信息存放在结构体<code>lpContext</code>中，接着读取了目标进程的<code>lpContext</code>结构体中<code>Ebx+8</code>的数据。</p><p><code>[lpContext.Ebx+8]</code>处存的是外壳进程的加载基址，该目标进程的基址为<code>0x00400000</code></p><p><img alt="enter image description here" img-src="795d548bf08547834fa2a4b7ae0c8230e9f5e5c9.jpg"></p><p>动态获取<code>ntdll</code>的<code>ZwUnmapViewOfSection</code>并调用，卸载目标进程原外壳内存数据</p><p><img alt="enter image description here" img-src="860df1a2d230374768b85958133ef16e8a8a1c75.jpg"></p><p>重新在目标傀儡进程中申请傀儡代码用到的内存，<code>0x00400000</code>大小为<code>2C000</code></p><p><img alt="enter image description here" img-src="9ff28ee3b6f1795f922a80272c1d2074c44d7494.jpg"></p><p><img alt="enter image description here" img-src="c9220ef953ab9146709561f12e12ad7ba4eb816a.jpg"></p><p>内存申请成功后在傀儡进程的<code>Context.ebx+8</code>中写入新的基址（因为两个文件基址都为<code>0x400000</code>，所以这一步并没有什么用，但是如果对于两个基址不一样的文件这一步就非常必要了）</p><p><img alt="enter image description here" img-src="a5f3484c60f54db61d4b38cb25bc47eaef6ae9e5.jpg"></p><p>然后在新申请的内存中写入已经展开了所有节数据的病毒代码，大小为0x2C000</p><p><img alt="enter image description here" img-src="85556182b3753c044fb1f2355aeb88fba8997b0e.jpg"></p><p>重置运行环境中的入口地址，新的OEP为基址+0x0002A820</p><p><img alt="enter image description here" img-src="0537546f294f2e12066e4a650d289329f2f43837.jpg"></p><p>更新傀儡进程运行环境后恢复傀儡进程运行</p><p><img alt="enter image description here" img-src="f6c6ac7c705a53be624910f7ec57fd96c8b6b536.jpg"></p><p>至此ETComm.dll的任务已经完成，直接退出了进程</p><p><img alt="enter image description here" img-src="6e3493ca933b748db49bbb95ccde716fb662429b.jpg"></p><p><strong><em>接下来我们来分析被偷梁换柱的update.exe进程</em></strong></p><p>从入口点我们可以看出是UPX加壳</p><p><img alt="enter image description here" img-src="445da85adf2eb3426f03b25d55ee076fcad16520.jpg"></p><p>直接ESP定律到程序OEP，入口点代码可以看出是VC6.0所编译</p><p><img alt="enter image description here" img-src="03099ef825e390bea05b694e64f2d2d50e6d7e6f.jpg"></p><p>来到Main函数我们可以看到先是调用了一些sleep(0)</p><p><img alt="enter image description here" img-src="fe201897289032e520b79f88a0648cbaae8b59ee.jpg"></p><p>后面有一些字符串单字节赋值，我们可以看出他拼出来的字符串是Kernel32.dll和GetMoudleFileNameA，分别给到了变量LibFileName和ProcName</p><p><img alt="enter image description here" img-src="c6ec01adb1296b97478f80f6db9c2eb0beb5a960.jpg"></p><p>动态获取GetMoudleFileNameA</p><p><img alt="enter image description here" img-src="2f965a8e7f3644577cc8d5745677e114f9b03efe.jpg"></p><p>通过GetMoudleFileNameA获取到文件所在路径后，将该路径写入注册表作为启动项，启动项名称为“Realtek高清晰音频管理器”</p><p><img alt="enter image description here" img-src="2af525f3917253a685fd8449eddce87166fd9424.jpg"></p><p><img alt="enter image description here" img-src="8ed759965b571b4c98b3054b556816b4ec28b564.jpg"></p><p>获取资源中的名为“dll”的资源</p><p><img alt="enter image description here" img-src="bf25d8c44616056452c4e0f4c11495e988df7555.jpg"></p><p><img alt="enter image description here" img-src="df039bb3be593c87c624b3af82d80009bff9dc35.jpg"></p><p>解密算法为</p><pre><code>xor 0xF1
add 0xF1
</code></pre><p>中间有很多sleep(0)做干扰</p><p><img alt="enter image description here" img-src="4b135b2bc79e9b5153873213a87b5c3520f84bea.jpg"></p><p>解出来的文件</p><p><img alt="enter image description here" img-src="981f560c82c347a9d52dad644fadc0e7494de1fc.jpg"></p><p>Dump出来是dll简单观察发现是华晨远控（Gh0st修改）</p><p><img alt="enter image description here" img-src="f8387ed451629c0af2f49bb44c238f9bf11bffdd.jpg"></p><p>继续往下就是内存加载dll。抛弃系统的LoadLibrary和GetProcAddress来自己实现则会使dll不用落地，其目的是躲避安全软件的云查杀。</p><p>LoadLibrary的实现过程如下：</p><p>申请内存，写入PE头数据</p><p><img alt="enter image description here" img-src="11cff9ba4ea442539a0a6b3c91a255d598eb4891.jpg"></p><p>循环拷贝各个节数据</p><p><img alt="enter image description here" img-src="14193c3f48959e7d192e64c62f1933799ee13a5e.jpg"></p><p>处理重定位</p><p><img alt="enter image description here" img-src="6d2099ffce0f4b6aa00416c5f1f01b975ed9b89a.jpg"></p><p>读取dll的引入表部分，加载引入表部分需要的，并填充需要的函数入口的真实地址</p><p><img alt="enter image description here" img-src="e060a51bb7c7ddc53535911f09cc6a2c824becf4.jpg"></p><p>dll</p><p><img alt="enter image description here" img-src="22089fe18bb43464d0d353df431fd4acd7c15f48.jpg"></p><p>修改各个节内存属性，单独设置其对应内存页的属性</p><p><img alt="enter image description here" img-src="f3cb287447973c23fa0c1146f4b739f73619caf1.jpg"></p><p><img alt="enter image description here" img-src="2057851ab38eac557825bd561aac23bd06121213.jpg"></p><p>执行DllMain函数</p><p><img alt="enter image description here" img-src="63eb340a7b9df7517b1773b37247dc7cef9780b8.jpg"></p><p><img alt="enter image description here" img-src="b087d2d17a5b2f9832550657b98ab6eff062f69b.jpg"></p><p>GetProcAddress实现过程：</p><p><img alt="enter image description here" img-src="033dbed3239303da502fea3618782e22bbd9b7db.jpg"></p><p>调用自写GetProcAddress获取“Fi”导出函数并调用</p><p><img alt="enter image description here" img-src="b41ad36287ddd38599310b5cd90db802dfa8e6c8.jpg"></p><p>Fi函数负责将整个远控执行起来了。</p><p>以下是远控基本信息：</p><pre><code>远控上线地址：dddd.ndiii.com
端口：2012
分组名称：Default
远控官网：http://www.jinjingltsh.com/
</code></pre><p>“华晨同步专家”官网号称“拥有国家政府机关认证，与众多安全厂商均有合作”，实际上完全是其捏造的。</p><p><img alt="enter image description here" img-src="be587fa6d70baf61b80d646c51c73b94c9b0c4b4.jpg"></p><p><img alt="enter image description here" img-src="72fb3edb129a4b28a786c5388d3af54d0b41d388.jpg"></p><h1>0x02 总结</h1><hr><p>通过以上分析我们看出，“华晨同步专家”远控木马的新颖之处，在于利用白进程内存运行exe，内存运行dll，真正的病毒文件并不落地，仅存活在内存当中，具有较强的免杀能力。</p><p>根据VirusTotal对此木马较新变种样本的扫描结果，57款杀毒软件中有17款可以将其检出，检出率约为30%：</p><p><img alt="enter image description here" img-src="55dbb0a8f874b8a0662150e115a2a5cd0de4ae36.jpg"></p><p></p></section></article><div class="entry-controls clearfix"><div style="float:left;color:#9d9e9f;font-size:15px"><span>&copy;乌云知识库版权所有 未经许可 禁止转载</span></div></div><div id="comments" class="comment-list clearfix"><div id="comment-list"></div></div></div></main>