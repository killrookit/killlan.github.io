<main class="main-container ng-scope" ng-view=""><div class="main receptacle post-view ng-scope"><article class="entry ng-scope" ng-controller="EntryCtrl" ui-lightbox=""><header><h1 class="entry-title ng-binding">MS15-034/CVE-2015-1635 HTTP.SYS 漏洞分析</h1><div class="entry-meta"><a target="_blank" class="author name ng-binding">360安全卫士</a> <span class="bull">·</span> <time title="2015/04/16 10:10" ui-time="" datetime="2015/04/16 10:10" class="published ng-binding ng-isolate-scope">2015/04/16 10:10</time></div></header><section class="entry-content ng-binding" ng-bind-html="postContentTrustedHtml"><p></p><h1>前言</h1><hr><p>在4月的补丁日，微软通过标记为“高危”的MS15-034补丁，修复了HTTP.SYS中一处远程代码漏洞CVE-2015-1635。据微软公告（<a href="https://technet.microsoft.com/en-us/library/security/MS15-034">https://technet.microsoft.com/en-us/library/security/MS15-034</a>）所称，当存在该漏洞的HTTP服务器接收到精心构造的HTTP请求时，可能触发远程代码在目标系统以系统权限执行。</p><p>这是对于服务器系统影响不小的安全漏洞，任何安装了微软IIS 6.0以上的Windows Server 2008 R2/Server 2012/Server 2012 R2以及Windows 7/8/8.1操作系统都受到这个漏洞的影响。</p><p>从微软的公告致谢来看，这个漏洞是由“Citrix Security Response Team”（美国思杰公司的安全响应团队）发现，从网上公开的信息来看，Citrix公司是一家从事云计算虚拟化、虚拟桌面和远程接入技术领域的高科技企业。这也引发了Twitter上很多关于该漏洞是否是由针对Citrix公司的APT攻击中发现的疑问，而就在微软发布补丁的不到12个小时内，便有匿名用户在Pastebin网站上贴出了针对这个漏洞可用的概念验证攻击代码，似乎也印证了这一点。</p><p>笔者和360Vulcan的小伙伴们获得该信息后，就开始针对其进行深入的分析，并在12小时内初步分析清楚了漏洞的原理和利用相关信息，下面就将我们分析的一些结果分享给大家，以便更好地促进安全社区理解和防御这一高危安全漏洞。</p><h1>漏洞重现</h1><hr><p>结合Pastebin网站上贴出的信息（<a href="http://pastebin.com/ypURDPc4">http://pastebin.com/ypURDPc4</a>）和微软公告，我们知道这是一个位于HTTP.SYS中的整数溢出漏洞，根据Pastebin网站的python代码，我们知道通过给IIS服务器发送这样格式的HTTP请求，就可以触发（检测）这个漏洞：</p><pre><code>GET / HTTP/1.1
Host: stuff
Range: bytes=0-18446744073709551615
</code></pre><p>我们直接使用wget或curl工具，也可以直接测试这个漏洞，例如使用如下命令行：</p><pre><code>#!bash
wget 127.0.0.1 –debug –header="Range: bytes=0-18446744073709551615"
</code></pre><p>此处18446744073709551615转为十六进制即是 0xFFFFFFFFFFFFFFFF(16个F），是64位无符号整形所能表达的最大整数，那么我们很容易可以想到，这个“整数溢出”必然同这个异常的超大整数有关。</p><p>Pastebin上POC的作者提供的检测工具代码认为，如上请求包，若IIS服务器返回“Requested Range Not Satisfiable”，则是存在漏洞，否则如果返回”The request has an invalid header name“，则说明漏洞已经修补。</p><p>在实测中可能很多人也会发现并非如此，针对不同的服务器，这个测试程序很可能导致服务器直接BSOD甚至直接引发VM进程Crash(对于虚拟主机），这是为什么呢？这究竟是发生在何处的什么原因的整数一处呢？在下面的小节中我们将会进一步讲到。</p><h1>漏洞原理分析</h1><hr><p>HTTP.SYS是微软从IIS6.0开始，为了在Windows平台上优化IIS服务器性能而引入的一个内核模式驱动程序。它为IIS及其他需要运用HTTP协议的微软服务器功能提供HTTP请求的接收与响应、快速缓存、提高性能、日志等功能服务。</p><p>更多关于HTTP.SYS的信息，可以参考微软Technet Library中”IIS 6.0 Architecture”中的“HTTP Protocol Stack”一章（<a href="https://technet.microsoft.com/en-us/library/cc739400%28v=ws.10%29.aspx">https://technet.microsoft.com/en-us/library/cc739400(v=ws.10).aspx</a>)。 HTTP.SYS提供了两个最重要的功能是Kernel-mode caching 和Kernel mode request queuing，而本次的安全漏洞就出在Kernel mode caching（内核模式缓存）中。</p><p>这里笔者以Windows 8.1 X86平台上安装的IIS 8.5为例进行分析讲解，这里我们分析的存在漏洞的HTTP.SYS版本号为6.3.9600.16520，修补后的http.sys版本为6.3.9600.17712</p><p>Pastebin上POC代码的匿名作者提到，补丁修补了http!UlpParseRange函数，通过RtlUlonglongAdd函数实现了修补/拦截。</p><p>从测试代码和函数名上，我们都可以看出这个漏洞同HTTP头中的”Range“域有直接的关系， Range请求是HTTP协议中HTTP客户端用于只获取服务器上文件的某一部分数据的请求域，更多关于Range请求的细节和规范，可以参考RFC 7233 “Hypertext Transfer Protocol (HTTP/1.1): Range Requests”(<a href="http://www.rfc-editor.org/rfc/rfc7233.txt">http://www.rfc-editor.org/rfc/rfc7233.txt</a>)。</p><p>这里先简单介绍一下http.sys缓存工作的原理，IIS进程w3wp.exe接收到HTTP请求后，将数据缓存到内核中，并整合HTTP回应头，最后由http.sys组织数据包经由网络内核组件发送出去。请求中包括Ranges对象的指定范围，而缓存中则包含了http文件和大小信息等。</p><p>我们接下来先来看看这个UlpParseRange函数，看他是否是这个漏洞的根本原因。</p><p>UlpParseRange的整个代码比较长，这里就不全部贴出了，函数的逻辑很简单，就是从<code>Range bytes=lower-upper</code>（也可以是lower-或-upper形式）中，解析出lower（即读取范围的开始offset）和upper（即读取范围的结束offset)），然后计算要读取的长度，在正常的情况下，upper大于lower，因此长度=upper-lower +1</p><p>这里如果是测试代码中的例子，<code>lower=0 ，upper=0xFFFFFFFFFFFFFFFF</code></p><p>我们看看未修补前的代码是怎么样写的</p><pre><code>#!bash
PAGE:0009AD2C                 sub     eax, edx
PAGE:0009AD2E                 sbb     ecx, edi
PAGE:0009AD30                 add     eax, 1
PAGE:0009AD33                 mov     [esi], eax
PAGE:0009AD35                 adc     ecx, ebx
PAGE:0009AD37                 mov     [esi+4], ecx
</code></pre><p>通过汇编代码我们可知，这里是将upper先减去lower，再加1，得到两者之间的长度差距（例如 bytes=20-50, 则50-20+1 , 两者之间有31个字节）</p><p>按照例子里的写法，就是<code>0xFFFFFFFFFFFFFFFF – 0 + 1</code> ， 确实发生了整数溢出，64位无符号整数上溢为0。</p><p>我们来看修改后的版本：</p><pre><code>#!bash
PAGE:0009B501                 push    ebx
PAGE:0009B502                 sub     eax, edx
PAGE:0009B504                 push    1
PAGE:0009B506                 sbb     ecx, edi
PAGE:0009B508                 push    ecx
PAGE:0009B509                 push    eax
PAGE:0009B50A                 mov     ecx, esi
PAGE:0009B50C                 call    <a class="__cf_email__" href="/cdn-cgi/l/email-protection" data-cfemail="653a37110930290a0b02290a0b02240101255755">[email&#160;protected]</a>
</code></pre><p>这里的代码是将upper 先减去 lower，然后再用RtlUlonglongAdd 将结果同1相加，这里RtlUlonglongAdd会做安全性检查，如果相加结果溢出，则会返回STATUS&#95;INTEGER&#95;OVERFLOW.</p><p>由于测试代码中lower传入的是0，所以这里也发生了溢出并被捕获、阻止，但如果lower != 0，这里压根就不会捕获到整数溢出，这是怎么回事呢？真正出现问题的地方是这里吗？</p><p>实际上，这可能是POC编写者故意隐藏了一点关键细节： UlpParseRange通过操纵Range参数可以引发整数溢出，也确实被进行了修补，但是并非这个Range数据真正出现问题的地方。</p><p>我们进一步推测和分析，发现本次漏洞真正利用的地方，而是UlAdjustRangesToContentSize，这个函数用于最终修正Ranges中指定的StartingOffset和Length的合法性。</p><p>首先UrlpParseRange解析了Range参数并获得StartingOffset和Length后，会将其保存在http请求的对象中，而在解析到对应的缓存后，对比Offset + Length的大小，是否超过要请求的缓存文件数据长度，如果超出了，就要把length裁剪为适合的长度，防止读取超出的数据，见如下代码：</p><pre><code>#!bash
PAGE:0007FD09                 mov     eax, [ebp+length_low]    
PAGE:0007FD0C                 add     eax, dword ptr [ebp+offset_low]
PAGE:0007FD0F                 mov     dword ptr [ebp+offset_low], eax
PAGE:0007FD12                 mov     eax, [ebp+length_high]
PAGE:0007FD15                 adc     eax, dword ptr [ebp+offset_high]  ;将Length + Offset
PAGE:0007FD18                 cmp     eax, esi                          ;esi = content length ，缓存的实际数据长度，进行对比
PAGE:0007FD1A                 jb      short loc_7FD30
PAGE:0007FD1C                 ja      short loc_7FD23
PAGE:0007FD1E                 cmp     dword ptr [ebp+offset_low], ecx  
PAGE:0007FD21                 jb      short loc_7FD30
PAGE:0007FD23
PAGE:0007FD23 loc_7FD23:                             
PAGE:0007FD23                                         
PAGE:0007FD23                 sub     ecx, [ebp+length_low]                ;length = contentlength-offset            
PAGE:0007FD26                 mov     eax, esi
PAGE:0007FD28                 sbb     eax, [ebp+length_high]
PAGE:0007FD2B                 mov     [edx+4], eax
</code></pre><p>这里我们看到是一处可利用的整数溢出，<code>Length + offset</code> 如果发生溢出，就会小于contentsize，这里就会跳过这个”adjust”的过程，Length没有得到任何处理和修正，我们成功控制了Length。</p><p>以例子中的数值为例， <code>length + offset = (0xFFFFFFFFFFFFFFFF + 1 ) + 0 (这个+ 1是前面UlpParseRange添加的） = 0</code> ，小于contentsize</p><p>而假设lower不为0，则结果 = lower ,只要结果小于contentsize，也是不会被adjust的。</p><p>也就是说，UlpParseRange处发生了整数溢出，而在此处导致了安全检查的绕过，同时，如果lower != 0 ，UlpParseRange时不会被触发整数溢出，而是应该在这里得以触发。</p><p>到这里我们就弄清楚了这个漏洞的触发流程和原理：</p><p>1.<code>upper(range结束的offset) = 0xFFFFFFFFFFFFFFFF</code>时，UlpParseRange或UlAdjustRangesToContentSize会触发整数溢出,导致绕过UlAdjustRangesToContentSize的Length检查</p><p>2.Length 可控，但是<code>Length = 0xFFFFFFFFFFFFFFFF – lower（range开始的offset）</code> ， 且lower必须要小于要获取目标文件的数据长度contentlength。</p><h1>BSOD的重现和原理</h1><hr><p>看到很多测试攻击程序的研究人员都无法稳定重现BSOD，看Github上的讨论，通过调整lower的数值，有些人可以打蓝Server 2012 R2，有些人就不行，或者换个文件就不行。</p><p>实际上，我们分析了这个漏洞的原理就可以很清楚的了解其中的规律了，首先一条原则是上面已经说到的lower不能大于请求的content length，例如假设请求iisstart.htm(648Bytes），lower就必须小于647。</p><p>同时，HTTP请求的处理实际是先通过w3wp发起的进程上下文内http先解析HTTP请求包，组合成紧凑的http回应包后，通过</p><pre><code>UlSendData-&gt;UxTpTransmitPacket-&gt;UxpTpEnqueueTransmitPacket
</code></pre><p>排入队列，然后再由UlSendCacheEntryWorker将其发送出去，在这个过程中，如果range指定的数据开始offset小于紧凑的数据包头部的总长度，那么就不会触发到后面继续命中缓存的处理。（range只允许对数据文件内存指定，不能指定响应头内的）</p><p>这里我使用wget添加头部的方式测试，回应包的长度应该是(针对Windows 8.1 X86)310个字节，也就是说，lower必须大于等于310个字节，其他的发送还需要调整这个数值。</p><p>所以，针对iisstart.htm , lower >= 310 且 &lt; 647 就可以稳定触发BSOD了</p><h1>进一步利用</h1><hr><p>这个漏洞难道只能BSOD吗？说好的远程代码执行呢？再深入看下漏洞触发的细节，看上去似乎不能远程代码执行，但是远程读取服务器内核内存数据是有可能的。</p><p>在<code>UlpSendCacheEntry-&gt;UlBuildFastRangeCacheMdlChain</code>中，http.sys会为HTTP回应头和缓存来源buffer/length（我们可控）创建MDL，那么，对于我们的超长length，就会创造一个巨大的mdl，接着放入UxTpTransmitPacket的数据包对象中，通过tcpip->netio，最后解析MDL，将数据最终发出去。</p><p>此时是可以超过缓存的空间，读取缓存内存往后的数据，如果缓存内存后面是连续的<code>0xffffffffffffffff – lower(4GB?)</code>左右内核内存（通常是X64)，就有可能实现信息泄露。</p><p>不过首先是很难有连续的4G内存，同时通过IIS也很难一下获得如此多的数据，那么只能设法降低这个内存要求：<code>length = 0xFFFFFFFFFFFFFFFF – lower</code> ，且lower &lt; contetnlength才行，我们可以想办法提高content length，达到降低Length的目的，例如在服务器上寻找一个接近4GB大小的文件：）</p><p>分析时间仓促，有任何进一步的利用和错误之处，欢迎讨论指正。</p><p></p></section></article><div class="entry-controls clearfix"><div style="float:left;color:#9d9e9f;font-size:15px"><span>&copy;乌云知识库版权所有 未经许可 禁止转载</span></div></div><div class="yarpp-related"><h3>为您推荐了适合您的技术文章:</h3><ol id="recommandsystem"><li><a href="http://drops.wooyun.org/papers/5731" rel="bookmark" id="re1">MS15-035 EMF文件处理漏洞分析与POC构造</a></li><li><a href="http://drops.wooyun.org/binary/7428" rel="bookmark" id="re2">逆向基础 OS-specific (一)</a></li><li><a href="http://drops.wooyun.org/papers/7031" rel="bookmark" id="re3">Hacking Team 新 Flash 0day分析</a></li><li><a href="http://drops.wooyun.org/papers/4621" rel="bookmark" id="re4">MS15-002 telnet服务缓冲区溢出漏洞分析与POC构造</a></li></ol></div><div id="comments" class="comment-list clearfix"><div id="comment-list"><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">炮灰乙</span> <span class="reply-time">2015-04-20 20:22:14</span></div><p></p><p>我的iis返回The request has an invalid header name.了，求问怎样卸载补丁复现</p><p></p></div></div><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">点点</span> <span class="reply-time">2015-04-17 15:30:15</span></div><p></p><p>这b装的 可以。。。。。</p><p></p></div></div><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">winsyk</span> <span class="reply-time">2015-04-17 08:30:05</span></div><p></p><p>unicode编码。</p><p></p></div></div><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">纳米翡翠</span> <span class="reply-time">2015-04-16 14:32:17</span></div><p></p><p>哪位大神知道这是什么编码：<br>%94%D8%B7%BD%94%EC%D6%BC%BF%F5%BF%F5%94%D8%B7%BD%94%EC%95%46%CA%B1%95%42%94%FD%D6%BC%95%46%94%D8%B7%BD%94%EC%BA%B5%95%42%BF%F5%95%45%95%47%95%43%94%D8%B7%BD%94%EC%95%47%BF%F5%95%41%CA%B1%D6%BC%94%FE%94%D8%B7%BD%94%EC%B7%BD%94%E0%94%E1%EC%B6%94%DD%94%E0%94%E3%94%DD%94%E1%EC%B6%94%D8%B7%BD%94%EC%D6%BC%D4%E7%94%FD%94%DE%BA%B5%CD%FA%BF%F5%94%D8%94%E0%94%E0</p><p></p></div></div><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">冷冷的夜</span> <span class="reply-time">2015-04-16 11:22:01</span></div><p></p><p>不对啊，这个最多是读取内存数据，代码执行在哪呢。。。。。。。。。。。。。。。。。</p><p></p></div></div><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">MITM</span> <span class="reply-time">2015-04-16 10:49:25</span></div><p></p><p>好吧，成功了。用的下限是500.</p><p></p></div></div><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">L.N.</span> <span class="reply-time">2015-04-16 10:46:17</span></div><p></p><p>详细，小菜我竟然都有点看懂了！</p><p></p></div></div><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">MITM</span> <span class="reply-time">2015-04-16 10:42:40</span></div><p></p><p>“针对iisstart.htm , lower &gt;= 310 且 &lt; 647 就可以稳定触发BSOD了”。我怎么触发不了BSOD（Windows 8.1 x64）？</p><p></p></div></div></div></div></div></main>