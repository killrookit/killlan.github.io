<main class="main-container ng-scope" ng-view=""><div class="main receptacle post-view ng-scope"><article class="entry ng-scope" ng-controller="EntryCtrl" ui-lightbox=""><header><h1 class="entry-title ng-binding">变种XSS：持久控制</h1><div class="entry-meta"><a target="_blank" class="author name ng-binding">tig3r</a> <span class="bull">·</span> <time title="2015/11/30 10:42" ui-time="" datetime="2015/11/30 10:42" class="published ng-binding ng-isolate-scope">2015/11/30 10:42</time></div></header><section class="entry-content ng-binding" ng-bind-html="postContentTrustedHtml"><p></p><h1>0x00 引言</h1><hr><p>首先声明，这不是一个新洞，看过 Homakov 文章（最后附）以及译文的人想必对这种漏洞有所了解。</p><p>但原文写的太过简单（没有说明利用条件、情景和特性），且译文和我的理解略有偏差，于是就有了这篇文章。</p><p>这种漏洞已经存在一段时间了，有没有被利用过尚不得知，虽然利用条件较苛刻，但是当符合条件的站点被攻击后， 影响面和影响程度巨大，并且普通用户不知如何清除, 可导致长期持续攻击。</p><p>2014年底的时候，这种漏洞的利用条件没有现在苛刻（比如没有<code>Service-Worker-Allowed</code>头），一年过来 W3C 对规范优化了不少（包括安全方面）， 相信不久的将来，很快会被标准更新所扼杀了。</p><p>弥留之际，让这个漏洞放点异彩吧。</p><h1>0x01 一切都从 serviceWorker 说起</h1><hr><blockquote><p>Service Worker是基于Web Worker的事件驱动的，他们执行的机制都是新开一个线程去处理一些额外的，以前不能直接处理的任务。对于Web Worker，我们可以使用它来进行复杂的计算，因为它并不阻塞浏览器主线程的渲染。而Service Worker，我们可以用它来进行本地缓存，相当于一个本地的proxy。说起缓存，我们会想起我们常用的一些缓存技术来缓存我们的静态资源，但是老的方式是不支持调试的，灵活性不高。使用Service Worker来进行缓存，我们可以用javascript代码来拦截浏览器的http请求，并设置缓存的文件，直接返回，不经过web服务器，然后，做更多你想做的事情。</p></blockquote><ul><li>我们可以用 javascript 代码来拦截浏览器的 http 请求，并设置缓存的文件，直接返回</li></ul><p>相信很多人看到这句已经明白了，通过 js 来代理浏览器 http 请求，也就是说通过执行 js 代码来控制浏览器的请求， 很容易想到，利用 xss 来修改浏览器请求的返回内容。</p><p>可怕的是，即便 xss 漏洞被修复了，攻击仍然持续，并且渗透到攻击范围内的每一个 url。</p><p>并且，当用户察觉到攻击，并且理解这种攻击，进入chrome后台（chrome://appcache-internals）， 进行手动清除攻击缓存，攻击仍未失效！当然了，还是有办法清除的，且无须用户手工操作（下文会演示）。</p><h1>0x02 漏洞原理和演示</h1><hr><p><code>serviceWorker</code> 的官方标准文档：<a href="http://www.w3.org/TR/service-workers/">http://www.w3.org/TR/service-workers/</a></p><p>其操作可以参考：<a href="https://github.com/w3c-webmob/ServiceWorkersDemos">https://github.com/w3c-webmob/ServiceWorkersDemos</a></p><p>首先 serviceWorker 只有在 https 页面中才可以调用 regist。</p><p>而 serviceWorker 需要 Promise 支撑，目前支持的浏览器如下：</p><p><img alt="" img-src="a5fed1d79fc2db5b95fcb0943bcd3166e6f24b0a.jpg"></p><p>支持 serviceWorker 的浏览器：</p><p><img alt="" img-src="bd3c7a28fbb3a09dd13553c2780d858944c5f32e.jpg"></p><p>firefox 默认关闭 serviceWorker，可以通过 about:config 打开开关：</p><p><img alt="" img-src="a0afe53992d9aef77a919a1f3731d1d5e0c69e13.jpg"></p><p>支持 fetch 方法（抓包）的浏览器：</p><p><img alt="" img-src="e4bc3579d08ddcf4b443ba14dc3d2db829eaf3f5.jpg"></p><hr><h2>开始尝试攻击：</h2><p>首先在 https 站点中找到一个 Xss，利用 Xss 注册一个 <code>serviceWorker.registration</code> 实例：</p><pre><code>#!js
navigator.serviceWorker.register(url).then(function(registration) {
  console.log(registration);
});
</code></pre><p>注意到有个未知参数 url，这个 url 就是拿来放我们的攻击代码（假设我们能上传一个js到根目录）：</p><pre><code>#!js
var url = '//victim.com/evil.js'
</code></pre><p>有人说这太难了，往根目录上传 js 文件不可能，那么可以尝试在子目录/任何一个可能的目录上传js文件， 或者和 Homakov 一样，利用 jsonp 接口来代替这个恶意 js 文件。</p><p>serviceWorker.register 只支持请求文件返回头的MIME类型为：<code>text/javascript, application/x-javascript, application/javascript</code>。</p><p>我们知道，jsonp 的 callback 经常是可控的，那么找到一个这样可以写代码的 jsonp 难不难？</p><p>Google it !</p><p><img alt="" img-src="7d1bffd1002aa439ec3502d8eb9e759f9e23683b.jpg"></p><p>点击第一个链接：</p><p><img alt="" img-src="828070948f87e9f59fd437a8204f2bb158485833.jpg"></p><p>可以看到，以 taobao.com 为例，第一个 jsonp 接口就存在这样的弱点：callback 可以写入任意代码。</p><p>退一步说，只要能输入 []!() 等几个符号，就能构造任意代码了。</p><p>以往安全工程师修复 jsonp 接口的 xss 漏洞，都是将页面的 <code>mime</code> 修改为 <code>application/javascript</code>， 或者将 callback 的参数中的html符号实体转义，就觉得杜绝 xss 了，看来以后得换个修法了</p><p>若 callback 仅仅代表一个函数名，何不只允许数字、字母和下划线呢？</p><h2>往 “js/jsonp接口” 里写入恶意代码：</h2><pre><code>#!js
onfetch = function(e) {
  e.respondWith(new Response('任意内容',{
      headers
      ...
    });
  );
}
</code></pre><p>通过 onfetch 方法拦截 http 请求，并构造返回内容，比如返回：<code>&lt;script&gt;alert(/xss/)&lt;/script&gt;</code></p><p>所有在 evil 路径下的请求的内容都被篡改。</p><hr><p>让我们本地测试还原一遍场景（注意：本地测试不需要 https）：</p><p>首先打开网站：</p><p><img alt="" img-src="979b06aefb849b054501f6779a7bda91cdd4b479.jpg"></p><p>打开正常页面：</p><p><img alt="" img-src="28038f77e923e093d938f9a311c89fe0a8b199a9.jpg"></p><p>这时候点击被攻击页面，此页面事先被注入了 XSS 脚本：</p><p><img alt="" img-src="43fa5b79484fbd91f13a1db9bb61efd0aa357e08.jpg"></p><p>可以看到，这时候 serviceWorker 已经成功注册了</p><p>刷新页面，此时返回内容以及被修改了：</p><p><img alt="" img-src="1000b3dbb7c1c78bb856fa0fd9a1c76d557e6035.jpg"></p><p>这时候再看正常页面，也被攻击了：</p><p><img alt="" img-src="609ad2447def5ab2ac4327613424e417f0faa69f.jpg"></p><p>首页也是相同的情况：</p><p><img alt="" img-src="4667fcbcf789ca8fac45c9bf1a100ddc1132dcb4.jpg"></p><p>关闭浏览器，再打开，依旧如此：</p><p><img alt="" img-src="025694e3f17319886215fd201de6d5c143c20cbd.jpg"></p><h3>0x03 优势、局限性</h3><ul><li>优势<ul><li>生存周期久（即便浏览器重启还在）</li><li>一旦中招不易清除，包括用户和网站业务方</li></ul></li><li>局限性<ul><li>需要同域中同时存在 XSS 和弱点 JSONP（或可控js文件）</li><li>感染路径受弱点 js 路径的限制</li><li>被攻击站点必须是 https</li></ul></li></ul><p>实际利用中，若弱点JSONP路径中不存在网站业务，这个漏洞依然能发挥一定价值。</p><p>比如：杀死该JSONP路径以及其子目录的全部接口，从而导致网站无法正常使用。</p><h1>0x04 中止及防范攻击</h1><hr><h2>1. 如何中止攻击</h2><p>从上文可以知道，即便 xss 被修复了或者消失了，攻击依然生效，那么如何中止攻击呢？</p><p>作为一个普通用户，首先尝试打开 chrome://inspect/#service-workers 查看存活：</p><p><img alt="" img-src="ef67fc56c0ed943d2f4c68875aa770e4c30fd4c7.jpg"></p><p>的确可以看到被用作攻击的 Worker，点击 terminate 尝试中止：</p><p><img alt="" img-src="f609bf32658440da3bf84c75ce370cd28af91300.jpg"></p><p><img alt="" img-src="b6f78475b6542468d1d9dd281339a90934d4b143.jpg"></p><p>可以看到以及被清理了，但是打开页面，攻击仍然存在！</p><p><img alt="" img-src="cc9274a729cec062f518572b8ef07afa51fd53df.jpg"></p><p>浏览器中打开<code>F12</code>，在<code>console</code>中输入：<code>navigator.serviceWorker.</code>， 可以看到有 getRegistration 和 getRegistrations 这两种属性。</p><p>查询文档：<a href="https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerContainer/getRegistration">https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerContainer/getRegistration</a></p><p>尝试获取注册器，并且调用注销（由于用到 Promise，需要使用 then 调取结果）：</p><pre><code>#!js
navigator.serviceWorker.getRegistration()
  .then(function(registration) {
  registration.unregister();
});
</code></pre><p><img alt="" img-src="6557af9c07d62c3e4bc264c2d36008c26ed4c288.jpg"></p><p><img alt="" img-src="f487d7693aa0d68177d1e7c8f6530ffa01740bb7.jpg"></p><p>这一次终于清除了。</p><p>而对于网站方，如何清除所有攻击呢？</p><p>只要将“清除代码”部署在一个未受感染的同域的页面里，当用户访问过后，自然就清除了。</p><h2>2. 防范方法：</h2><ol><li>Jsonp 接口的 callback 可以做白名单，或者只允许特定字符（比如数字、字母和下划线）。</li><li>Jsonp所在域不应该存在 XSS（一切类型），至少不应该存在业务页面。</li><li>如果做不到2，Jsonp 所在 url 路径下不应该存在网站业务。</li><li>域名内不应存在用户可控的 js 文件。</li></ol><h3>reference:</h3><ul><li><a href="http://www.w3.org/TR/service-workers/">http://www.w3.org/TR/service-workers/</a></li><li><a href="https://github.com/w3c-webmob/ServiceWorkersDemos">https://github.com/w3c-webmob/ServiceWorkersDemos</a></li><li><a href="http://sakurity.com/blog/2015/08/13/middlekit.html">http://sakurity.com/blog/2015/08/13/middlekit.html</a></li><li><a href="https://jakearchibald.github.io/isserviceworkerready/">https://jakearchibald.github.io/isserviceworkerready/</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/API/">https://developer.mozilla.org/en-US/docs/Web/API/</a></li></ul><p></p></section></article><div class="entry-controls clearfix"><div style="float:left;color:#9d9e9f;font-size:15px"><span>&copy;乌云知识库版权所有 未经许可 禁止转载</span></div></div><div class="yarpp-related"><h3>为您推荐了适合您的技术文章:</h3><ol id="recommandsystem"><li><a href="http://drops.wooyun.org/tips/2554" rel="bookmark" id="re1">上传文件的陷阱II 纯数字字母的swf是漏洞么?</a></li><li><a href="http://drops.wooyun.org/papers/6630" rel="bookmark" id="re2">JSONP挖掘与高级利用</a></li><li><a href="http://drops.wooyun.org/tips/737" rel="bookmark" id="re3">Tomcat的8009端口AJP的利用</a></li><li><a href="http://drops.wooyun.org/tips/2031" rel="bookmark" id="re4">上传文件的陷阱</a></li></ol></div><div id="comments" class="comment-list clearfix"><div id="comment-list"><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">珈蓝夜宇</span> <span class="reply-time">2015-12-01 13:59:02</span></div><p></p><p>@0x0d 搞了半天也一个都没成功 -.-</p><p></p></div></div><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">0x0d</span> <span class="reply-time">2015-12-01 13:46:13</span></div><p></p><p>然而找了个qq的试了下并没有成功…<br>据 http://www.w3ctech.com/topic/866 中所述，&quot;有一个需要特别说明的是service worker文件的路径，你一定注意到了在这个例子中，service worker文件被放在这个域的根目录下，这意味着service worker和网站同源。换句话说，这个service work将会收到这个域下的所有fetch事件。如果我将service worker文件注册为/example/sw.js，那么，service worker只能收到/example/路径下的fetch事件（例如： /example/page1/, /example/page2/）。&quot;，所以 serviceWorker 是要同源的，条件太苛刻了……</p><p></p></div></div><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">0x0d</span> <span class="reply-time">2015-12-01 13:10:52</span></div><p></p><p>@珈蓝夜宇 jsonp 不受同源策略影响，根据文末的参考资料（http://sakurity.com/blog/2015/08/13/middlekit.html）反射型应该可以的。</p><p></p></div></div><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">珈蓝夜宇</span> <span class="reply-time">2015-12-01 11:58:43</span></div><p></p><p>@tig3r XSS是在一个三级域名下的,JSONP这个可以随便吗?</p><p></p></div></div><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">珈蓝夜宇</span> <span class="reply-time">2015-12-01 11:57:43</span></div><p></p><p>@tig3r 我有很多腾讯的反射型XSS,这样也可以吗?</p><p></p></div></div><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">隐形人真忙</span> <span class="reply-time">2015-11-30 22:50:14</span></div><p></p><p>思路真不错 XSS rootkit的一种形式</p><p></p></div></div><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">Knight</span> <span class="reply-time">2015-11-30 19:56:38</span></div><p></p><p>赞！</p><p></p></div></div><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">/fd</span> <span class="reply-time">2015-11-30 19:06:50</span></div><p></p><p>SW 會 24小時強制refresh一次</p><p></p></div></div><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">tig3r</span> <span class="reply-time">2015-11-30 14:54:55</span></div><p></p><p>@小哲哥 嗯，是的</p><p></p></div></div><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">tig3r</span> <span class="reply-time">2015-11-30 14:54:33</span></div><p></p><p>@珈蓝夜宇 首先得有一个XSS，至于JSONP很好找，我google很快就找到某几个互联网大厂www域名都存在这样可构造的JSONP接口。</p><p></p></div></div><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">小哲哥</span> <span class="reply-time">2015-11-30 11:33:51</span></div><p></p><p>是不是反射的也可以利用这种方法缓存在本地</p><p></p></div></div><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">珈蓝夜宇</span> <span class="reply-time">2015-11-30 11:10:46</span></div><p></p><p>good!请问下有实例么</p><p></p></div></div><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">EtherDream</span> <span class="reply-time">2015-11-30 11:10:44</span></div><p></p><p>javascript 也可以 daemon 进程了</p><p></p></div></div></div></div></div></main>