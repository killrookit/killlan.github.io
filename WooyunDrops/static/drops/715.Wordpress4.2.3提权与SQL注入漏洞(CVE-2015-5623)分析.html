<main class="main-container ng-scope" ng-view=""><div class="main receptacle post-view ng-scope"><article class="entry ng-scope" ng-controller="EntryCtrl" ui-lightbox=""><header><h1 class="entry-title ng-binding">Wordpress4.2.3提权与SQL注入漏洞(CVE-2015-5623)分析</h1><div class="entry-meta"><a target="_blank" class="author name ng-binding">腾讯安全中心</a> <span class="bull">·</span> <time title="2015/08/18 11:18" ui-time="" datetime="2015/08/18 11:18" class="published ng-binding ng-isolate-scope">2015/08/18 11:18</time></div></header><section class="entry-content ng-binding" ng-bind-html="postContentTrustedHtml"><p></p><p>这是这几天一直关注的漏洞了，<code>wordpress</code>上个礼拜发布的4.2.4版本，其中提到修补了可能存在的SQL漏洞和多个XSS。 <code>Check point</code>也很快发出了分析，我也来分析与复现一下最新的这个漏洞。</p><h1>0x01 GP混用造成的越权漏洞</h1><hr><p>首先，说明一下背景。<code>wordpress</code>中用户权限分为订阅者、投稿者、作者、编辑和管理员。</p><p>权限最低的是订阅者，订阅者只有订阅文章的权限，<code>wordpress</code>开启注册后默认注册的用户就是订阅者。国内很多知名网站，如<code>Freebuf</code>，用户注册后身份即为“订阅者”。</p><p>我们先看到一个提权漏洞，通过这个提权漏洞，我们作为一个订阅者，可以越权在数据库里插入一篇文章。</p><p><code>Wordpress</code>检查用户权限是调用<code>current_user_can</code>函数，我们看到这个函数：</p><p><img alt="enter image description here" img-src="2a8821de4d80b0e10481ad5b6434a49acaedccdc.jpg"></p><p>调用的<code>has_cap</code>方法，跟进</p><p><img alt="enter image description here" img-src="3aee8f53667e65d74297abecb8fc14b68897d98b.jpg"></p><p>再次跟进<code>map_meta_cap</code>函数：</p><p><img alt="enter image description here" img-src="1147e79da7612264e303eeb87e8796cab55ed684.jpg"></p><p>可以见到，这个函数是真正检查权限的。出错误的代码在检查<code>’edit_post’</code>和<code>’edit_page’</code>的部分：</p><p><img alt="enter image description here" img-src="7ba4df6239ca0e654d6d6f49995ac472a33b6f2b.jpg"></p><p>可见，这里当<code>$post</code>不存在的时候，直接<code>break</code>出<code>switch</code>逻辑了，后面所有检查的代码都没有执行。</p><p><code>$post</code>是要编辑的文章的ID，也就是说，如果我要编辑一篇不存在的文章，这里不检查权限直接返回。</p><p>正常情况下是没有问题的，因为不存在的文章也没有编辑一说了。</p><p>我们再看到后台编辑文章的部分：<code>/wp-admin/post.php</code></p><p><img alt="enter image description here" img-src="ba8170374008acd99db71676196e5275fb616ef8.jpg"></p><p>这里首先获取<code>$_GET[‘post’]</code>，找不到才获取<code>$_POST[‘post_ID’]</code>，也就是可以说此时的<code>$post_ID</code>是来自<code>GET</code>的。</p><p>但我们后面调用<code>current_user_can</code>函数时传入的<code>post_ID</code>却是来自<code>POST</code>的：</p><p><img alt="enter image description here" img-src="31ecc5ba430050486ac23bbb23e7e9a533c9c239.jpg"></p><p>这里就是一个逻辑问题，当我们在GET参数中传入正确的<code>postid</code>（这样在<code>get_post</code>的时候不会产生错误），而在<code>POST</code>参数中传入一个不存在的<code>postid</code>，那么就能够绕过检查<code>edit_post</code>权限的步骤。</p><p>但是这个逻辑错误暂时不能造成严重的危害，因为实际上编辑文章的代码在<code>edit_post</code>函数中，而这个函数取的<code>post_ID</code>来自<code>$_POST</code>。</p><h1>0x02获取_wpnonce绕过CSRF防御</h1><hr><p><code>wordpress</code>对于CSRF漏洞的防御措施是使用<code>_wpnonce</code>（也就是token），而且它的token很严格，不同的操作有不同的token。</p><p>比如我们这里，如果想调用edit_post函数，需要经过以下逻辑：</p><p><img alt="enter image description here" img-src="38bbf710958ea655ed0d47b3550c93aee386137c.jpg"></p><p><code>check_admin_referer</code>就是检查<code>_wpnonce</code>的函数，当<code>$post_type==’postajaxpost’</code>的时候，此时<code>_wpnonce</code>的名字就是<code>“add-postajaxpost”</code>。</p><p>那么怎么获取名字为<code>”add-postajaxpost”</code>的<code>_wpnonce</code>呢？</p><p>看到上面一点的位置：</p><p><img alt="enter image description here" img-src="5e3e0cae8c1f0c25e4e439fc44d4a32d1c972133.jpg"></p><p>有个<code>post-quickdraft-save</code>操作。这个操作是用来临时储存草稿的，只要用户访问这个操作，就会在数据库<code>post</code>表中插入一个<code>status</code>为<code>auto-draft</code>的新文章。</p><p>如上图画出来的步骤，因为我们不知道名字为<code>”add-post”</code>的<code>_wpnonce</code>，所以进入到<code>wp_dashboard_quick_press</code>函数，跟进：</p><p><img alt="enter image description here" img-src="73e10ee5a172138ddbd8a79edff9c3d703832b44.jpg"></p><p>见上图，很幸运的是，在这个函数中<code>wordpress</code>居然自己把此时的<code>_wpnonce</code>输出在表单里了。</p><p>所以，只要我们访问一次<code>post-quickdraft-save</code>，就可以获得<code>add-post</code>的<code>_wpnonce</code>，从而绕过<code>check_admin_referer</code>函数。</p><h1>0x03 竞争漏洞导致的逻辑漏洞</h1><hr><p>这一节实际上是这个提权洞的真正核心，在我们拿到<code>_wpnonce</code>后，进入<code>edit_post</code>函数。</p><p>我们目的是去update一篇文章，但刚才0x01中说到，如果要绕过权限检查的函数，需要传入一个“不存在”的文章id。那么即使可以执行update，我们也不可能修改已经存在的文章呀？</p><p>这里实际上涉及到一个由竞争造成的逻辑漏洞。看到<code>edit_post</code>函数代码：</p><p><img alt="enter image description here" img-src="3a753c8c65ab16b88587c5493ce5ec857f76dc63.jpg"></p><p>上面两个图应该很直观了。在0x01中说到的<code>current_user_can</code>被绕过以后，到最终执行<code>update</code>语句中间，这一段代码的执行时间是真空的。</p><p>比如我们传入的<code>tax_input=1,2,3,4…10000</code>，那么实际上那条查询语句就要执行10000次，这是需要执行很长时间的。（在我自己的虚拟机上测试，执行10000次这条语句，大概需要5~10秒左右）</p><p>那么假设在这段时间内，有新插入的文章，那么我们之前那个“不存在”的id，不就可能可以存在了吗（只需要把id设置为最新一篇文章id+1）？ 但有个问题是，我们怎么在这段时间内插入一篇新的文章？因为在0x02中为了获取<code>_wpnonce</code>，已经执行过<code>post-quickdraft-save</code>了。执行<code>post-quickdraft-save</code>可以在数据库插入一篇<code>status</code>为<code>auto-draft</code>的文章，但每个用户最多只会插入一篇文章。</p><p>在<code>check-point</code>的原文中，它提到的方法是，等待一个星期，<code>wordpress</code>会自动将这篇文章删除，而<code>_wpnonce</code>会多保留一天，这样在这天我们再次执行<code>post-quickdraft-save</code>又可以插入一篇文章了。</p><p>我自己想了一下，其实没必要这么麻烦。如果我们能够再注册一个身份为订阅者的账号，就可以再插入一篇文章了，所以我的POC是不需要等待一个礼拜的。</p><p>这三个漏洞组合起来，造成了一个提权漏洞。针对第一篇文章描述的提权漏洞，我写了一个EXP，执行后订阅者就可以在垃圾桶内插入一篇文章：</p><p><img alt="enter image description here" img-src="9b5631833132987335a9f09722f234f27e7329f2.jpg"></p><p>访问文章编辑页面可以看到这篇文章：</p><p><img alt="enter image description here" img-src="722c0775ca18ca7f0948b33ea6dc6b27279922db.jpg"></p><h1>0x04 untrash文章时造成的SQL注入漏洞</h1><hr><p>那么，仅仅是一个这样的提权漏洞，实际上没有太大意义。<code>Check-point</code>第二篇文章里提到了一个因为这个提权漏洞导致的SQL注入。</p><p>先说这个注入的原理。</p><pre><code>/wp-includes/post.php
</code></pre><p><img alt="enter image description here" img-src="7e58deca84f154568206e544da1a33421d11e5ee.jpg"></p><p>如上图。<code>Wordpress</code>很多地方执行SQL语句使用的预编译，但仅限于直接接受用户输入的地方。而上图中明显是一个二次操作，先用<code>get_post_meta</code>函数从数据库中取出meta，之后以字符串拼接的方式插入SQL语句。</p><p>这个地方造成一个二次注入。</p><p>我们来看看第一次是如何入库的。首先<code>wp_trash_post</code>是将文章删除的方法，其中删除文章后又调用<code>wp_trash_post_comments</code>将文章下的评论也删除了：</p><p><img alt="enter image description here" img-src="cdec570f9e748215982058f765bb57e2ea241090.jpg"></p><p>跟进<code>wp_trash_post_comments</code>函数：</p><p><img alt="enter image description here" img-src="9e293c14950c789ce0d81b84ed9e72c23b949a36.jpg"></p><p>如上图，可以看到这个<code>“comment_approved”</code>其实也是从数据库中取出来的。所以这个注入我称之为“三次注入”。</p><p>那么我再继续跟进，看看最早的<code>comment_approved</code>是从哪来的。</p><p>实际上看到图中的SQL语句就大概知道了，这个<code>comment_approved</code>是<code>comments</code>（评论）表的一个字段，我分别看了新增评论、修改评论两个函数，发现修改评论的函数（<code>edit_comment</code>）中，有涉及到这个字段：</p><p><img alt="enter image description here" img-src="d6c6610ceffd0a61dc0bbf0c4217e34c8a7708a2.jpg"></p><p>所以，这一连串操作最后造成的结果就是一个SQL注入漏洞。</p><p>总结一下1234，整个利用过程如下：</p><p>利用快速草稿插入文章->越权编辑文章->插入评论->修改评论（恶意数据入库）->删除文章（恶意数据进入另一个库）->反删除文章（恶意数据被取出，直接插入SQL语句导致注入）</p><h1>0x05 原文隐藏的部分与真实利用过程的研究</h1><hr><p>这里不得不提到<code>check-point</code>的原文，原文的第二篇全文只字未提<code>wordpress</code>的<code>token</code>也就是<code>_wpnonce</code>，但wordpress后台几乎所有操作都需要特定的<code>_wpnonce</code>。在第一步中我们通过一处泄露点获取了“<code>add-postajaxpost</code>”的<code>_wpnonce</code>，但实际上后面的每一步（增加、编辑评论、<code>trash</code>文章、<code>untrash</code>文章）都需要不同的<code>_wpnonce</code>，那么这些<code>_wpnonce</code>我们怎么获得？</p><p>经过我的分析，最后实在找不到在订阅者权限下怎么获得“增加评论”和“反删除文章”的<code>_wpnonce</code>，而“修改评论”、“删除文章”的<code>_wpnonce</code>倒是可以在后台找到。</p><p>另外，虽然前台也可以增加评论，但前台增加评论会检查所属文章是否是草稿、状态是否是<code>public</code>或<code>private</code>，我们没法给这篇文章以及其派生的预览文章增加评论。</p><p>所以我把基础账号的权限提升一下，提升到可以发表文章与编辑文章的作者权限，再来对注入漏洞进行复现。</p><p><img alt="enter image description here" img-src="baeea1c2281febd35fd128616266db9d21c96619.jpg"></p><p>首先发表一篇文章，并在该文下回复一条评论：</p><p><img alt="enter image description here" img-src="001980438b75b521bb96cf49f1774a1bef797085.jpg"></p><p>我们再来修改这条评论：</p><p><img alt="enter image description here" img-src="0f76012b53dd70159addaad10319274b71c3eb6e.jpg"></p><p>在文章编辑页面找到<code>trash</code>的<code>_wpnonce</code>，将该评论所属的文章丢入垃圾箱：</p><p><img alt="enter image description here" img-src="944a7ebdc7a8a4334e7deea3e26852b754678d08.jpg"></p><p>再找到反删除的<code>_wpnonce</code>，从垃圾箱里反删除这篇文章：</p><p><img alt="enter image description here" img-src="6782115648d9463f7662e5df2e8d99b360febb33.jpg"></p><p>查看SQL执行记录，发现已经注入成功，引入单引号：</p><p><img alt="enter image description here" img-src="e92fb667e4ca0240cba8858f6838d78780437374.jpg"></p><p>最后，我来总结一下这个漏洞。</p><p>这个漏洞有两个核心点，一是利用一个竞争条件逻辑错误，造成的一个越权漏洞；二是利用一个三次操作，导致最后的SQL注入漏洞。</p><p>这两个核心技术点都是很有代表性的，通篇学习下来，不得不佩服洞主的思路和对<code>wordpress</code>的研究深度。</p><p>但我也很遗憾，没能分析出在最低权限下怎样去注入，主要还是<code>_wpnonce</code>的获取导致漏洞利用上出现了一些问题。</p><p>另外，该SQL注入有一个不得不说的鸡肋点，在污染数据第一次入库的时候，数据库中保存这个数据的字段只有20字符长度，所以导致最后我们的注入点是一个“存在长度限制”的注入点，对于这个长度限制的利用，我也暂时没有想出更好的方法。</p><p>虽然存在长度限制，但因为注入点出现在update语句的评论表中，所以通过这个漏洞，可以将一整个站的评论全部置为0，对于像Freebuf这类社交性质的网站来说危害还是巨大的。</p><p>所以，我对这个SQL注入的评价是：利用上（可能）比较鸡肋，但思路是绝对一流的，值得学习。</p><p></p></section></article><div class="entry-controls clearfix"><div style="float:left;color:#9d9e9f;font-size:15px"><span>&copy;乌云知识库版权所有 未经许可 禁止转载</span></div></div><div class="yarpp-related"><h3>为您推荐了适合您的技术文章:</h3><ol id="recommandsystem"><li><a href="http://drops.wooyun.org/papers/8988" rel="bookmark" id="re1">WordPress Vulnerability Analysis (CVE-2015-5714 &amp; CVE-2015-5715)</a></li><li><a href="http://drops.wooyun.org/papers/7073" rel="bookmark" id="re2">OpenSSL-CVE-2015-1793漏洞分析</a></li><li><a href="http://drops.wooyun.org/papers/9809" rel="bookmark" id="re3">CVE-2015-1641漏洞分析</a></li><li><a href="http://drops.wooyun.org/papers/13040" rel="bookmark" id="re4">CVE-2015-7547简单分析与调试</a></li></ol></div><div id="comments" class="comment-list clearfix"><div id="comment-list"><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">winsyk</span> <span class="reply-time">2015-08-18 23:02:16</span></div><p></p><p>原文：http://blog.checkpoint.com/2015/08/04/wordpress-vulnerabilities-1/<br>http://blog.checkpoint.com/2015/08/11/finding-vulnerabilities-in-core-wordpress-a-bug-hunters-trilogy-part-ii-supremacy/</p><p></p></div></div><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">phith0n</span> <span class="reply-time">2015-08-18 19:37:48</span></div><p></p><p>有几张图掉了</p><p></p></div></div><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">jsbba</span> <span class="reply-time">2015-08-18 17:43:51</span></div><p></p><p>回去慢慢看</p><p></p></div></div><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">mramydnei</span> <span class="reply-time">2015-08-18 17:43:08</span></div><p></p><p>给跪了</p><p></p></div></div><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">chock</span> <span class="reply-time">2015-08-18 12:29:26</span></div><p></p><p>妈妈问我为什么要跪着看电脑</p><p></p></div></div></div></div></div></main>